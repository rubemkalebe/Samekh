Terminais não utilizados na gramática

   CHAR
   OP_PTR
   SIZEOF
   TYPEOF


Estado 119 conflitos: 1 de deslocamento/redução


Gramática

    0 $accept: translation_unit $end

    1 translation_unit: program_file

    2 program_file: declarations

    3 declarations: declaration
    4             | declarations declaration

    5 declaration: function_declaration
    6            | procedure_declaration
    7            | type_declaration
    8            | variable_declaration

    9 function_declaration: FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION

   10 procedure_declaration: PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE

   11 subprogram_declarator: IDENTIFIER L_PAREN parameter_list R_PAREN
   12                      | IDENTIFIER L_PAREN R_PAREN

   13 parameter_list: parameter
   14               | parameter_list COMMA parameter

   15 parameter: type_specifier declarator_name
   16          | CONST type_specifier declarator_name

   17 subprogram_body: block
   18                | SEMICOLON

   19 block: local_variable_declarations_and_statements

   20 local_variable_declarations_and_statements: local_variable_declarations_or_statements
   21                                           | local_variable_declarations_and_statements local_variable_declarations_or_statements

   22 local_variable_declarations_or_statements: local_variable_declaration_statement
   23                                          | statement

   24 local_variable_declaration_statement: type_specifier variable_declarators SEMICOLON
   25                                     | STATIC type_specifier variable_declarators SEMICOLON

   26 statement: assignment_expression SEMICOLON
   27          | selection_statement
   28          | iteration_statement
   29          | jump_statement
   30          | read_statement
   31          | print_statement
   32          | println_statement

   33 selection_statement: IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | IF L_PAREN expression R_PAREN block END_IF

   36 elsif_staments: elsif_stament
   37               | elsif_staments ELSIF elsif_stament
   38               | ELSE block

   39 elsif_stament: L_PAREN expression R_PAREN block

   40 iteration_statement: WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | FOR L_PAREN for_init for_expr R_PAREN block END_FOR

   43 for_init: expression_statements SEMICOLON
   44         | local_variable_declaration_statement
   45         | SEMICOLON

   46 for_expr: expression SEMICOLON
   47         | SEMICOLON

   48 for_incr: expression_statements

   49 expression_statements: expression_statement
   50                      | expression_statements COMMA expression_statement

   51 expression_statement: expression

   52 jump_statement: BREAK IDENTIFIER SEMICOLON
   53               | BREAK SEMICOLON
   54               | CONTINUE IDENTIFIER SEMICOLON
   55               | CONTINUE SEMICOLON
   56               | RETURN expression SEMICOLON
   57               | RETURN SEMICOLON

   58 read_statement: READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON

   60 print_statement: PRINT L_PAREN expression R_PAREN SEMICOLON

   61 println_statement: PRINTLN L_PAREN expression R_PAREN SEMICOLON

   62 type_declaration: STRUCT IDENTIFIER variable_declarations END_STRUCT
   63                 | UNION IDENTIFIER discriminant union_body END_UNION
   64                 | ENUM IDENTIFIER enumerator_list END_ENUM

   65 variable_declarations: variable_declaration
   66                      | variable_declarations variable_declaration

   67 variable_declaration: modifiers type_specifier variable_declarators SEMICOLON
   68                     | type_specifier variable_declarators SEMICOLON

   69 modifiers: modifier
   70          | modifiers modifier

   71 modifier: CONST
   72         | STATIC

   73 type_specifier: type_name

   74 type_name: primitive_type
   75          | qualified_name

   76 primitive_type: AUTO
   77               | BOOL
   78               | INT
   79               | LONG
   80               | FLOAT
   81               | STRING

   82 discriminant: L_PAREN type_specifier declarator_name R_PAREN
   83             | %empty

   84 enumerator_list: enumerator
   85                | enumerator_list COMMA enumerator

   86 enumerator: IDENTIFIER ASSIGN expression
   87           | IDENTIFIER

   88 qualified_name: IDENTIFIER

   89 union_body: variable_declarations short_case_statement
   90           | variable_declarations

   91 short_case_statement: CASE IDENTIFIER choices END_CASE

   92 choices: choice
   93        | choices choice

   94 choice: WHEN IDENTIFIER THEN variable_declarations

   95 variable_declarators: variable_declarator
   96                     | variable_declarators COMMA variable_declarator

   97 variable_declarator: declarator_name
   98                    | declarator_name ASSIGN variable_initializer

   99 declarator_name: IDENTIFIER
  100                | declarator_name dim_exprs

  101 variable_initializer: expression
  102                     | L_BRACE R_BRACE
  103                     | L_BRACE array_initializers R_BRACE

  104 array_initializers: variable_initializer
  105                   | array_initializers COMMA variable_initializer
  106                   | array_initializers COMMA

  107 expression: assignment_expression

  108 assignment_expression: conditional_or_expression
  109                      | unary_expression assignment_operator assignment_expression

  110 unary_expression: arithmetic_unary_operator cast_expression
  111                 | logical_unary_expression

  112 logical_unary_expression: postfix_expression
  113                         | logical_unary_operator unary_expression

  114 postfix_expression: primary_expression

  115 primary_expression: qualified_name
  116                   | not_just_name

  117 arithmetic_unary_operator: OP_PLUS
  118                          | OP_MINUS

  119 logical_unary_operator: BITWISE_COMPLEMENT
  120                       | LOG_NOT

  121 conditional_or_expression: conditional_and_expression
  122                          | conditional_or_expression LOG_OR conditional_and_expression
  123                          | conditional_or_expression LOG_SC_OR conditional_and_expression

  124 conditional_and_expression: inclusive_or_expression
  125                           | conditional_and_expression LOG_AND inclusive_or_expression
  126                           | conditional_and_expression LOG_SC_AND inclusive_or_expression

  127 inclusive_or_expression: exclusive_or_expression
  128                        | inclusive_or_expression BITWISE_OR exclusive_or_expression

  129 exclusive_or_expression: and_expression
  130                        | exclusive_or_expression BITWISE_OR_EXC and_expression

  131 and_expression: equality_expression
  132               | and_expression AMPERSAND equality_expression

  133 equality_expression: relational_expression
  134                    | equality_expression OP_EQ relational_expression
  135                    | equality_expression OP_NE relational_expression

  136 relational_expression: shift_expression
  137                      | relational_expression OP_LT shift_expression
  138                      | relational_expression OP_GT shift_expression
  139                      | relational_expression OP_LET shift_expression
  140                      | relational_expression OP_GET shift_expression

  141 shift_expression: additive_expression
  142                 | shift_expression L_SHIFT additive_expression
  143                 | shift_expression R_SHIFT additive_expression

  144 additive_expression: multiplicative_expression
  145                    | additive_expression OP_PLUS multiplicative_expression
  146                    | additive_expression OP_MINUS multiplicative_expression

  147 multiplicative_expression: cast_expression
  148                          | multiplicative_expression OP_ASTERISK cast_expression
  149                          | multiplicative_expression OP_DIV cast_expression
  150                          | multiplicative_expression OP_MOD cast_expression

  151 cast_expression: unary_expression
  152                | L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | L_PAREN user_type_expression R_PAREN cast_expression
  154                | L_PAREN expression R_PAREN logical_unary_expression

  155 primitive_type_expression: primitive_type
  156                          | primitive_type dims

  157 user_type_expression: qualified_name dims

  158 assignment_operator: ASSIGN
  159                    | ASSIGN_PLUS
  160                    | ASSIGN_MINUS
  161                    | ASSIGN_PRODUCT
  162                    | ASSIGN_DIV
  163                    | ASSIGN_MOD
  164                    | ASSIGN_BITWISE_AND
  165                    | ASSIGN_BITWISE_OR
  166                    | ASSIGN_BITWISE_OR_EXC
  167                    | ASSIGN_L_SHIFT
  168                    | ASSIGN_R_SHIFT

  169 not_just_name: complex_primary

  170 complex_primary: L_PAREN expression R_PAREN
  171                | complex_primary_no_parenthesis

  172 complex_primary_no_parenthesis: BOOL_LITERAL
  173                               | OCTAL
  174                               | DECIMAL
  175                               | HEX
  176                               | FLOATING_POINT
  177                               | NNULL
  178                               | STRING_LITERAL
  179                               | array_access
  180                               | field_access
  181                               | subprogram_call

  182 array_access: qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | complex_primary L_SQ_PAREN expression R_SQ_PAREN

  184 field_access: postfix_expression DOT IDENTIFIER

  185 subprogram_call: subprogram_access L_PAREN argument_list R_PAREN
  186                | subprogram_access L_PAREN R_PAREN

  187 subprogram_access: complex_primary_no_parenthesis
  188                  | qualified_name

  189 argument_list: expression
  190              | argument_list COMMA expression

  191 dim_exprs: dim_expr
  192          | dim_exprs dim_expr

  193 dim_expr: L_SQ_PAREN expression R_SQ_PAREN

  194 dims: L_SQ_PAREN R_SQ_PAREN
  195     | dims L_SQ_PAREN R_SQ_PAREN


Terminais, com as regras onde eles aparecem

$end (0) 0
error (256)
IDENTIFIER (258) 11 12 52 54 62 63 64 86 87 88 91 94 99 184
ASSIGN (259) 86 98 158
ASSIGN_PLUS (260) 159
ASSIGN_MINUS (261) 160
ASSIGN_PRODUCT (262) 161
ASSIGN_DIV (263) 162
ASSIGN_MOD (264) 163
ASSIGN_BITWISE_AND (265) 164
ASSIGN_BITWISE_OR (266) 165
ASSIGN_BITWISE_OR_EXC (267) 166
ASSIGN_L_SHIFT (268) 167
ASSIGN_R_SHIFT (269) 168
AMPERSAND (270) 132
AUTO (271) 76
BOOL (272) 77
BREAK (273) 52 53
BITWISE_COMPLEMENT (274) 119
BITWISE_OR (275) 128
BITWISE_OR_EXC (276) 130
DOT (277) 184
CHAR (278)
COMMA (279) 14 50 58 85 96 105 106 190
CONTINUE (280) 54 55
CONST (281) 16 71
ENUM (282) 64
ELSE (283) 34 38
ELSIF (284) 33 37
FLOAT (285) 80
FOR (286) 41 42
IF (287) 33 34 35
INT (288) 78
L_PAREN (289) 11 12 33 34 35 39 40 41 42 58 59 60 61 82 152 153 154
    170 185 186
L_SQ_PAREN (290) 182 183 193 194 195
L_BRACE (291) 102 103
L_SHIFT (292) 142
LOG_NOT (293) 120
LOG_AND (294) 125
LOG_OR (295) 122
LOG_SC_AND (296) 126
LOG_SC_OR (297) 123
LONG (298) 79
OP_EQ (299) 134
OP_NE (300) 135
OP_PTR (301)
OP_PLUS (302) 117 145
OP_MINUS (303) 118 146
OP_ASTERISK (304) 148
OP_DIV (305) 149
OP_MOD (306) 150
OP_LET (307) 139
OP_LT (308) 137
OP_GET (309) 140
OP_GT (310) 138
PRINT (311) 60
PRINTLN (312) 61
R_PAREN (313) 11 12 33 34 35 39 40 41 42 58 59 60 61 82 152 153 154
    170 185 186
R_SQ_PAREN (314) 182 183 193 194 195
R_BRACE (315) 102 103
R_SHIFT (316) 143
STRING (317) 81
STRUCT (318) 62
STATIC (319) 25 72
SIZEOF (320)
READ (321) 58 59
RETURN (322) 56 57
SEMICOLON (323) 18 24 25 26 43 45 46 47 52 53 54 55 56 57 58 59 60
    61 67 68
UNION (324) 63
WHILE (325) 40
CASE (326) 91
END_CASE (327) 91
END_ENUM (328) 64
END_FOR (329) 41 42
END_FUNCTION (330) 9
END_IF (331) 33 34 35
END_PROCEDURE (332) 10
END_STRUCT (333) 62
END_UNION (334) 63
END_WHILE (335) 40
FUNCTION (336) 9
PROCEDURE (337) 10
THEN (338) 94
TYPEOF (339)
WHEN (340) 94
STRING_LITERAL (341) 58 59 178
DECIMAL (342) 174
HEX (343) 175
OCTAL (344) 173
FLOATING_POINT (345) 176
BOOL_LITERAL (346) 172
NNULL (347) 177


Não-terminais com as regras onde eles aparecem

$accept (93)
    à esquerda: 0
translation_unit (94)
    à esquerda: 1, à direita: 0
program_file (95)
    à esquerda: 2, à direita: 1
declarations (96)
    à esquerda: 3 4, à direita: 2 4
declaration (97)
    à esquerda: 5 6 7 8, à direita: 3 4
function_declaration (98)
    à esquerda: 9, à direita: 5
procedure_declaration (99)
    à esquerda: 10, à direita: 6
subprogram_declarator (100)
    à esquerda: 11 12, à direita: 9 10
parameter_list (101)
    à esquerda: 13 14, à direita: 11 14
parameter (102)
    à esquerda: 15 16, à direita: 13 14
subprogram_body (103)
    à esquerda: 17 18, à direita: 9 10
block (104)
    à esquerda: 19, à direita: 17 33 34 35 38 39 40 41 42
local_variable_declarations_and_statements (105)
    à esquerda: 20 21, à direita: 19 21
local_variable_declarations_or_statements (106)
    à esquerda: 22 23, à direita: 20 21
local_variable_declaration_statement (107)
    à esquerda: 24 25, à direita: 22 44
statement (108)
    à esquerda: 26 27 28 29 30 31 32, à direita: 23
selection_statement (109)
    à esquerda: 33 34 35, à direita: 27
elsif_staments (110)
    à esquerda: 36 37 38, à direita: 33 37
elsif_stament (111)
    à esquerda: 39, à direita: 36 37
iteration_statement (112)
    à esquerda: 40 41 42, à direita: 28
for_init (113)
    à esquerda: 43 44 45, à direita: 41 42
for_expr (114)
    à esquerda: 46 47, à direita: 41 42
for_incr (115)
    à esquerda: 48, à direita: 41
expression_statements (116)
    à esquerda: 49 50, à direita: 43 48 50
expression_statement (117)
    à esquerda: 51, à direita: 49 50
jump_statement (118)
    à esquerda: 52 53 54 55 56 57, à direita: 29
read_statement (119)
    à esquerda: 58 59, à direita: 30
print_statement (120)
    à esquerda: 60, à direita: 31
println_statement (121)
    à esquerda: 61, à direita: 32
type_declaration (122)
    à esquerda: 62 63 64, à direita: 7
variable_declarations (123)
    à esquerda: 65 66, à direita: 62 66 89 90 94
variable_declaration (124)
    à esquerda: 67 68, à direita: 8 65 66
modifiers (125)
    à esquerda: 69 70, à direita: 67 70
modifier (126)
    à esquerda: 71 72, à direita: 69 70
type_specifier (127)
    à esquerda: 73, à direita: 9 15 16 24 25 67 68 82
type_name (128)
    à esquerda: 74 75, à direita: 73
primitive_type (129)
    à esquerda: 76 77 78 79 80 81, à direita: 74 155 156
discriminant (130)
    à esquerda: 82 83, à direita: 63
enumerator_list (131)
    à esquerda: 84 85, à direita: 64 85
enumerator (132)
    à esquerda: 86 87, à direita: 84 85
qualified_name (133)
    à esquerda: 88, à direita: 75 115 157 182 188
union_body (134)
    à esquerda: 89 90, à direita: 63
short_case_statement (135)
    à esquerda: 91, à direita: 89
choices (136)
    à esquerda: 92 93, à direita: 91 93
choice (137)
    à esquerda: 94, à direita: 92 93
variable_declarators (138)
    à esquerda: 95 96, à direita: 24 25 67 68 96
variable_declarator (139)
    à esquerda: 97 98, à direita: 95 96
declarator_name (140)
    à esquerda: 99 100, à direita: 15 16 82 97 98 100
variable_initializer (141)
    à esquerda: 101 102 103, à direita: 98 104 105
array_initializers (142)
    à esquerda: 104 105 106, à direita: 103 105 106
expression (143)
    à esquerda: 107, à direita: 33 34 35 39 40 46 51 56 60 61 86
    101 154 170 182 183 189 190 193
assignment_expression (144)
    à esquerda: 108 109, à direita: 26 107 109
unary_expression (145)
    à esquerda: 110 111, à direita: 109 113 151
logical_unary_expression (146)
    à esquerda: 112 113, à direita: 111 154
postfix_expression (147)
    à esquerda: 114, à direita: 112 184
primary_expression (148)
    à esquerda: 115 116, à direita: 114
arithmetic_unary_operator (149)
    à esquerda: 117 118, à direita: 110
logical_unary_operator (150)
    à esquerda: 119 120, à direita: 113
conditional_or_expression (151)
    à esquerda: 121 122 123, à direita: 108 122 123
conditional_and_expression (152)
    à esquerda: 124 125 126, à direita: 121 122 123 125 126
inclusive_or_expression (153)
    à esquerda: 127 128, à direita: 124 125 126 128
exclusive_or_expression (154)
    à esquerda: 129 130, à direita: 127 128 130
and_expression (155)
    à esquerda: 131 132, à direita: 129 130 132
equality_expression (156)
    à esquerda: 133 134 135, à direita: 131 132 134 135
relational_expression (157)
    à esquerda: 136 137 138 139 140, à direita: 133 134 135 137 138
    139 140
shift_expression (158)
    à esquerda: 141 142 143, à direita: 136 137 138 139 140 142 143
additive_expression (159)
    à esquerda: 144 145 146, à direita: 141 142 143 145 146
multiplicative_expression (160)
    à esquerda: 147 148 149 150, à direita: 144 145 146 148 149 150
cast_expression (161)
    à esquerda: 151 152 153 154, à direita: 110 147 148 149 150 152
    153
primitive_type_expression (162)
    à esquerda: 155 156, à direita: 152
user_type_expression (163)
    à esquerda: 157, à direita: 153
assignment_operator (164)
    à esquerda: 158 159 160 161 162 163 164 165 166 167 168, à direita:
    109
not_just_name (165)
    à esquerda: 169, à direita: 116
complex_primary (166)
    à esquerda: 170 171, à direita: 169 183
complex_primary_no_parenthesis (167)
    à esquerda: 172 173 174 175 176 177 178 179 180 181, à direita:
    171 187
array_access (168)
    à esquerda: 182 183, à direita: 179
field_access (169)
    à esquerda: 184, à direita: 180
subprogram_call (170)
    à esquerda: 185 186, à direita: 181
subprogram_access (171)
    à esquerda: 187 188, à direita: 185 186
argument_list (172)
    à esquerda: 189 190, à direita: 58 185 190
dim_exprs (173)
    à esquerda: 191 192, à direita: 100 192
dim_expr (174)
    à esquerda: 193, à direita: 191 192
dims (175)
    à esquerda: 194 195, à direita: 156 157 195


State 0

    0 $accept: . translation_unit $end
    1 translation_unit: . program_file
    2 program_file: . declarations
    3 declarations: . declaration
    4             | . declarations declaration
    5 declaration: . function_declaration
    6            | . procedure_declaration
    7            | . type_declaration
    8            | . variable_declaration
    9 function_declaration: . FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION
   10 procedure_declaration: . PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE
   62 type_declaration: . STRUCT IDENTIFIER variable_declarations END_STRUCT
   63                 | . UNION IDENTIFIER discriminant union_body END_UNION
   64                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 4
    ENUM        deslocar, e ir ao estado 5
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9
    STRUCT      deslocar, e ir ao estado 10
    STATIC      deslocar, e ir ao estado 11
    UNION       deslocar, e ir ao estado 12
    FUNCTION    deslocar, e ir ao estado 13
    PROCEDURE   deslocar, e ir ao estado 14

    translation_unit       ir ao estado 15
    program_file           ir ao estado 16
    declarations           ir ao estado 17
    declaration            ir ao estado 18
    function_declaration   ir ao estado 19
    procedure_declaration  ir ao estado 20
    type_declaration       ir ao estado 21
    variable_declaration   ir ao estado 22
    modifiers              ir ao estado 23
    modifier               ir ao estado 24
    type_specifier         ir ao estado 25
    type_name              ir ao estado 26
    primitive_type         ir ao estado 27
    qualified_name         ir ao estado 28


State 1

   88 qualified_name: IDENTIFIER .

    $padrão  reduzir usando a regra 88 (qualified_name)


State 2

   76 primitive_type: AUTO .

    $padrão  reduzir usando a regra 76 (primitive_type)


State 3

   77 primitive_type: BOOL .

    $padrão  reduzir usando a regra 77 (primitive_type)


State 4

   71 modifier: CONST .

    $padrão  reduzir usando a regra 71 (modifier)


State 5

   64 type_declaration: ENUM . IDENTIFIER enumerator_list END_ENUM

    IDENTIFIER  deslocar, e ir ao estado 29


State 6

   80 primitive_type: FLOAT .

    $padrão  reduzir usando a regra 80 (primitive_type)


State 7

   78 primitive_type: INT .

    $padrão  reduzir usando a regra 78 (primitive_type)


State 8

   79 primitive_type: LONG .

    $padrão  reduzir usando a regra 79 (primitive_type)


State 9

   81 primitive_type: STRING .

    $padrão  reduzir usando a regra 81 (primitive_type)


State 10

   62 type_declaration: STRUCT . IDENTIFIER variable_declarations END_STRUCT

    IDENTIFIER  deslocar, e ir ao estado 30


State 11

   72 modifier: STATIC .

    $padrão  reduzir usando a regra 72 (modifier)


State 12

   63 type_declaration: UNION . IDENTIFIER discriminant union_body END_UNION

    IDENTIFIER  deslocar, e ir ao estado 31


State 13

    9 function_declaration: FUNCTION . type_specifier subprogram_declarator subprogram_body END_FUNCTION
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9

    type_specifier  ir ao estado 32
    type_name       ir ao estado 26
    primitive_type  ir ao estado 27
    qualified_name  ir ao estado 28


State 14

   10 procedure_declaration: PROCEDURE . subprogram_declarator subprogram_body END_PROCEDURE
   11 subprogram_declarator: . IDENTIFIER L_PAREN parameter_list R_PAREN
   12                      | . IDENTIFIER L_PAREN R_PAREN

    IDENTIFIER  deslocar, e ir ao estado 33

    subprogram_declarator  ir ao estado 34


State 15

    0 $accept: translation_unit . $end

    $end  deslocar, e ir ao estado 35


State 16

    1 translation_unit: program_file .

    $padrão  reduzir usando a regra 1 (translation_unit)


State 17

    2 program_file: declarations .  [$end]
    4 declarations: declarations . declaration
    5 declaration: . function_declaration
    6            | . procedure_declaration
    7            | . type_declaration
    8            | . variable_declaration
    9 function_declaration: . FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION
   10 procedure_declaration: . PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE
   62 type_declaration: . STRUCT IDENTIFIER variable_declarations END_STRUCT
   63                 | . UNION IDENTIFIER discriminant union_body END_UNION
   64                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 4
    ENUM        deslocar, e ir ao estado 5
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9
    STRUCT      deslocar, e ir ao estado 10
    STATIC      deslocar, e ir ao estado 11
    UNION       deslocar, e ir ao estado 12
    FUNCTION    deslocar, e ir ao estado 13
    PROCEDURE   deslocar, e ir ao estado 14

    $padrão  reduzir usando a regra 2 (program_file)

    declaration            ir ao estado 36
    function_declaration   ir ao estado 19
    procedure_declaration  ir ao estado 20
    type_declaration       ir ao estado 21
    variable_declaration   ir ao estado 22
    modifiers              ir ao estado 23
    modifier               ir ao estado 24
    type_specifier         ir ao estado 25
    type_name              ir ao estado 26
    primitive_type         ir ao estado 27
    qualified_name         ir ao estado 28


State 18

    3 declarations: declaration .

    $padrão  reduzir usando a regra 3 (declarations)


State 19

    5 declaration: function_declaration .

    $padrão  reduzir usando a regra 5 (declaration)


State 20

    6 declaration: procedure_declaration .

    $padrão  reduzir usando a regra 6 (declaration)


State 21

    7 declaration: type_declaration .

    $padrão  reduzir usando a regra 7 (declaration)


State 22

    8 declaration: variable_declaration .

    $padrão  reduzir usando a regra 8 (declaration)


State 23

   67 variable_declaration: modifiers . type_specifier variable_declarators SEMICOLON
   70 modifiers: modifiers . modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 4
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9
    STATIC      deslocar, e ir ao estado 11

    modifier        ir ao estado 37
    type_specifier  ir ao estado 38
    type_name       ir ao estado 26
    primitive_type  ir ao estado 27
    qualified_name  ir ao estado 28


State 24

   69 modifiers: modifier .

    $padrão  reduzir usando a regra 69 (modifiers)


State 25

   68 variable_declaration: type_specifier . variable_declarators SEMICOLON
   95 variable_declarators: . variable_declarator
   96                     | . variable_declarators COMMA variable_declarator
   97 variable_declarator: . declarator_name
   98                    | . declarator_name ASSIGN variable_initializer
   99 declarator_name: . IDENTIFIER
  100                | . declarator_name dim_exprs

    IDENTIFIER  deslocar, e ir ao estado 39

    variable_declarators  ir ao estado 40
    variable_declarator   ir ao estado 41
    declarator_name       ir ao estado 42


State 26

   73 type_specifier: type_name .

    $padrão  reduzir usando a regra 73 (type_specifier)


State 27

   74 type_name: primitive_type .

    $padrão  reduzir usando a regra 74 (type_name)


State 28

   75 type_name: qualified_name .

    $padrão  reduzir usando a regra 75 (type_name)


State 29

   64 type_declaration: ENUM IDENTIFIER . enumerator_list END_ENUM
   84 enumerator_list: . enumerator
   85                | . enumerator_list COMMA enumerator
   86 enumerator: . IDENTIFIER ASSIGN expression
   87           | . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 43

    enumerator_list  ir ao estado 44
    enumerator       ir ao estado 45


State 30

   62 type_declaration: STRUCT IDENTIFIER . variable_declarations END_STRUCT
   65 variable_declarations: . variable_declaration
   66                      | . variable_declarations variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 4
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9
    STATIC      deslocar, e ir ao estado 11

    variable_declarations  ir ao estado 46
    variable_declaration   ir ao estado 47
    modifiers              ir ao estado 23
    modifier               ir ao estado 24
    type_specifier         ir ao estado 25
    type_name              ir ao estado 26
    primitive_type         ir ao estado 27
    qualified_name         ir ao estado 28


State 31

   63 type_declaration: UNION IDENTIFIER . discriminant union_body END_UNION
   82 discriminant: . L_PAREN type_specifier declarator_name R_PAREN
   83             | . %empty  [IDENTIFIER, AUTO, BOOL, CONST, FLOAT, INT, LONG, STRING, STATIC]

    L_PAREN  deslocar, e ir ao estado 48

    $padrão  reduzir usando a regra 83 (discriminant)

    discriminant  ir ao estado 49


State 32

    9 function_declaration: FUNCTION type_specifier . subprogram_declarator subprogram_body END_FUNCTION
   11 subprogram_declarator: . IDENTIFIER L_PAREN parameter_list R_PAREN
   12                      | . IDENTIFIER L_PAREN R_PAREN

    IDENTIFIER  deslocar, e ir ao estado 33

    subprogram_declarator  ir ao estado 50


State 33

   11 subprogram_declarator: IDENTIFIER . L_PAREN parameter_list R_PAREN
   12                      | IDENTIFIER . L_PAREN R_PAREN

    L_PAREN  deslocar, e ir ao estado 51


State 34

   10 procedure_declaration: PROCEDURE subprogram_declarator . subprogram_body END_PROCEDURE
   17 subprogram_body: . block
   18                | . SEMICOLON
   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 52
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    CONTINUE            deslocar, e ir ao estado 54
    FLOAT               deslocar, e ir ao estado 6
    FOR                 deslocar, e ir ao estado 55
    IF                  deslocar, e ir ao estado 56
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    PRINT               deslocar, e ir ao estado 61
    PRINTLN             deslocar, e ir ao estado 62
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    READ                deslocar, e ir ao estado 64
    RETURN              deslocar, e ir ao estado 65
    SEMICOLON           deslocar, e ir ao estado 66
    WHILE               deslocar, e ir ao estado 67
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    subprogram_body                             ir ao estado 75
    block                                       ir ao estado 76
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 26
    primitive_type                              ir ao estado 27
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 35

    0 $accept: translation_unit $end .

    $padrão  aceitar


State 36

    4 declarations: declarations declaration .

    $padrão  reduzir usando a regra 4 (declarations)


State 37

   70 modifiers: modifiers modifier .

    $padrão  reduzir usando a regra 70 (modifiers)


State 38

   67 variable_declaration: modifiers type_specifier . variable_declarators SEMICOLON
   95 variable_declarators: . variable_declarator
   96                     | . variable_declarators COMMA variable_declarator
   97 variable_declarator: . declarator_name
   98                    | . declarator_name ASSIGN variable_initializer
   99 declarator_name: . IDENTIFIER
  100                | . declarator_name dim_exprs

    IDENTIFIER  deslocar, e ir ao estado 39

    variable_declarators  ir ao estado 114
    variable_declarator   ir ao estado 41
    declarator_name       ir ao estado 42


State 39

   99 declarator_name: IDENTIFIER .

    $padrão  reduzir usando a regra 99 (declarator_name)


State 40

   68 variable_declaration: type_specifier variable_declarators . SEMICOLON
   96 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 115
    SEMICOLON  deslocar, e ir ao estado 116


State 41

   95 variable_declarators: variable_declarator .

    $padrão  reduzir usando a regra 95 (variable_declarators)


State 42

   97 variable_declarator: declarator_name .  [COMMA, SEMICOLON]
   98                    | declarator_name . ASSIGN variable_initializer
  100 declarator_name: declarator_name . dim_exprs
  191 dim_exprs: . dim_expr
  192          | . dim_exprs dim_expr
  193 dim_expr: . L_SQ_PAREN expression R_SQ_PAREN

    ASSIGN      deslocar, e ir ao estado 117
    L_SQ_PAREN  deslocar, e ir ao estado 118

    $padrão  reduzir usando a regra 97 (variable_declarator)

    dim_exprs  ir ao estado 119
    dim_expr   ir ao estado 120


State 43

   86 enumerator: IDENTIFIER . ASSIGN expression
   87           | IDENTIFIER .  [COMMA, END_ENUM]

    ASSIGN  deslocar, e ir ao estado 121

    $padrão  reduzir usando a regra 87 (enumerator)


State 44

   64 type_declaration: ENUM IDENTIFIER enumerator_list . END_ENUM
   85 enumerator_list: enumerator_list . COMMA enumerator

    COMMA     deslocar, e ir ao estado 122
    END_ENUM  deslocar, e ir ao estado 123


State 45

   84 enumerator_list: enumerator .

    $padrão  reduzir usando a regra 84 (enumerator_list)


State 46

   62 type_declaration: STRUCT IDENTIFIER variable_declarations . END_STRUCT
   66 variable_declarations: variable_declarations . variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 4
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9
    STATIC      deslocar, e ir ao estado 11
    END_STRUCT  deslocar, e ir ao estado 124

    variable_declaration  ir ao estado 125
    modifiers             ir ao estado 23
    modifier              ir ao estado 24
    type_specifier        ir ao estado 25
    type_name             ir ao estado 26
    primitive_type        ir ao estado 27
    qualified_name        ir ao estado 28


State 47

   65 variable_declarations: variable_declaration .

    $padrão  reduzir usando a regra 65 (variable_declarations)


State 48

   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   82 discriminant: L_PAREN . type_specifier declarator_name R_PAREN
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9

    type_specifier  ir ao estado 126
    type_name       ir ao estado 26
    primitive_type  ir ao estado 27
    qualified_name  ir ao estado 28


State 49

   63 type_declaration: UNION IDENTIFIER discriminant . union_body END_UNION
   65 variable_declarations: . variable_declaration
   66                      | . variable_declarations variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
   89 union_body: . variable_declarations short_case_statement
   90           | . variable_declarations

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 4
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9
    STATIC      deslocar, e ir ao estado 11

    variable_declarations  ir ao estado 127
    variable_declaration   ir ao estado 47
    modifiers              ir ao estado 23
    modifier               ir ao estado 24
    type_specifier         ir ao estado 25
    type_name              ir ao estado 26
    primitive_type         ir ao estado 27
    qualified_name         ir ao estado 28
    union_body             ir ao estado 128


State 50

    9 function_declaration: FUNCTION type_specifier subprogram_declarator . subprogram_body END_FUNCTION
   17 subprogram_body: . block
   18                | . SEMICOLON
   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 52
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    CONTINUE            deslocar, e ir ao estado 54
    FLOAT               deslocar, e ir ao estado 6
    FOR                 deslocar, e ir ao estado 55
    IF                  deslocar, e ir ao estado 56
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    PRINT               deslocar, e ir ao estado 61
    PRINTLN             deslocar, e ir ao estado 62
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    READ                deslocar, e ir ao estado 64
    RETURN              deslocar, e ir ao estado 65
    SEMICOLON           deslocar, e ir ao estado 66
    WHILE               deslocar, e ir ao estado 67
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    subprogram_body                             ir ao estado 129
    block                                       ir ao estado 76
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 26
    primitive_type                              ir ao estado 27
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 51

   11 subprogram_declarator: IDENTIFIER L_PAREN . parameter_list R_PAREN
   12                      | IDENTIFIER L_PAREN . R_PAREN
   13 parameter_list: . parameter
   14               | . parameter_list COMMA parameter
   15 parameter: . type_specifier declarator_name
   16          | . CONST type_specifier declarator_name
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 130
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    R_PAREN     deslocar, e ir ao estado 131
    STRING      deslocar, e ir ao estado 9

    parameter_list  ir ao estado 132
    parameter       ir ao estado 133
    type_specifier  ir ao estado 134
    type_name       ir ao estado 26
    primitive_type  ir ao estado 27
    qualified_name  ir ao estado 28


State 52

   52 jump_statement: BREAK . IDENTIFIER SEMICOLON
   53               | BREAK . SEMICOLON

    IDENTIFIER  deslocar, e ir ao estado 135
    SEMICOLON   deslocar, e ir ao estado 136


State 53

  119 logical_unary_operator: BITWISE_COMPLEMENT .

    $padrão  reduzir usando a regra 119 (logical_unary_operator)


State 54

   54 jump_statement: CONTINUE . IDENTIFIER SEMICOLON
   55               | CONTINUE . SEMICOLON

    IDENTIFIER  deslocar, e ir ao estado 137
    SEMICOLON   deslocar, e ir ao estado 138


State 55

   41 iteration_statement: FOR . L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | FOR . L_PAREN for_init for_expr R_PAREN block END_FOR

    L_PAREN  deslocar, e ir ao estado 139


State 56

   33 selection_statement: IF . L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | IF . L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | IF . L_PAREN expression R_PAREN block END_IF

    L_PAREN  deslocar, e ir ao estado 140


State 57

   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  152                | L_PAREN . primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  153                | L_PAREN . user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  154                | L_PAREN . expression R_PAREN logical_unary_expression
  155 primitive_type_expression: . primitive_type
  156                          | . primitive_type dims
  157 user_type_expression: . qualified_name dims
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  170                | L_PAREN . expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    FLOAT               deslocar, e ir ao estado 6
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING              deslocar, e ir ao estado 9
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    primitive_type                  ir ao estado 141
    qualified_name                  ir ao estado 142
    expression                      ir ao estado 143
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    primitive_type_expression       ir ao estado 145
    user_type_expression            ir ao estado 146
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 58

  120 logical_unary_operator: LOG_NOT .

    $padrão  reduzir usando a regra 120 (logical_unary_operator)


State 59

  117 arithmetic_unary_operator: OP_PLUS .

    $padrão  reduzir usando a regra 117 (arithmetic_unary_operator)


State 60

  118 arithmetic_unary_operator: OP_MINUS .

    $padrão  reduzir usando a regra 118 (arithmetic_unary_operator)


State 61

   60 print_statement: PRINT . L_PAREN expression R_PAREN SEMICOLON

    L_PAREN  deslocar, e ir ao estado 147


State 62

   61 println_statement: PRINTLN . L_PAREN expression R_PAREN SEMICOLON

    L_PAREN  deslocar, e ir ao estado 148


State 63

   25 local_variable_declaration_statement: STATIC . type_specifier variable_declarators SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9

    type_specifier  ir ao estado 149
    type_name       ir ao estado 26
    primitive_type  ir ao estado 27
    qualified_name  ir ao estado 28


State 64

   58 read_statement: READ . L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | READ . L_PAREN STRING_LITERAL R_PAREN SEMICOLON

    L_PAREN  deslocar, e ir ao estado 150


State 65

   56 jump_statement: RETURN . expression SEMICOLON
   57               | RETURN . SEMICOLON
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    SEMICOLON           deslocar, e ir ao estado 151
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 153
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 66

   18 subprogram_body: SEMICOLON .

    $padrão  reduzir usando a regra 18 (subprogram_body)


State 67

   40 iteration_statement: WHILE . L_PAREN expression R_PAREN block END_WHILE

    L_PAREN  deslocar, e ir ao estado 154


State 68

  178 complex_primary_no_parenthesis: STRING_LITERAL .

    $padrão  reduzir usando a regra 178 (complex_primary_no_parenthesis)


State 69

  174 complex_primary_no_parenthesis: DECIMAL .

    $padrão  reduzir usando a regra 174 (complex_primary_no_parenthesis)


State 70

  175 complex_primary_no_parenthesis: HEX .

    $padrão  reduzir usando a regra 175 (complex_primary_no_parenthesis)


State 71

  173 complex_primary_no_parenthesis: OCTAL .

    $padrão  reduzir usando a regra 173 (complex_primary_no_parenthesis)


State 72

  176 complex_primary_no_parenthesis: FLOATING_POINT .

    $padrão  reduzir usando a regra 176 (complex_primary_no_parenthesis)


State 73

  172 complex_primary_no_parenthesis: BOOL_LITERAL .

    $padrão  reduzir usando a regra 172 (complex_primary_no_parenthesis)


State 74

  177 complex_primary_no_parenthesis: NNULL .

    $padrão  reduzir usando a regra 177 (complex_primary_no_parenthesis)


State 75

   10 procedure_declaration: PROCEDURE subprogram_declarator subprogram_body . END_PROCEDURE

    END_PROCEDURE  deslocar, e ir ao estado 155


State 76

   17 subprogram_body: block .

    $padrão  reduzir usando a regra 17 (subprogram_body)


State 77

   19 block: local_variable_declarations_and_statements .  [ELSE, ELSIF, END_FOR, END_FUNCTION, END_IF, END_PROCEDURE, END_WHILE]
   21 local_variable_declarations_and_statements: local_variable_declarations_and_statements . local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 52
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    CONTINUE            deslocar, e ir ao estado 54
    FLOAT               deslocar, e ir ao estado 6
    FOR                 deslocar, e ir ao estado 55
    IF                  deslocar, e ir ao estado 56
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    PRINT               deslocar, e ir ao estado 61
    PRINTLN             deslocar, e ir ao estado 62
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    READ                deslocar, e ir ao estado 64
    RETURN              deslocar, e ir ao estado 65
    WHILE               deslocar, e ir ao estado 67
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    $padrão  reduzir usando a regra 19 (block)

    local_variable_declarations_or_statements  ir ao estado 156
    local_variable_declaration_statement       ir ao estado 79
    statement                                  ir ao estado 80
    selection_statement                        ir ao estado 81
    iteration_statement                        ir ao estado 82
    jump_statement                             ir ao estado 83
    read_statement                             ir ao estado 84
    print_statement                            ir ao estado 85
    println_statement                          ir ao estado 86
    type_specifier                             ir ao estado 87
    type_name                                  ir ao estado 26
    primitive_type                             ir ao estado 27
    qualified_name                             ir ao estado 88
    assignment_expression                      ir ao estado 89
    unary_expression                           ir ao estado 90
    logical_unary_expression                   ir ao estado 91
    postfix_expression                         ir ao estado 92
    primary_expression                         ir ao estado 93
    arithmetic_unary_operator                  ir ao estado 94
    logical_unary_operator                     ir ao estado 95
    conditional_or_expression                  ir ao estado 96
    conditional_and_expression                 ir ao estado 97
    inclusive_or_expression                    ir ao estado 98
    exclusive_or_expression                    ir ao estado 99
    and_expression                             ir ao estado 100
    equality_expression                        ir ao estado 101
    relational_expression                      ir ao estado 102
    shift_expression                           ir ao estado 103
    additive_expression                        ir ao estado 104
    multiplicative_expression                  ir ao estado 105
    cast_expression                            ir ao estado 106
    not_just_name                              ir ao estado 107
    complex_primary                            ir ao estado 108
    complex_primary_no_parenthesis             ir ao estado 109
    array_access                               ir ao estado 110
    field_access                               ir ao estado 111
    subprogram_call                            ir ao estado 112
    subprogram_access                          ir ao estado 113


State 78

   20 local_variable_declarations_and_statements: local_variable_declarations_or_statements .

    $padrão  reduzir usando a regra 20 (local_variable_declarations_and_statements)


State 79

   22 local_variable_declarations_or_statements: local_variable_declaration_statement .

    $padrão  reduzir usando a regra 22 (local_variable_declarations_or_statements)


State 80

   23 local_variable_declarations_or_statements: statement .

    $padrão  reduzir usando a regra 23 (local_variable_declarations_or_statements)


State 81

   27 statement: selection_statement .

    $padrão  reduzir usando a regra 27 (statement)


State 82

   28 statement: iteration_statement .

    $padrão  reduzir usando a regra 28 (statement)


State 83

   29 statement: jump_statement .

    $padrão  reduzir usando a regra 29 (statement)


State 84

   30 statement: read_statement .

    $padrão  reduzir usando a regra 30 (statement)


State 85

   31 statement: print_statement .

    $padrão  reduzir usando a regra 31 (statement)


State 86

   32 statement: println_statement .

    $padrão  reduzir usando a regra 32 (statement)


State 87

   24 local_variable_declaration_statement: type_specifier . variable_declarators SEMICOLON
   95 variable_declarators: . variable_declarator
   96                     | . variable_declarators COMMA variable_declarator
   97 variable_declarator: . declarator_name
   98                    | . declarator_name ASSIGN variable_initializer
   99 declarator_name: . IDENTIFIER
  100                | . declarator_name dim_exprs

    IDENTIFIER  deslocar, e ir ao estado 39

    variable_declarators  ir ao estado 157
    variable_declarator   ir ao estado 41
    declarator_name       ir ao estado 42


State 88

   75 type_name: qualified_name .  [IDENTIFIER]
  115 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_SHIFT, SEMICOLON]
  182 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  188 subprogram_access: qualified_name .  [L_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 158

    IDENTIFIER  reduzir usando a regra 75 (type_name)
    L_PAREN     reduzir usando a regra 188 (subprogram_access)
    $padrão    reduzir usando a regra 115 (primary_expression)


State 89

   26 statement: assignment_expression . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 159


State 90

  109 assignment_expression: unary_expression . assignment_operator assignment_expression
  151 cast_expression: unary_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  158 assignment_operator: . ASSIGN
  159                    | . ASSIGN_PLUS
  160                    | . ASSIGN_MINUS
  161                    | . ASSIGN_PRODUCT
  162                    | . ASSIGN_DIV
  163                    | . ASSIGN_MOD
  164                    | . ASSIGN_BITWISE_AND
  165                    | . ASSIGN_BITWISE_OR
  166                    | . ASSIGN_BITWISE_OR_EXC
  167                    | . ASSIGN_L_SHIFT
  168                    | . ASSIGN_R_SHIFT

    ASSIGN                 deslocar, e ir ao estado 160
    ASSIGN_PLUS            deslocar, e ir ao estado 161
    ASSIGN_MINUS           deslocar, e ir ao estado 162
    ASSIGN_PRODUCT         deslocar, e ir ao estado 163
    ASSIGN_DIV             deslocar, e ir ao estado 164
    ASSIGN_MOD             deslocar, e ir ao estado 165
    ASSIGN_BITWISE_AND     deslocar, e ir ao estado 166
    ASSIGN_BITWISE_OR      deslocar, e ir ao estado 167
    ASSIGN_BITWISE_OR_EXC  deslocar, e ir ao estado 168
    ASSIGN_L_SHIFT         deslocar, e ir ao estado 169
    ASSIGN_R_SHIFT         deslocar, e ir ao estado 170

    $padrão  reduzir usando a regra 151 (cast_expression)

    assignment_operator  ir ao estado 171


State 91

  111 unary_expression: logical_unary_expression .

    $padrão  reduzir usando a regra 111 (unary_expression)


State 92

  112 logical_unary_expression: postfix_expression .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  184 field_access: postfix_expression . DOT IDENTIFIER

    DOT  deslocar, e ir ao estado 172

    $padrão  reduzir usando a regra 112 (logical_unary_expression)


State 93

  114 postfix_expression: primary_expression .

    $padrão  reduzir usando a regra 114 (postfix_expression)


State 94

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  110                 | arithmetic_unary_operator . cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 174
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 95

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  113                         | logical_unary_operator . unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 175
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 176
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 96

  108 assignment_expression: conditional_or_expression .  [COMMA, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  122 conditional_or_expression: conditional_or_expression . LOG_OR conditional_and_expression
  123                          | conditional_or_expression . LOG_SC_OR conditional_and_expression

    LOG_OR     deslocar, e ir ao estado 177
    LOG_SC_OR  deslocar, e ir ao estado 178

    $padrão  reduzir usando a regra 108 (assignment_expression)


State 97

  121 conditional_or_expression: conditional_and_expression .  [COMMA, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  125 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
  126                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 179
    LOG_SC_AND  deslocar, e ir ao estado 180

    $padrão  reduzir usando a regra 121 (conditional_or_expression)


State 98

  124 conditional_and_expression: inclusive_or_expression .  [COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  128 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 181

    $padrão  reduzir usando a regra 124 (conditional_and_expression)


State 99

  127 inclusive_or_expression: exclusive_or_expression .  [BITWISE_OR, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  130 exclusive_or_expression: exclusive_or_expression . BITWISE_OR_EXC and_expression

    BITWISE_OR_EXC  deslocar, e ir ao estado 182

    $padrão  reduzir usando a regra 127 (inclusive_or_expression)


State 100

  129 exclusive_or_expression: and_expression .  [BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  132 and_expression: and_expression . AMPERSAND equality_expression

    AMPERSAND  deslocar, e ir ao estado 183

    $padrão  reduzir usando a regra 129 (exclusive_or_expression)


State 101

  131 and_expression: equality_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  134 equality_expression: equality_expression . OP_EQ relational_expression
  135                    | equality_expression . OP_NE relational_expression

    OP_EQ  deslocar, e ir ao estado 184
    OP_NE  deslocar, e ir ao estado 185

    $padrão  reduzir usando a regra 131 (and_expression)


State 102

  133 equality_expression: relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  137 relational_expression: relational_expression . OP_LT shift_expression
  138                      | relational_expression . OP_GT shift_expression
  139                      | relational_expression . OP_LET shift_expression
  140                      | relational_expression . OP_GET shift_expression

    OP_LET  deslocar, e ir ao estado 186
    OP_LT   deslocar, e ir ao estado 187
    OP_GET  deslocar, e ir ao estado 188
    OP_GT   deslocar, e ir ao estado 189

    $padrão  reduzir usando a regra 133 (equality_expression)


State 103

  136 relational_expression: shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  142 shift_expression: shift_expression . L_SHIFT additive_expression
  143                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 190
    R_SHIFT  deslocar, e ir ao estado 191

    $padrão  reduzir usando a regra 136 (relational_expression)


State 104

  141 shift_expression: additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  145 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  146                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 192
    OP_MINUS  deslocar, e ir ao estado 193

    $padrão  reduzir usando a regra 141 (shift_expression)


State 105

  144 additive_expression: multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  148 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  149                          | multiplicative_expression . OP_DIV cast_expression
  150                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 194
    OP_DIV       deslocar, e ir ao estado 195
    OP_MOD       deslocar, e ir ao estado 196

    $padrão  reduzir usando a regra 144 (additive_expression)


State 106

  147 multiplicative_expression: cast_expression .

    $padrão  reduzir usando a regra 147 (multiplicative_expression)


State 107

  116 primary_expression: not_just_name .

    $padrão  reduzir usando a regra 116 (primary_expression)


State 108

  169 not_just_name: complex_primary .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  183 array_access: complex_primary . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 197

    $padrão  reduzir usando a regra 169 (not_just_name)


State 109

  171 complex_primary: complex_primary_no_parenthesis .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, COMMA, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  187 subprogram_access: complex_primary_no_parenthesis .  [L_PAREN]

    L_PAREN   reduzir usando a regra 187 (subprogram_access)
    $padrão  reduzir usando a regra 171 (complex_primary)


State 110

  179 complex_primary_no_parenthesis: array_access .

    $padrão  reduzir usando a regra 179 (complex_primary_no_parenthesis)


State 111

  180 complex_primary_no_parenthesis: field_access .

    $padrão  reduzir usando a regra 180 (complex_primary_no_parenthesis)


State 112

  181 complex_primary_no_parenthesis: subprogram_call .

    $padrão  reduzir usando a regra 181 (complex_primary_no_parenthesis)


State 113

  185 subprogram_call: subprogram_access . L_PAREN argument_list R_PAREN
  186                | subprogram_access . L_PAREN R_PAREN

    L_PAREN  deslocar, e ir ao estado 198


State 114

   67 variable_declaration: modifiers type_specifier variable_declarators . SEMICOLON
   96 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 115
    SEMICOLON  deslocar, e ir ao estado 199


State 115

   96 variable_declarators: variable_declarators COMMA . variable_declarator
   97 variable_declarator: . declarator_name
   98                    | . declarator_name ASSIGN variable_initializer
   99 declarator_name: . IDENTIFIER
  100                | . declarator_name dim_exprs

    IDENTIFIER  deslocar, e ir ao estado 39

    variable_declarator  ir ao estado 200
    declarator_name      ir ao estado 42


State 116

   68 variable_declaration: type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 68 (variable_declaration)


State 117

   88 qualified_name: . IDENTIFIER
   98 variable_declarator: declarator_name ASSIGN . variable_initializer
  101 variable_initializer: . expression
  102                     | . L_BRACE R_BRACE
  103                     | . L_BRACE array_initializers R_BRACE
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    L_BRACE             deslocar, e ir ao estado 201
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    variable_initializer            ir ao estado 202
    expression                      ir ao estado 203
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 118

   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name
  193 dim_expr: L_SQ_PAREN . expression R_SQ_PAREN

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 204
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 119

  100 declarator_name: declarator_name dim_exprs .  [ASSIGN, COMMA, L_SQ_PAREN, R_PAREN, SEMICOLON]
  192 dim_exprs: dim_exprs . dim_expr
  193 dim_expr: . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 118

    L_SQ_PAREN  [reduzir usando a regra 100 (declarator_name)]
    $padrão    reduzir usando a regra 100 (declarator_name)

    dim_expr  ir ao estado 205


State 120

  191 dim_exprs: dim_expr .

    $padrão  reduzir usando a regra 191 (dim_exprs)


State 121

   86 enumerator: IDENTIFIER ASSIGN . expression
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 206
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 122

   85 enumerator_list: enumerator_list COMMA . enumerator
   86 enumerator: . IDENTIFIER ASSIGN expression
   87           | . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 43

    enumerator  ir ao estado 207


State 123

   64 type_declaration: ENUM IDENTIFIER enumerator_list END_ENUM .

    $padrão  reduzir usando a regra 64 (type_declaration)


State 124

   62 type_declaration: STRUCT IDENTIFIER variable_declarations END_STRUCT .

    $padrão  reduzir usando a regra 62 (type_declaration)


State 125

   66 variable_declarations: variable_declarations variable_declaration .

    $padrão  reduzir usando a regra 66 (variable_declarations)


State 126

   82 discriminant: L_PAREN type_specifier . declarator_name R_PAREN
   99 declarator_name: . IDENTIFIER
  100                | . declarator_name dim_exprs

    IDENTIFIER  deslocar, e ir ao estado 39

    declarator_name  ir ao estado 208


State 127

   66 variable_declarations: variable_declarations . variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
   89 union_body: variable_declarations . short_case_statement
   90           | variable_declarations .  [END_UNION]
   91 short_case_statement: . CASE IDENTIFIER choices END_CASE

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 4
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9
    STATIC      deslocar, e ir ao estado 11
    CASE        deslocar, e ir ao estado 209

    $padrão  reduzir usando a regra 90 (union_body)

    variable_declaration  ir ao estado 125
    modifiers             ir ao estado 23
    modifier              ir ao estado 24
    type_specifier        ir ao estado 25
    type_name             ir ao estado 26
    primitive_type        ir ao estado 27
    qualified_name        ir ao estado 28
    short_case_statement  ir ao estado 210


State 128

   63 type_declaration: UNION IDENTIFIER discriminant union_body . END_UNION

    END_UNION  deslocar, e ir ao estado 211


State 129

    9 function_declaration: FUNCTION type_specifier subprogram_declarator subprogram_body . END_FUNCTION

    END_FUNCTION  deslocar, e ir ao estado 212


State 130

   16 parameter: CONST . type_specifier declarator_name
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9

    type_specifier  ir ao estado 213
    type_name       ir ao estado 26
    primitive_type  ir ao estado 27
    qualified_name  ir ao estado 28


State 131

   12 subprogram_declarator: IDENTIFIER L_PAREN R_PAREN .

    $padrão  reduzir usando a regra 12 (subprogram_declarator)


State 132

   11 subprogram_declarator: IDENTIFIER L_PAREN parameter_list . R_PAREN
   14 parameter_list: parameter_list . COMMA parameter

    COMMA    deslocar, e ir ao estado 214
    R_PAREN  deslocar, e ir ao estado 215


State 133

   13 parameter_list: parameter .

    $padrão  reduzir usando a regra 13 (parameter_list)


State 134

   15 parameter: type_specifier . declarator_name
   99 declarator_name: . IDENTIFIER
  100                | . declarator_name dim_exprs

    IDENTIFIER  deslocar, e ir ao estado 39

    declarator_name  ir ao estado 216


State 135

   52 jump_statement: BREAK IDENTIFIER . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 217


State 136

   53 jump_statement: BREAK SEMICOLON .

    $padrão  reduzir usando a regra 53 (jump_statement)


State 137

   54 jump_statement: CONTINUE IDENTIFIER . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 218


State 138

   55 jump_statement: CONTINUE SEMICOLON .

    $padrão  reduzir usando a regra 55 (jump_statement)


State 139

   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   41 iteration_statement: FOR L_PAREN . for_init for_expr for_incr R_PAREN block END_FOR
   42                    | FOR L_PAREN . for_init for_expr R_PAREN block END_FOR
   43 for_init: . expression_statements SEMICOLON
   44         | . local_variable_declaration_statement
   45         | . SEMICOLON
   49 expression_statements: . expression_statement
   50                      | . expression_statements COMMA expression_statement
   51 expression_statement: . expression
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    FLOAT               deslocar, e ir ao estado 6
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    SEMICOLON           deslocar, e ir ao estado 219
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    local_variable_declaration_statement  ir ao estado 220
    for_init                              ir ao estado 221
    expression_statements                 ir ao estado 222
    expression_statement                  ir ao estado 223
    type_specifier                        ir ao estado 87
    type_name                             ir ao estado 26
    primitive_type                        ir ao estado 27
    qualified_name                        ir ao estado 88
    expression                            ir ao estado 224
    assignment_expression                 ir ao estado 144
    unary_expression                      ir ao estado 90
    logical_unary_expression              ir ao estado 91
    postfix_expression                    ir ao estado 92
    primary_expression                    ir ao estado 93
    arithmetic_unary_operator             ir ao estado 94
    logical_unary_operator                ir ao estado 95
    conditional_or_expression             ir ao estado 96
    conditional_and_expression            ir ao estado 97
    inclusive_or_expression               ir ao estado 98
    exclusive_or_expression               ir ao estado 99
    and_expression                        ir ao estado 100
    equality_expression                   ir ao estado 101
    relational_expression                 ir ao estado 102
    shift_expression                      ir ao estado 103
    additive_expression                   ir ao estado 104
    multiplicative_expression             ir ao estado 105
    cast_expression                       ir ao estado 106
    not_just_name                         ir ao estado 107
    complex_primary                       ir ao estado 108
    complex_primary_no_parenthesis        ir ao estado 109
    array_access                          ir ao estado 110
    field_access                          ir ao estado 111
    subprogram_call                       ir ao estado 112
    subprogram_access                     ir ao estado 113


State 140

   33 selection_statement: IF L_PAREN . expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | IF L_PAREN . expression R_PAREN block ELSE block END_IF
   35                    | IF L_PAREN . expression R_PAREN block END_IF
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 225
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 141

  155 primitive_type_expression: primitive_type .  [R_PAREN]
  156                          | primitive_type . dims
  194 dims: . L_SQ_PAREN R_SQ_PAREN
  195     | . dims L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 226

    $padrão  reduzir usando a regra 155 (primitive_type_expression)

    dims  ir ao estado 227


State 142

  115 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SHIFT]
  157 user_type_expression: qualified_name . dims
  182 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  188 subprogram_access: qualified_name .  [L_PAREN]
  194 dims: . L_SQ_PAREN R_SQ_PAREN
  195     | . dims L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 228

    L_PAREN   reduzir usando a regra 188 (subprogram_access)
    $padrão  reduzir usando a regra 115 (primary_expression)

    dims  ir ao estado 229


State 143

  154 cast_expression: L_PAREN expression . R_PAREN logical_unary_expression
  170 complex_primary: L_PAREN expression . R_PAREN

    R_PAREN  deslocar, e ir ao estado 230


State 144

  107 expression: assignment_expression .

    $padrão  reduzir usando a regra 107 (expression)


State 145

  152 cast_expression: L_PAREN primitive_type_expression . R_PAREN cast_expression

    R_PAREN  deslocar, e ir ao estado 231


State 146

  153 cast_expression: L_PAREN user_type_expression . R_PAREN cast_expression

    R_PAREN  deslocar, e ir ao estado 232


State 147

   60 print_statement: PRINT L_PAREN . expression R_PAREN SEMICOLON
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 233
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 148

   61 println_statement: PRINTLN L_PAREN . expression R_PAREN SEMICOLON
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 234
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 149

   25 local_variable_declaration_statement: STATIC type_specifier . variable_declarators SEMICOLON
   95 variable_declarators: . variable_declarator
   96                     | . variable_declarators COMMA variable_declarator
   97 variable_declarator: . declarator_name
   98                    | . declarator_name ASSIGN variable_initializer
   99 declarator_name: . IDENTIFIER
  100                | . declarator_name dim_exprs

    IDENTIFIER  deslocar, e ir ao estado 39

    variable_declarators  ir ao estado 235
    variable_declarator   ir ao estado 41
    declarator_name       ir ao estado 42


State 150

   58 read_statement: READ L_PAREN . STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | READ L_PAREN . STRING_LITERAL R_PAREN SEMICOLON

    STRING_LITERAL  deslocar, e ir ao estado 236


State 151

   57 jump_statement: RETURN SEMICOLON .

    $padrão  reduzir usando a regra 57 (jump_statement)


State 152

  115 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  182 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  188 subprogram_access: qualified_name .  [L_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 158

    L_PAREN   reduzir usando a regra 188 (subprogram_access)
    $padrão  reduzir usando a regra 115 (primary_expression)


State 153

   56 jump_statement: RETURN expression . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 237


State 154

   40 iteration_statement: WHILE L_PAREN . expression R_PAREN block END_WHILE
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 238
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 155

   10 procedure_declaration: PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE .

    $padrão  reduzir usando a regra 10 (procedure_declaration)


State 156

   21 local_variable_declarations_and_statements: local_variable_declarations_and_statements local_variable_declarations_or_statements .

    $padrão  reduzir usando a regra 21 (local_variable_declarations_and_statements)


State 157

   24 local_variable_declaration_statement: type_specifier variable_declarators . SEMICOLON
   96 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 115
    SEMICOLON  deslocar, e ir ao estado 239


State 158

   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  182             | qualified_name L_SQ_PAREN . expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 240
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 159

   26 statement: assignment_expression SEMICOLON .

    $padrão  reduzir usando a regra 26 (statement)


State 160

  158 assignment_operator: ASSIGN .

    $padrão  reduzir usando a regra 158 (assignment_operator)


State 161

  159 assignment_operator: ASSIGN_PLUS .

    $padrão  reduzir usando a regra 159 (assignment_operator)


State 162

  160 assignment_operator: ASSIGN_MINUS .

    $padrão  reduzir usando a regra 160 (assignment_operator)


State 163

  161 assignment_operator: ASSIGN_PRODUCT .

    $padrão  reduzir usando a regra 161 (assignment_operator)


State 164

  162 assignment_operator: ASSIGN_DIV .

    $padrão  reduzir usando a regra 162 (assignment_operator)


State 165

  163 assignment_operator: ASSIGN_MOD .

    $padrão  reduzir usando a regra 163 (assignment_operator)


State 166

  164 assignment_operator: ASSIGN_BITWISE_AND .

    $padrão  reduzir usando a regra 164 (assignment_operator)


State 167

  165 assignment_operator: ASSIGN_BITWISE_OR .

    $padrão  reduzir usando a regra 165 (assignment_operator)


State 168

  166 assignment_operator: ASSIGN_BITWISE_OR_EXC .

    $padrão  reduzir usando a regra 166 (assignment_operator)


State 169

  167 assignment_operator: ASSIGN_L_SHIFT .

    $padrão  reduzir usando a regra 167 (assignment_operator)


State 170

  168 assignment_operator: ASSIGN_R_SHIFT .

    $padrão  reduzir usando a regra 168 (assignment_operator)


State 171

   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  109                      | unary_expression assignment_operator . assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    assignment_expression           ir ao estado 241
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 172

  184 field_access: postfix_expression DOT . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 242


State 173

  151 cast_expression: unary_expression .

    $padrão  reduzir usando a regra 151 (cast_expression)


State 174

  110 unary_expression: arithmetic_unary_operator cast_expression .

    $padrão  reduzir usando a regra 110 (unary_expression)


State 175

   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  170                | L_PAREN . expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 243
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 176

  113 logical_unary_expression: logical_unary_operator unary_expression .

    $padrão  reduzir usando a regra 113 (logical_unary_expression)


State 177

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  122 conditional_or_expression: conditional_or_expression LOG_OR . conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_and_expression      ir ao estado 244
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 178

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  123 conditional_or_expression: conditional_or_expression LOG_SC_OR . conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_and_expression      ir ao estado 245
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 179

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  125 conditional_and_expression: conditional_and_expression LOG_AND . inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    inclusive_or_expression         ir ao estado 246
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 180

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  126 conditional_and_expression: conditional_and_expression LOG_SC_AND . inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    inclusive_or_expression         ir ao estado 247
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 181

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  128 inclusive_or_expression: inclusive_or_expression BITWISE_OR . exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    exclusive_or_expression         ir ao estado 248
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 182

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  130 exclusive_or_expression: exclusive_or_expression BITWISE_OR_EXC . and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    and_expression                  ir ao estado 249
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 183

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  132 and_expression: and_expression AMPERSAND . equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    equality_expression             ir ao estado 250
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 184

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  134 equality_expression: equality_expression OP_EQ . relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    relational_expression           ir ao estado 251
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 185

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  135 equality_expression: equality_expression OP_NE . relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    relational_expression           ir ao estado 252
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 186

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  139 relational_expression: relational_expression OP_LET . shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    shift_expression                ir ao estado 253
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 187

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  137 relational_expression: relational_expression OP_LT . shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    shift_expression                ir ao estado 254
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 188

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  140 relational_expression: relational_expression OP_GET . shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    shift_expression                ir ao estado 255
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 189

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  138 relational_expression: relational_expression OP_GT . shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    shift_expression                ir ao estado 256
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 190

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  142 shift_expression: shift_expression L_SHIFT . additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    additive_expression             ir ao estado 257
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 191

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  143 shift_expression: shift_expression R_SHIFT . additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    additive_expression             ir ao estado 258
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 192

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  145 additive_expression: additive_expression OP_PLUS . multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    multiplicative_expression       ir ao estado 259
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 193

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  146 additive_expression: additive_expression OP_MINUS . multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    multiplicative_expression       ir ao estado 260
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 194

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  148 multiplicative_expression: multiplicative_expression OP_ASTERISK . cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 261
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 195

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  149 multiplicative_expression: multiplicative_expression OP_DIV . cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 262
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 196

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  150 multiplicative_expression: multiplicative_expression OP_MOD . cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 263
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 197

   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  183             | complex_primary L_SQ_PAREN . expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 264
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 198

   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  185                | subprogram_access L_PAREN . argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  186                | subprogram_access L_PAREN . R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name
  189 argument_list: . expression
  190              | . argument_list COMMA expression

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    R_PAREN             deslocar, e ir ao estado 265
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 266
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113
    argument_list                   ir ao estado 267


State 199

   67 variable_declaration: modifiers type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 67 (variable_declaration)


State 200

   96 variable_declarators: variable_declarators COMMA variable_declarator .

    $padrão  reduzir usando a regra 96 (variable_declarators)


State 201

   88 qualified_name: . IDENTIFIER
  101 variable_initializer: . expression
  102                     | . L_BRACE R_BRACE
  102                     | L_BRACE . R_BRACE
  103                     | . L_BRACE array_initializers R_BRACE
  103                     | L_BRACE . array_initializers R_BRACE
  104 array_initializers: . variable_initializer
  105                   | . array_initializers COMMA variable_initializer
  106                   | . array_initializers COMMA
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    L_BRACE             deslocar, e ir ao estado 201
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    R_BRACE             deslocar, e ir ao estado 268
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    variable_initializer            ir ao estado 269
    array_initializers              ir ao estado 270
    expression                      ir ao estado 203
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 202

   98 variable_declarator: declarator_name ASSIGN variable_initializer .

    $padrão  reduzir usando a regra 98 (variable_declarator)


State 203

  101 variable_initializer: expression .

    $padrão  reduzir usando a regra 101 (variable_initializer)


State 204

  193 dim_expr: L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 271


State 205

  192 dim_exprs: dim_exprs dim_expr .

    $padrão  reduzir usando a regra 192 (dim_exprs)


State 206

   86 enumerator: IDENTIFIER ASSIGN expression .

    $padrão  reduzir usando a regra 86 (enumerator)


State 207

   85 enumerator_list: enumerator_list COMMA enumerator .

    $padrão  reduzir usando a regra 85 (enumerator_list)


State 208

   82 discriminant: L_PAREN type_specifier declarator_name . R_PAREN
  100 declarator_name: declarator_name . dim_exprs
  191 dim_exprs: . dim_expr
  192          | . dim_exprs dim_expr
  193 dim_expr: . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 118
    R_PAREN     deslocar, e ir ao estado 272

    dim_exprs  ir ao estado 119
    dim_expr   ir ao estado 120


State 209

   91 short_case_statement: CASE . IDENTIFIER choices END_CASE

    IDENTIFIER  deslocar, e ir ao estado 273


State 210

   89 union_body: variable_declarations short_case_statement .

    $padrão  reduzir usando a regra 89 (union_body)


State 211

   63 type_declaration: UNION IDENTIFIER discriminant union_body END_UNION .

    $padrão  reduzir usando a regra 63 (type_declaration)


State 212

    9 function_declaration: FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION .

    $padrão  reduzir usando a regra 9 (function_declaration)


State 213

   16 parameter: CONST type_specifier . declarator_name
   99 declarator_name: . IDENTIFIER
  100                | . declarator_name dim_exprs

    IDENTIFIER  deslocar, e ir ao estado 39

    declarator_name  ir ao estado 274


State 214

   14 parameter_list: parameter_list COMMA . parameter
   15 parameter: . type_specifier declarator_name
   16          | . CONST type_specifier declarator_name
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 130
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9

    parameter       ir ao estado 275
    type_specifier  ir ao estado 134
    type_name       ir ao estado 26
    primitive_type  ir ao estado 27
    qualified_name  ir ao estado 28


State 215

   11 subprogram_declarator: IDENTIFIER L_PAREN parameter_list R_PAREN .

    $padrão  reduzir usando a regra 11 (subprogram_declarator)


State 216

   15 parameter: type_specifier declarator_name .  [COMMA, R_PAREN]
  100 declarator_name: declarator_name . dim_exprs
  191 dim_exprs: . dim_expr
  192          | . dim_exprs dim_expr
  193 dim_expr: . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 118

    $padrão  reduzir usando a regra 15 (parameter)

    dim_exprs  ir ao estado 119
    dim_expr   ir ao estado 120


State 217

   52 jump_statement: BREAK IDENTIFIER SEMICOLON .

    $padrão  reduzir usando a regra 52 (jump_statement)


State 218

   54 jump_statement: CONTINUE IDENTIFIER SEMICOLON .

    $padrão  reduzir usando a regra 54 (jump_statement)


State 219

   45 for_init: SEMICOLON .

    $padrão  reduzir usando a regra 45 (for_init)


State 220

   44 for_init: local_variable_declaration_statement .

    $padrão  reduzir usando a regra 44 (for_init)


State 221

   41 iteration_statement: FOR L_PAREN for_init . for_expr for_incr R_PAREN block END_FOR
   42                    | FOR L_PAREN for_init . for_expr R_PAREN block END_FOR
   46 for_expr: . expression SEMICOLON
   47         | . SEMICOLON
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    SEMICOLON           deslocar, e ir ao estado 276
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    for_expr                        ir ao estado 277
    qualified_name                  ir ao estado 152
    expression                      ir ao estado 278
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 222

   43 for_init: expression_statements . SEMICOLON
   50 expression_statements: expression_statements . COMMA expression_statement

    COMMA      deslocar, e ir ao estado 279
    SEMICOLON  deslocar, e ir ao estado 280


State 223

   49 expression_statements: expression_statement .

    $padrão  reduzir usando a regra 49 (expression_statements)


State 224

   51 expression_statement: expression .

    $padrão  reduzir usando a regra 51 (expression_statement)


State 225

   33 selection_statement: IF L_PAREN expression . R_PAREN block ELSIF elsif_staments END_IF
   34                    | IF L_PAREN expression . R_PAREN block ELSE block END_IF
   35                    | IF L_PAREN expression . R_PAREN block END_IF

    R_PAREN  deslocar, e ir ao estado 281


State 226

  194 dims: L_SQ_PAREN . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 282


State 227

  156 primitive_type_expression: primitive_type dims .  [R_PAREN]
  195 dims: dims . L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 283

    $padrão  reduzir usando a regra 156 (primitive_type_expression)


State 228

   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  182             | qualified_name L_SQ_PAREN . expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name
  194 dims: L_SQ_PAREN . R_SQ_PAREN

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    R_SQ_PAREN          deslocar, e ir ao estado 282
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 240
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 229

  157 user_type_expression: qualified_name dims .  [R_PAREN]
  195 dims: dims . L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 283

    $padrão  reduzir usando a regra 157 (user_type_expression)


State 230

   88 qualified_name: . IDENTIFIER
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  154 cast_expression: L_PAREN expression R_PAREN . logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  170                | L_PAREN expression R_PAREN .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, COMMA, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 175
    LOG_NOT             deslocar, e ir ao estado 58
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    $padrão  reduzir usando a regra 170 (complex_primary)

    qualified_name                  ir ao estado 152
    logical_unary_expression        ir ao estado 284
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    logical_unary_operator          ir ao estado 95
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 231

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  152                | L_PAREN primitive_type_expression R_PAREN . cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 285
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 232

   88 qualified_name: . IDENTIFIER
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  153                | L_PAREN user_type_expression R_PAREN . cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 286
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 233

   60 print_statement: PRINT L_PAREN expression . R_PAREN SEMICOLON

    R_PAREN  deslocar, e ir ao estado 287


State 234

   61 println_statement: PRINTLN L_PAREN expression . R_PAREN SEMICOLON

    R_PAREN  deslocar, e ir ao estado 288


State 235

   25 local_variable_declaration_statement: STATIC type_specifier variable_declarators . SEMICOLON
   96 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 115
    SEMICOLON  deslocar, e ir ao estado 289


State 236

   58 read_statement: READ L_PAREN STRING_LITERAL . COMMA argument_list R_PAREN SEMICOLON
   59               | READ L_PAREN STRING_LITERAL . R_PAREN SEMICOLON

    COMMA    deslocar, e ir ao estado 290
    R_PAREN  deslocar, e ir ao estado 291


State 237

   56 jump_statement: RETURN expression SEMICOLON .

    $padrão  reduzir usando a regra 56 (jump_statement)


State 238

   40 iteration_statement: WHILE L_PAREN expression . R_PAREN block END_WHILE

    R_PAREN  deslocar, e ir ao estado 292


State 239

   24 local_variable_declaration_statement: type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 24 (local_variable_declaration_statement)


State 240

  182 array_access: qualified_name L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 293


State 241

  109 assignment_expression: unary_expression assignment_operator assignment_expression .

    $padrão  reduzir usando a regra 109 (assignment_expression)


State 242

  184 field_access: postfix_expression DOT IDENTIFIER .

    $padrão  reduzir usando a regra 184 (field_access)


State 243

  170 complex_primary: L_PAREN expression . R_PAREN

    R_PAREN  deslocar, e ir ao estado 294


State 244

  122 conditional_or_expression: conditional_or_expression LOG_OR conditional_and_expression .  [COMMA, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  125 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
  126                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 179
    LOG_SC_AND  deslocar, e ir ao estado 180

    $padrão  reduzir usando a regra 122 (conditional_or_expression)


State 245

  123 conditional_or_expression: conditional_or_expression LOG_SC_OR conditional_and_expression .  [COMMA, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  125 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
  126                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 179
    LOG_SC_AND  deslocar, e ir ao estado 180

    $padrão  reduzir usando a regra 123 (conditional_or_expression)


State 246

  125 conditional_and_expression: conditional_and_expression LOG_AND inclusive_or_expression .  [COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  128 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 181

    $padrão  reduzir usando a regra 125 (conditional_and_expression)


State 247

  126 conditional_and_expression: conditional_and_expression LOG_SC_AND inclusive_or_expression .  [COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  128 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 181

    $padrão  reduzir usando a regra 126 (conditional_and_expression)


State 248

  128 inclusive_or_expression: inclusive_or_expression BITWISE_OR exclusive_or_expression .  [BITWISE_OR, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  130 exclusive_or_expression: exclusive_or_expression . BITWISE_OR_EXC and_expression

    BITWISE_OR_EXC  deslocar, e ir ao estado 182

    $padrão  reduzir usando a regra 128 (inclusive_or_expression)


State 249

  130 exclusive_or_expression: exclusive_or_expression BITWISE_OR_EXC and_expression .  [BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  132 and_expression: and_expression . AMPERSAND equality_expression

    AMPERSAND  deslocar, e ir ao estado 183

    $padrão  reduzir usando a regra 130 (exclusive_or_expression)


State 250

  132 and_expression: and_expression AMPERSAND equality_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  134 equality_expression: equality_expression . OP_EQ relational_expression
  135                    | equality_expression . OP_NE relational_expression

    OP_EQ  deslocar, e ir ao estado 184
    OP_NE  deslocar, e ir ao estado 185

    $padrão  reduzir usando a regra 132 (and_expression)


State 251

  134 equality_expression: equality_expression OP_EQ relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  137 relational_expression: relational_expression . OP_LT shift_expression
  138                      | relational_expression . OP_GT shift_expression
  139                      | relational_expression . OP_LET shift_expression
  140                      | relational_expression . OP_GET shift_expression

    OP_LET  deslocar, e ir ao estado 186
    OP_LT   deslocar, e ir ao estado 187
    OP_GET  deslocar, e ir ao estado 188
    OP_GT   deslocar, e ir ao estado 189

    $padrão  reduzir usando a regra 134 (equality_expression)


State 252

  135 equality_expression: equality_expression OP_NE relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  137 relational_expression: relational_expression . OP_LT shift_expression
  138                      | relational_expression . OP_GT shift_expression
  139                      | relational_expression . OP_LET shift_expression
  140                      | relational_expression . OP_GET shift_expression

    OP_LET  deslocar, e ir ao estado 186
    OP_LT   deslocar, e ir ao estado 187
    OP_GET  deslocar, e ir ao estado 188
    OP_GT   deslocar, e ir ao estado 189

    $padrão  reduzir usando a regra 135 (equality_expression)


State 253

  139 relational_expression: relational_expression OP_LET shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  142 shift_expression: shift_expression . L_SHIFT additive_expression
  143                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 190
    R_SHIFT  deslocar, e ir ao estado 191

    $padrão  reduzir usando a regra 139 (relational_expression)


State 254

  137 relational_expression: relational_expression OP_LT shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  142 shift_expression: shift_expression . L_SHIFT additive_expression
  143                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 190
    R_SHIFT  deslocar, e ir ao estado 191

    $padrão  reduzir usando a regra 137 (relational_expression)


State 255

  140 relational_expression: relational_expression OP_GET shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  142 shift_expression: shift_expression . L_SHIFT additive_expression
  143                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 190
    R_SHIFT  deslocar, e ir ao estado 191

    $padrão  reduzir usando a regra 140 (relational_expression)


State 256

  138 relational_expression: relational_expression OP_GT shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, END_ENUM]
  142 shift_expression: shift_expression . L_SHIFT additive_expression
  143                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 190
    R_SHIFT  deslocar, e ir ao estado 191

    $padrão  reduzir usando a regra 138 (relational_expression)


State 257

  142 shift_expression: shift_expression L_SHIFT additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  145 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  146                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 192
    OP_MINUS  deslocar, e ir ao estado 193

    $padrão  reduzir usando a regra 142 (shift_expression)


State 258

  143 shift_expression: shift_expression R_SHIFT additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  145 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  146                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 192
    OP_MINUS  deslocar, e ir ao estado 193

    $padrão  reduzir usando a regra 143 (shift_expression)


State 259

  145 additive_expression: additive_expression OP_PLUS multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  148 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  149                          | multiplicative_expression . OP_DIV cast_expression
  150                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 194
    OP_DIV       deslocar, e ir ao estado 195
    OP_MOD       deslocar, e ir ao estado 196

    $padrão  reduzir usando a regra 145 (additive_expression)


State 260

  146 additive_expression: additive_expression OP_MINUS multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, END_ENUM]
  148 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  149                          | multiplicative_expression . OP_DIV cast_expression
  150                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 194
    OP_DIV       deslocar, e ir ao estado 195
    OP_MOD       deslocar, e ir ao estado 196

    $padrão  reduzir usando a regra 146 (additive_expression)


State 261

  148 multiplicative_expression: multiplicative_expression OP_ASTERISK cast_expression .

    $padrão  reduzir usando a regra 148 (multiplicative_expression)


State 262

  149 multiplicative_expression: multiplicative_expression OP_DIV cast_expression .

    $padrão  reduzir usando a regra 149 (multiplicative_expression)


State 263

  150 multiplicative_expression: multiplicative_expression OP_MOD cast_expression .

    $padrão  reduzir usando a regra 150 (multiplicative_expression)


State 264

  183 array_access: complex_primary L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 295


State 265

  186 subprogram_call: subprogram_access L_PAREN R_PAREN .

    $padrão  reduzir usando a regra 186 (subprogram_call)


State 266

  189 argument_list: expression .

    $padrão  reduzir usando a regra 189 (argument_list)


State 267

  185 subprogram_call: subprogram_access L_PAREN argument_list . R_PAREN
  190 argument_list: argument_list . COMMA expression

    COMMA    deslocar, e ir ao estado 296
    R_PAREN  deslocar, e ir ao estado 297


State 268

  102 variable_initializer: L_BRACE R_BRACE .

    $padrão  reduzir usando a regra 102 (variable_initializer)


State 269

  104 array_initializers: variable_initializer .

    $padrão  reduzir usando a regra 104 (array_initializers)


State 270

  103 variable_initializer: L_BRACE array_initializers . R_BRACE
  105 array_initializers: array_initializers . COMMA variable_initializer
  106                   | array_initializers . COMMA

    COMMA    deslocar, e ir ao estado 298
    R_BRACE  deslocar, e ir ao estado 299


State 271

  193 dim_expr: L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 193 (dim_expr)


State 272

   82 discriminant: L_PAREN type_specifier declarator_name R_PAREN .

    $padrão  reduzir usando a regra 82 (discriminant)


State 273

   91 short_case_statement: CASE IDENTIFIER . choices END_CASE
   92 choices: . choice
   93        | . choices choice
   94 choice: . WHEN IDENTIFIER THEN variable_declarations

    WHEN  deslocar, e ir ao estado 300

    choices  ir ao estado 301
    choice   ir ao estado 302


State 274

   16 parameter: CONST type_specifier declarator_name .  [COMMA, R_PAREN]
  100 declarator_name: declarator_name . dim_exprs
  191 dim_exprs: . dim_expr
  192          | . dim_exprs dim_expr
  193 dim_expr: . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 118

    $padrão  reduzir usando a regra 16 (parameter)

    dim_exprs  ir ao estado 119
    dim_expr   ir ao estado 120


State 275

   14 parameter_list: parameter_list COMMA parameter .

    $padrão  reduzir usando a regra 14 (parameter_list)


State 276

   47 for_expr: SEMICOLON .

    $padrão  reduzir usando a regra 47 (for_expr)


State 277

   41 iteration_statement: FOR L_PAREN for_init for_expr . for_incr R_PAREN block END_FOR
   42                    | FOR L_PAREN for_init for_expr . R_PAREN block END_FOR
   48 for_incr: . expression_statements
   49 expression_statements: . expression_statement
   50                      | . expression_statements COMMA expression_statement
   51 expression_statement: . expression
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    R_PAREN             deslocar, e ir ao estado 303
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    for_incr                        ir ao estado 304
    expression_statements           ir ao estado 305
    expression_statement            ir ao estado 223
    qualified_name                  ir ao estado 152
    expression                      ir ao estado 224
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 278

   46 for_expr: expression . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 306


State 279

   50 expression_statements: expression_statements COMMA . expression_statement
   51 expression_statement: . expression
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    expression_statement            ir ao estado 307
    qualified_name                  ir ao estado 152
    expression                      ir ao estado 224
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 280

   43 for_init: expression_statements SEMICOLON .

    $padrão  reduzir usando a regra 43 (for_init)


State 281

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   33                    | IF L_PAREN expression R_PAREN . block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   34                    | IF L_PAREN expression R_PAREN . block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   35                    | IF L_PAREN expression R_PAREN . block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 52
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    CONTINUE            deslocar, e ir ao estado 54
    FLOAT               deslocar, e ir ao estado 6
    FOR                 deslocar, e ir ao estado 55
    IF                  deslocar, e ir ao estado 56
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    PRINT               deslocar, e ir ao estado 61
    PRINTLN             deslocar, e ir ao estado 62
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    READ                deslocar, e ir ao estado 64
    RETURN              deslocar, e ir ao estado 65
    WHILE               deslocar, e ir ao estado 67
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    block                                       ir ao estado 308
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 26
    primitive_type                              ir ao estado 27
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 282

  194 dims: L_SQ_PAREN R_SQ_PAREN .

    $padrão  reduzir usando a regra 194 (dims)


State 283

  195 dims: dims L_SQ_PAREN . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 309


State 284

  154 cast_expression: L_PAREN expression R_PAREN logical_unary_expression .

    $padrão  reduzir usando a regra 154 (cast_expression)


State 285

  152 cast_expression: L_PAREN primitive_type_expression R_PAREN cast_expression .

    $padrão  reduzir usando a regra 152 (cast_expression)


State 286

  153 cast_expression: L_PAREN user_type_expression R_PAREN cast_expression .

    $padrão  reduzir usando a regra 153 (cast_expression)


State 287

   60 print_statement: PRINT L_PAREN expression R_PAREN . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 310


State 288

   61 println_statement: PRINTLN L_PAREN expression R_PAREN . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 311


State 289

   25 local_variable_declaration_statement: STATIC type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 25 (local_variable_declaration_statement)


State 290

   58 read_statement: READ L_PAREN STRING_LITERAL COMMA . argument_list R_PAREN SEMICOLON
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name
  189 argument_list: . expression
  190              | . argument_list COMMA expression

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 266
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113
    argument_list                   ir ao estado 312


State 291

   59 read_statement: READ L_PAREN STRING_LITERAL R_PAREN . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 313


State 292

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   40                    | WHILE L_PAREN expression R_PAREN . block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 52
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    CONTINUE            deslocar, e ir ao estado 54
    FLOAT               deslocar, e ir ao estado 6
    FOR                 deslocar, e ir ao estado 55
    IF                  deslocar, e ir ao estado 56
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    PRINT               deslocar, e ir ao estado 61
    PRINTLN             deslocar, e ir ao estado 62
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    READ                deslocar, e ir ao estado 64
    RETURN              deslocar, e ir ao estado 65
    WHILE               deslocar, e ir ao estado 67
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    block                                       ir ao estado 314
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 26
    primitive_type                              ir ao estado 27
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 293

  182 array_access: qualified_name L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 182 (array_access)


State 294

  170 complex_primary: L_PAREN expression R_PAREN .

    $padrão  reduzir usando a regra 170 (complex_primary)


State 295

  183 array_access: complex_primary L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 183 (array_access)


State 296

   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name
  190 argument_list: argument_list COMMA . expression

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 315
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 297

  185 subprogram_call: subprogram_access L_PAREN argument_list R_PAREN .

    $padrão  reduzir usando a regra 185 (subprogram_call)


State 298

   88 qualified_name: . IDENTIFIER
  101 variable_initializer: . expression
  102                     | . L_BRACE R_BRACE
  103                     | . L_BRACE array_initializers R_BRACE
  105 array_initializers: array_initializers COMMA . variable_initializer
  106                   | array_initializers COMMA .  [COMMA, R_BRACE]
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    L_BRACE             deslocar, e ir ao estado 201
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    $padrão  reduzir usando a regra 106 (array_initializers)

    qualified_name                  ir ao estado 152
    variable_initializer            ir ao estado 316
    expression                      ir ao estado 203
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 299

  103 variable_initializer: L_BRACE array_initializers R_BRACE .

    $padrão  reduzir usando a regra 103 (variable_initializer)


State 300

   94 choice: WHEN . IDENTIFIER THEN variable_declarations

    IDENTIFIER  deslocar, e ir ao estado 317


State 301

   91 short_case_statement: CASE IDENTIFIER choices . END_CASE
   93 choices: choices . choice
   94 choice: . WHEN IDENTIFIER THEN variable_declarations

    END_CASE  deslocar, e ir ao estado 318
    WHEN      deslocar, e ir ao estado 300

    choice  ir ao estado 319


State 302

   92 choices: choice .

    $padrão  reduzir usando a regra 92 (choices)


State 303

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   42                    | FOR L_PAREN for_init for_expr R_PAREN . block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 52
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    CONTINUE            deslocar, e ir ao estado 54
    FLOAT               deslocar, e ir ao estado 6
    FOR                 deslocar, e ir ao estado 55
    IF                  deslocar, e ir ao estado 56
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    PRINT               deslocar, e ir ao estado 61
    PRINTLN             deslocar, e ir ao estado 62
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    READ                deslocar, e ir ao estado 64
    RETURN              deslocar, e ir ao estado 65
    WHILE               deslocar, e ir ao estado 67
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    block                                       ir ao estado 320
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 26
    primitive_type                              ir ao estado 27
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 304

   41 iteration_statement: FOR L_PAREN for_init for_expr for_incr . R_PAREN block END_FOR

    R_PAREN  deslocar, e ir ao estado 321


State 305

   48 for_incr: expression_statements .  [R_PAREN]
   50 expression_statements: expression_statements . COMMA expression_statement

    COMMA  deslocar, e ir ao estado 279

    $padrão  reduzir usando a regra 48 (for_incr)


State 306

   46 for_expr: expression SEMICOLON .

    $padrão  reduzir usando a regra 46 (for_expr)


State 307

   50 expression_statements: expression_statements COMMA expression_statement .

    $padrão  reduzir usando a regra 50 (expression_statements)


State 308

   33 selection_statement: IF L_PAREN expression R_PAREN block . ELSIF elsif_staments END_IF
   34                    | IF L_PAREN expression R_PAREN block . ELSE block END_IF
   35                    | IF L_PAREN expression R_PAREN block . END_IF

    ELSE    deslocar, e ir ao estado 322
    ELSIF   deslocar, e ir ao estado 323
    END_IF  deslocar, e ir ao estado 324


State 309

  195 dims: dims L_SQ_PAREN R_SQ_PAREN .

    $padrão  reduzir usando a regra 195 (dims)


State 310

   60 print_statement: PRINT L_PAREN expression R_PAREN SEMICOLON .

    $padrão  reduzir usando a regra 60 (print_statement)


State 311

   61 println_statement: PRINTLN L_PAREN expression R_PAREN SEMICOLON .

    $padrão  reduzir usando a regra 61 (println_statement)


State 312

   58 read_statement: READ L_PAREN STRING_LITERAL COMMA argument_list . R_PAREN SEMICOLON
  190 argument_list: argument_list . COMMA expression

    COMMA    deslocar, e ir ao estado 296
    R_PAREN  deslocar, e ir ao estado 325


State 313

   59 read_statement: READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON .

    $padrão  reduzir usando a regra 59 (read_statement)


State 314

   40 iteration_statement: WHILE L_PAREN expression R_PAREN block . END_WHILE

    END_WHILE  deslocar, e ir ao estado 326


State 315

  190 argument_list: argument_list COMMA expression .

    $padrão  reduzir usando a regra 190 (argument_list)


State 316

  105 array_initializers: array_initializers COMMA variable_initializer .

    $padrão  reduzir usando a regra 105 (array_initializers)


State 317

   94 choice: WHEN IDENTIFIER . THEN variable_declarations

    THEN  deslocar, e ir ao estado 327


State 318

   91 short_case_statement: CASE IDENTIFIER choices END_CASE .

    $padrão  reduzir usando a regra 91 (short_case_statement)


State 319

   93 choices: choices choice .

    $padrão  reduzir usando a regra 93 (choices)


State 320

   42 iteration_statement: FOR L_PAREN for_init for_expr R_PAREN block . END_FOR

    END_FOR  deslocar, e ir ao estado 328


State 321

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   41                    | FOR L_PAREN for_init for_expr for_incr R_PAREN . block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 52
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    CONTINUE            deslocar, e ir ao estado 54
    FLOAT               deslocar, e ir ao estado 6
    FOR                 deslocar, e ir ao estado 55
    IF                  deslocar, e ir ao estado 56
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    PRINT               deslocar, e ir ao estado 61
    PRINTLN             deslocar, e ir ao estado 62
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    READ                deslocar, e ir ao estado 64
    RETURN              deslocar, e ir ao estado 65
    WHILE               deslocar, e ir ao estado 67
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    block                                       ir ao estado 329
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 26
    primitive_type                              ir ao estado 27
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 322

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   34                    | IF L_PAREN expression R_PAREN block ELSE . block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 52
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    CONTINUE            deslocar, e ir ao estado 54
    FLOAT               deslocar, e ir ao estado 6
    FOR                 deslocar, e ir ao estado 55
    IF                  deslocar, e ir ao estado 56
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    PRINT               deslocar, e ir ao estado 61
    PRINTLN             deslocar, e ir ao estado 62
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    READ                deslocar, e ir ao estado 64
    RETURN              deslocar, e ir ao estado 65
    WHILE               deslocar, e ir ao estado 67
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    block                                       ir ao estado 330
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 26
    primitive_type                              ir ao estado 27
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 323

   33 selection_statement: IF L_PAREN expression R_PAREN block ELSIF . elsif_staments END_IF
   36 elsif_staments: . elsif_stament
   37               | . elsif_staments ELSIF elsif_stament
   38               | . ELSE block
   39 elsif_stament: . L_PAREN expression R_PAREN block

    ELSE     deslocar, e ir ao estado 331
    L_PAREN  deslocar, e ir ao estado 332

    elsif_staments  ir ao estado 333
    elsif_stament   ir ao estado 334


State 324

   35 selection_statement: IF L_PAREN expression R_PAREN block END_IF .

    $padrão  reduzir usando a regra 35 (selection_statement)


State 325

   58 read_statement: READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 335


State 326

   40 iteration_statement: WHILE L_PAREN expression R_PAREN block END_WHILE .

    $padrão  reduzir usando a regra 40 (iteration_statement)


State 327

   65 variable_declarations: . variable_declaration
   66                      | . variable_declarations variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
   94 choice: WHEN IDENTIFIER THEN . variable_declarations

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 4
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9
    STATIC      deslocar, e ir ao estado 11

    variable_declarations  ir ao estado 336
    variable_declaration   ir ao estado 47
    modifiers              ir ao estado 23
    modifier               ir ao estado 24
    type_specifier         ir ao estado 25
    type_name              ir ao estado 26
    primitive_type         ir ao estado 27
    qualified_name         ir ao estado 28


State 328

   42 iteration_statement: FOR L_PAREN for_init for_expr R_PAREN block END_FOR .

    $padrão  reduzir usando a regra 42 (iteration_statement)


State 329

   41 iteration_statement: FOR L_PAREN for_init for_expr for_incr R_PAREN block . END_FOR

    END_FOR  deslocar, e ir ao estado 337


State 330

   34 selection_statement: IF L_PAREN expression R_PAREN block ELSE block . END_IF

    END_IF  deslocar, e ir ao estado 338


State 331

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   38 elsif_staments: ELSE . block
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 52
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    CONTINUE            deslocar, e ir ao estado 54
    FLOAT               deslocar, e ir ao estado 6
    FOR                 deslocar, e ir ao estado 55
    IF                  deslocar, e ir ao estado 56
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    PRINT               deslocar, e ir ao estado 61
    PRINTLN             deslocar, e ir ao estado 62
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    READ                deslocar, e ir ao estado 64
    RETURN              deslocar, e ir ao estado 65
    WHILE               deslocar, e ir ao estado 67
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    block                                       ir ao estado 339
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 26
    primitive_type                              ir ao estado 27
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 332

   39 elsif_stament: L_PAREN . expression R_PAREN block
   88 qualified_name: . IDENTIFIER
  107 expression: . assignment_expression
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    qualified_name                  ir ao estado 152
    expression                      ir ao estado 340
    assignment_expression           ir ao estado 144
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 333

   33 selection_statement: IF L_PAREN expression R_PAREN block ELSIF elsif_staments . END_IF
   37 elsif_staments: elsif_staments . ELSIF elsif_stament

    ELSIF   deslocar, e ir ao estado 341
    END_IF  deslocar, e ir ao estado 342


State 334

   36 elsif_staments: elsif_stament .

    $padrão  reduzir usando a regra 36 (elsif_staments)


State 335

   58 read_statement: READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON .

    $padrão  reduzir usando a regra 58 (read_statement)


State 336

   66 variable_declarations: variable_declarations . variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
   94 choice: WHEN IDENTIFIER THEN variable_declarations .  [END_CASE, WHEN]

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CONST       deslocar, e ir ao estado 4
    FLOAT       deslocar, e ir ao estado 6
    INT         deslocar, e ir ao estado 7
    LONG        deslocar, e ir ao estado 8
    STRING      deslocar, e ir ao estado 9
    STATIC      deslocar, e ir ao estado 11

    $padrão  reduzir usando a regra 94 (choice)

    variable_declaration  ir ao estado 125
    modifiers             ir ao estado 23
    modifier              ir ao estado 24
    type_specifier        ir ao estado 25
    type_name             ir ao estado 26
    primitive_type        ir ao estado 27
    qualified_name        ir ao estado 28


State 337

   41 iteration_statement: FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR .

    $padrão  reduzir usando a regra 41 (iteration_statement)


State 338

   34 selection_statement: IF L_PAREN expression R_PAREN block ELSE block END_IF .

    $padrão  reduzir usando a regra 34 (selection_statement)


State 339

   38 elsif_staments: ELSE block .

    $padrão  reduzir usando a regra 38 (elsif_staments)


State 340

   39 elsif_stament: L_PAREN expression . R_PAREN block

    R_PAREN  deslocar, e ir ao estado 343


State 341

   37 elsif_staments: elsif_staments ELSIF . elsif_stament
   39 elsif_stament: . L_PAREN expression R_PAREN block

    L_PAREN  deslocar, e ir ao estado 332

    elsif_stament  ir ao estado 344


State 342

   33 selection_statement: IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF .

    $padrão  reduzir usando a regra 33 (selection_statement)


State 343

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   39 elsif_stament: L_PAREN expression R_PAREN . block
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . INT
   79               | . LONG
   80               | . FLOAT
   81               | . STRING
   88 qualified_name: . IDENTIFIER
  108 assignment_expression: . conditional_or_expression
  109                      | . unary_expression assignment_operator assignment_expression
  110 unary_expression: . arithmetic_unary_operator cast_expression
  111                 | . logical_unary_expression
  112 logical_unary_expression: . postfix_expression
  113                         | . logical_unary_operator unary_expression
  114 postfix_expression: . primary_expression
  115 primary_expression: . qualified_name
  116                   | . not_just_name
  117 arithmetic_unary_operator: . OP_PLUS
  118                          | . OP_MINUS
  119 logical_unary_operator: . BITWISE_COMPLEMENT
  120                       | . LOG_NOT
  121 conditional_or_expression: . conditional_and_expression
  122                          | . conditional_or_expression LOG_OR conditional_and_expression
  123                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  124 conditional_and_expression: . inclusive_or_expression
  125                           | . conditional_and_expression LOG_AND inclusive_or_expression
  126                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  127 inclusive_or_expression: . exclusive_or_expression
  128                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  129 exclusive_or_expression: . and_expression
  130                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  131 and_expression: . equality_expression
  132               | . and_expression AMPERSAND equality_expression
  133 equality_expression: . relational_expression
  134                    | . equality_expression OP_EQ relational_expression
  135                    | . equality_expression OP_NE relational_expression
  136 relational_expression: . shift_expression
  137                      | . relational_expression OP_LT shift_expression
  138                      | . relational_expression OP_GT shift_expression
  139                      | . relational_expression OP_LET shift_expression
  140                      | . relational_expression OP_GET shift_expression
  141 shift_expression: . additive_expression
  142                 | . shift_expression L_SHIFT additive_expression
  143                 | . shift_expression R_SHIFT additive_expression
  144 additive_expression: . multiplicative_expression
  145                    | . additive_expression OP_PLUS multiplicative_expression
  146                    | . additive_expression OP_MINUS multiplicative_expression
  147 multiplicative_expression: . cast_expression
  148                          | . multiplicative_expression OP_ASTERISK cast_expression
  149                          | . multiplicative_expression OP_DIV cast_expression
  150                          | . multiplicative_expression OP_MOD cast_expression
  151 cast_expression: . unary_expression
  152                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  153                | . L_PAREN user_type_expression R_PAREN cast_expression
  154                | . L_PAREN expression R_PAREN logical_unary_expression
  169 not_just_name: . complex_primary
  170 complex_primary: . L_PAREN expression R_PAREN
  171                | . complex_primary_no_parenthesis
  172 complex_primary_no_parenthesis: . BOOL_LITERAL
  173                               | . OCTAL
  174                               | . DECIMAL
  175                               | . HEX
  176                               | . FLOATING_POINT
  177                               | . NNULL
  178                               | . STRING_LITERAL
  179                               | . array_access
  180                               | . field_access
  181                               | . subprogram_call
  182 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  183             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  184 field_access: . postfix_expression DOT IDENTIFIER
  185 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  186                | . subprogram_access L_PAREN R_PAREN
  187 subprogram_access: . complex_primary_no_parenthesis
  188                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 52
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 53
    CONTINUE            deslocar, e ir ao estado 54
    FLOAT               deslocar, e ir ao estado 6
    FOR                 deslocar, e ir ao estado 55
    IF                  deslocar, e ir ao estado 56
    INT                 deslocar, e ir ao estado 7
    L_PAREN             deslocar, e ir ao estado 57
    LOG_NOT             deslocar, e ir ao estado 58
    LONG                deslocar, e ir ao estado 8
    OP_PLUS             deslocar, e ir ao estado 59
    OP_MINUS            deslocar, e ir ao estado 60
    PRINT               deslocar, e ir ao estado 61
    PRINTLN             deslocar, e ir ao estado 62
    STRING              deslocar, e ir ao estado 9
    STATIC              deslocar, e ir ao estado 63
    READ                deslocar, e ir ao estado 64
    RETURN              deslocar, e ir ao estado 65
    WHILE               deslocar, e ir ao estado 67
    STRING_LITERAL      deslocar, e ir ao estado 68
    DECIMAL             deslocar, e ir ao estado 69
    HEX                 deslocar, e ir ao estado 70
    OCTAL               deslocar, e ir ao estado 71
    FLOATING_POINT      deslocar, e ir ao estado 72
    BOOL_LITERAL        deslocar, e ir ao estado 73
    NNULL               deslocar, e ir ao estado 74

    block                                       ir ao estado 345
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 26
    primitive_type                              ir ao estado 27
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 344

   37 elsif_staments: elsif_staments ELSIF elsif_stament .

    $padrão  reduzir usando a regra 37 (elsif_staments)


State 345

   39 elsif_stament: L_PAREN expression R_PAREN block .

    $padrão  reduzir usando a regra 39 (elsif_stament)
