Terminais não utilizados na gramática

   CHAR_LITERAL
   BREAK
   BYTE
   CASE
   CONTINUE
   DO
   ELSE
   ELSIF
   END_CASE
   END_FOR
   END_FUNCTION
   END_IF
   END_PROCEDURE
   END_WHILE
   FOR
   IF
   NNULL
   OP_PTR
   PRINT
   PRINTLN
   READ
   RETURN
   SIZEOF
   WHEN
   WHILE


Estado 95 conflitos: 1 de deslocamento/redução


Gramática

    0 $accept: translation_unit $end

    1 translation_unit: program_file

    2 program_file: declarations

    3 declarations: declaration
    4             | declarations declaration

    5 declaration: function_declaration
    6            | procedure_declaration
    7            | type_declaration
    8            | variable_declaration

    9 function_declaration: FUNCTION

   10 procedure_declaration: PROCEDURE

   11 type_declaration: STRUCT IDENTIFIER variable_declarations END_STRUCT
   12                 | UNION IDENTIFIER discriminant union_body END_UNION
   13                 | ENUM IDENTIFIER enumerator_list END_ENUM

   14 variable_declarations: variable_declaration
   15                      | variable_declarations variable_declaration

   16 variable_declaration: modifiers type_specifier variable_declarators SEMICOLON
   17                     | type_specifier variable_declarators SEMICOLON

   18 modifiers: modifier
   19          | modifiers modifier

   20 modifier: CONST
   21         | STATIC

   22 type_specifier: type_name

   23 type_name: primitive_type
   24          | qualified_name

   25 primitive_type: AUTO
   26               | BOOL
   27               | CHAR
   28               | DOUBLE
   29               | FLOAT
   30               | INT
   31               | LONG
   32               | SHORT
   33               | STRING

   34 discriminant: %empty

   35 enumerator_list: enumerator
   36                | enumerator_list COMMA enumerator

   37 enumerator: IDENTIFIER ASSIGN expression
   38           | IDENTIFIER

   39 qualified_name: IDENTIFIER

   40 union_body: %empty

   41 variable_declarators: variable_declarator
   42                     | variable_declarators COMMA variable_declarator

   43 variable_declarator: declarator_name
   44                    | declarator_name ASSIGN variable_initializer

   45 declarator_name: IDENTIFIER
   46                | declarator_name L_SQ_PAREN expression R_SQ_PAREN

   47 variable_initializer: expression
   48                     | L_BRACE R_BRACE
   49                     | L_BRACE array_initializers R_BRACE

   50 array_initializers: variable_initializer
   51                   | array_initializers COMMA variable_initializer
   52                   | array_initializers COMMA

   53 expression: assignment_expression

   54 assignment_expression: conditional_or_expression
   55                      | unary_expression assignment_operator assignment_expression

   56 unary_expression: arithmetic_unary_operator cast_expression
   57                 | logical_unary_expression

   58 logical_unary_expression: postfix_expression
   59                         | logical_unary_operator unary_expression

   60 postfix_expression: primary_expression

   61 primary_expression: qualified_name
   62                   | not_just_name

   63 arithmetic_unary_operator: OP_PLUS
   64                          | OP_MINUS

   65 logical_unary_operator: BITWISE_COMPLEMENT
   66                       | LOG_NOT

   67 conditional_or_expression: conditional_and_expression
   68                          | conditional_or_expression LOG_OR conditional_and_expression
   69                          | conditional_or_expression LOG_SC_OR conditional_and_expression

   70 conditional_and_expression: inclusive_or_expression
   71                           | conditional_and_expression LOG_AND inclusive_or_expression
   72                           | conditional_and_expression LOG_SC_AND inclusive_or_expression

   73 inclusive_or_expression: exclusive_or_expression
   74                        | inclusive_or_expression BITWISE_OR exclusive_or_expression

   75 exclusive_or_expression: and_expression
   76                        | exclusive_or_expression BITWISE_OR_EXC and_expression

   77 and_expression: equality_expression
   78               | and_expression AMPERSAND equality_expression

   79 equality_expression: relational_expression
   80                    | equality_expression OP_EQ relational_expression
   81                    | equality_expression OP_NE relational_expression

   82 relational_expression: shift_expression
   83                      | relational_expression OP_LT shift_expression
   84                      | relational_expression OP_GT shift_expression
   85                      | relational_expression OP_LET shift_expression
   86                      | relational_expression OP_GET shift_expression
   87                      | relational_expression TYPEOF type_specifier

   88 shift_expression: additive_expression
   89                 | shift_expression L_SHIFT additive_expression
   90                 | shift_expression R_SHIFT additive_expression

   91 additive_expression: multiplicative_expression
   92                    | additive_expression OP_PLUS multiplicative_expression
   93                    | additive_expression OP_MINUS multiplicative_expression

   94 multiplicative_expression: cast_expression
   95                          | multiplicative_expression OP_ASTERISK cast_expression
   96                          | multiplicative_expression OP_DIV cast_expression
   97                          | multiplicative_expression OP_MOD cast_expression

   98 cast_expression: unary_expression
   99                | L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | L_PAREN user_type_expression R_PAREN cast_expression
  101                | L_PAREN expression R_PAREN logical_unary_expression

  102 primitive_type_expression: primitive_type
  103                          | primitive_type dims

  104 user_type_expression: qualified_name dims

  105 assignment_operator: ASSIGN
  106                    | ASSIGN_PLUS
  107                    | ASSIGN_MINUS
  108                    | ASSIGN_PRODUCT
  109                    | ASSIGN_DIV
  110                    | ASSIGN_MOD
  111                    | ASSIGN_BITWISE_AND
  112                    | ASSIGN_BITWISE_OR
  113                    | ASSIGN_BITWISE_OR_EXC
  114                    | ASSIGN_L_SHIFT
  115                    | ASSIGN_R_SHIFT

  116 not_just_name: complex_primary

  117 complex_primary: L_PAREN expression R_PAREN
  118                | complex_primary_no_parenthesis

  119 complex_primary_no_parenthesis: BOOL_LITERAL
  120                               | OCTAL
  121                               | DECIMAL
  122                               | HEX
  123                               | FLOATING_POINT
  124                               | STRING_LITERAL
  125                               | array_access
  126                               | field_access
  127                               | subprogram_call

  128 array_access: qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | complex_primary L_SQ_PAREN expression R_SQ_PAREN

  130 field_access: not_just_name DOT IDENTIFIER
  131             | postfix_expression DOT IDENTIFIER

  132 subprogram_call: subprogram_access L_PAREN argument_list R_PAREN
  133                | subprogram_access L_PAREN R_PAREN

  134 subprogram_access: complex_primary_no_parenthesis
  135                  | qualified_name

  136 argument_list: expression
  137              | argument_list COMMA expression

  138 dims: L_SQ_PAREN R_SQ_PAREN
  139     | dims L_SQ_PAREN R_SQ_PAREN


Terminais, com as regras onde eles aparecem

$end (0) 0
error (256)
IDENTIFIER (258) 11 12 13 37 38 39 45 130 131
STRING_LITERAL (259) 124
DECIMAL (260) 121
HEX (261) 122
OCTAL (262) 120
FLOATING_POINT (263) 123
BOOL_LITERAL (264) 119
CHAR_LITERAL (265)
ASSIGN (266) 37 44 105
ASSIGN_PLUS (267) 106
ASSIGN_MINUS (268) 107
ASSIGN_PRODUCT (269) 108
ASSIGN_DIV (270) 109
ASSIGN_MOD (271) 110
ASSIGN_BITWISE_AND (272) 111
ASSIGN_BITWISE_OR (273) 112
ASSIGN_BITWISE_OR_EXC (274) 113
ASSIGN_L_SHIFT (275) 114
ASSIGN_R_SHIFT (276) 115
AMPERSAND (277) 78
AUTO (278) 25
BOOL (279) 26
BREAK (280)
BYTE (281)
BITWISE_COMPLEMENT (282) 65
BITWISE_OR (283) 74
BITWISE_OR_EXC (284) 76
CASE (285)
CHAR (286) 27
COMMA (287) 36 42 51 52 137
CONTINUE (288)
CONST (289) 20
DO (290)
DOT (291) 130 131
DOUBLE (292) 28
ENUM (293) 13
ELSE (294)
ELSIF (295)
END_CASE (296)
END_ENUM (297) 13
END_FOR (298)
END_FUNCTION (299)
END_IF (300)
END_PROCEDURE (301)
END_STRUCT (302) 11
END_UNION (303) 12
END_WHILE (304)
FLOAT (305) 29
FOR (306)
FUNCTION (307) 9
IF (308)
INT (309) 30
L_PAREN (310) 99 100 101 117 132 133
L_SQ_PAREN (311) 46 128 129 138 139
L_BRACE (312) 48 49
L_SHIFT (313) 89
LOG_NOT (314) 66
LOG_AND (315) 71
LOG_OR (316) 68
LOG_SC_AND (317) 72
LOG_SC_OR (318) 69
LONG (319) 31
NNULL (320)
OP_EQ (321) 80
OP_NE (322) 81
OP_PTR (323)
OP_PLUS (324) 63 92
OP_MINUS (325) 64 93
OP_ASTERISK (326) 95
OP_DIV (327) 96
OP_MOD (328) 97
OP_LET (329) 85
OP_LT (330) 83
OP_GET (331) 86
OP_GT (332) 84
PRINT (333)
PRINTLN (334)
PROCEDURE (335) 10
READ (336)
RETURN (337)
R_PAREN (338) 99 100 101 117 132 133
R_SQ_PAREN (339) 46 128 129 138 139
R_BRACE (340) 48 49
R_SHIFT (341) 90
SHORT (342) 32
STRING (343) 33
STRUCT (344) 11
STATIC (345) 21
SIZEOF (346)
SEMICOLON (347) 16 17
TYPEOF (348) 87
UNION (349) 12
WHEN (350)
WHILE (351)


Não-terminais com as regras onde eles aparecem

$accept (97)
    à esquerda: 0
translation_unit (98)
    à esquerda: 1, à direita: 0
program_file (99)
    à esquerda: 2, à direita: 1
declarations (100)
    à esquerda: 3 4, à direita: 2 4
declaration (101)
    à esquerda: 5 6 7 8, à direita: 3 4
function_declaration (102)
    à esquerda: 9, à direita: 5
procedure_declaration (103)
    à esquerda: 10, à direita: 6
type_declaration (104)
    à esquerda: 11 12 13, à direita: 7
variable_declarations (105)
    à esquerda: 14 15, à direita: 11 15
variable_declaration (106)
    à esquerda: 16 17, à direita: 8 14 15
modifiers (107)
    à esquerda: 18 19, à direita: 16 19
modifier (108)
    à esquerda: 20 21, à direita: 18 19
type_specifier (109)
    à esquerda: 22, à direita: 16 17 87
type_name (110)
    à esquerda: 23 24, à direita: 22
primitive_type (111)
    à esquerda: 25 26 27 28 29 30 31 32 33, à direita: 23 102 103
discriminant (112)
    à esquerda: 34, à direita: 12
enumerator_list (113)
    à esquerda: 35 36, à direita: 13 36
enumerator (114)
    à esquerda: 37 38, à direita: 35 36
qualified_name (115)
    à esquerda: 39, à direita: 24 61 104 128 135
union_body (116)
    à esquerda: 40, à direita: 12
variable_declarators (117)
    à esquerda: 41 42, à direita: 16 17 42
variable_declarator (118)
    à esquerda: 43 44, à direita: 41 42
declarator_name (119)
    à esquerda: 45 46, à direita: 43 44 46
variable_initializer (120)
    à esquerda: 47 48 49, à direita: 44 50 51
array_initializers (121)
    à esquerda: 50 51 52, à direita: 49 51 52
expression (122)
    à esquerda: 53, à direita: 37 46 47 101 117 128 129 136 137
assignment_expression (123)
    à esquerda: 54 55, à direita: 53 55
unary_expression (124)
    à esquerda: 56 57, à direita: 55 59 98
logical_unary_expression (125)
    à esquerda: 58 59, à direita: 57 101
postfix_expression (126)
    à esquerda: 60, à direita: 58 131
primary_expression (127)
    à esquerda: 61 62, à direita: 60
arithmetic_unary_operator (128)
    à esquerda: 63 64, à direita: 56
logical_unary_operator (129)
    à esquerda: 65 66, à direita: 59
conditional_or_expression (130)
    à esquerda: 67 68 69, à direita: 54 68 69
conditional_and_expression (131)
    à esquerda: 70 71 72, à direita: 67 68 69 71 72
inclusive_or_expression (132)
    à esquerda: 73 74, à direita: 70 71 72 74
exclusive_or_expression (133)
    à esquerda: 75 76, à direita: 73 74 76
and_expression (134)
    à esquerda: 77 78, à direita: 75 76 78
equality_expression (135)
    à esquerda: 79 80 81, à direita: 77 78 80 81
relational_expression (136)
    à esquerda: 82 83 84 85 86 87, à direita: 79 80 81 83 84 85 86
    87
shift_expression (137)
    à esquerda: 88 89 90, à direita: 82 83 84 85 86 89 90
additive_expression (138)
    à esquerda: 91 92 93, à direita: 88 89 90 92 93
multiplicative_expression (139)
    à esquerda: 94 95 96 97, à direita: 91 92 93 95 96 97
cast_expression (140)
    à esquerda: 98 99 100 101, à direita: 56 94 95 96 97 99 100
primitive_type_expression (141)
    à esquerda: 102 103, à direita: 99
user_type_expression (142)
    à esquerda: 104, à direita: 100
assignment_operator (143)
    à esquerda: 105 106 107 108 109 110 111 112 113 114 115, à direita:
    55
not_just_name (144)
    à esquerda: 116, à direita: 62 130
complex_primary (145)
    à esquerda: 117 118, à direita: 116 129
complex_primary_no_parenthesis (146)
    à esquerda: 119 120 121 122 123 124 125 126 127, à direita: 118
    134
array_access (147)
    à esquerda: 128 129, à direita: 125
field_access (148)
    à esquerda: 130 131, à direita: 126
subprogram_call (149)
    à esquerda: 132 133, à direita: 127
subprogram_access (150)
    à esquerda: 134 135, à direita: 132 133
argument_list (151)
    à esquerda: 136 137, à direita: 132 137
dims (152)
    à esquerda: 138 139, à direita: 103 104 139


State 0

    0 $accept: . translation_unit $end
    1 translation_unit: . program_file
    2 program_file: . declarations
    3 declarations: . declaration
    4             | . declarations declaration
    5 declaration: . function_declaration
    6            | . procedure_declaration
    7            | . type_declaration
    8            | . variable_declaration
    9 function_declaration: . FUNCTION
   10 procedure_declaration: . PROCEDURE
   11 type_declaration: . STRUCT IDENTIFIER variable_declarations END_STRUCT
   12                 | . UNION IDENTIFIER discriminant union_body END_UNION
   13                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   16 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   17                     | . type_specifier variable_declarators SEMICOLON
   18 modifiers: . modifier
   19          | . modifiers modifier
   20 modifier: . CONST
   21         | . STATIC
   22 type_specifier: . type_name
   23 type_name: . primitive_type
   24          | . qualified_name
   25 primitive_type: . AUTO
   26               | . BOOL
   27               | . CHAR
   28               | . DOUBLE
   29               | . FLOAT
   30               | . INT
   31               | . LONG
   32               | . SHORT
   33               | . STRING
   39 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    ENUM        deslocar, e ir ao estado 7
    FLOAT       deslocar, e ir ao estado 8
    FUNCTION    deslocar, e ir ao estado 9
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    PROCEDURE   deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STRUCT      deslocar, e ir ao estado 15
    STATIC      deslocar, e ir ao estado 16
    UNION       deslocar, e ir ao estado 17

    translation_unit       ir ao estado 18
    program_file           ir ao estado 19
    declarations           ir ao estado 20
    declaration            ir ao estado 21
    function_declaration   ir ao estado 22
    procedure_declaration  ir ao estado 23
    type_declaration       ir ao estado 24
    variable_declaration   ir ao estado 25
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31


State 1

   39 qualified_name: IDENTIFIER .

    $padrão  reduzir usando a regra 39 (qualified_name)


State 2

   25 primitive_type: AUTO .

    $padrão  reduzir usando a regra 25 (primitive_type)


State 3

   26 primitive_type: BOOL .

    $padrão  reduzir usando a regra 26 (primitive_type)


State 4

   27 primitive_type: CHAR .

    $padrão  reduzir usando a regra 27 (primitive_type)


State 5

   20 modifier: CONST .

    $padrão  reduzir usando a regra 20 (modifier)


State 6

   28 primitive_type: DOUBLE .

    $padrão  reduzir usando a regra 28 (primitive_type)


State 7

   13 type_declaration: ENUM . IDENTIFIER enumerator_list END_ENUM

    IDENTIFIER  deslocar, e ir ao estado 32


State 8

   29 primitive_type: FLOAT .

    $padrão  reduzir usando a regra 29 (primitive_type)


State 9

    9 function_declaration: FUNCTION .

    $padrão  reduzir usando a regra 9 (function_declaration)


State 10

   30 primitive_type: INT .

    $padrão  reduzir usando a regra 30 (primitive_type)


State 11

   31 primitive_type: LONG .

    $padrão  reduzir usando a regra 31 (primitive_type)


State 12

   10 procedure_declaration: PROCEDURE .

    $padrão  reduzir usando a regra 10 (procedure_declaration)


State 13

   32 primitive_type: SHORT .

    $padrão  reduzir usando a regra 32 (primitive_type)


State 14

   33 primitive_type: STRING .

    $padrão  reduzir usando a regra 33 (primitive_type)


State 15

   11 type_declaration: STRUCT . IDENTIFIER variable_declarations END_STRUCT

    IDENTIFIER  deslocar, e ir ao estado 33


State 16

   21 modifier: STATIC .

    $padrão  reduzir usando a regra 21 (modifier)


State 17

   12 type_declaration: UNION . IDENTIFIER discriminant union_body END_UNION

    IDENTIFIER  deslocar, e ir ao estado 34


State 18

    0 $accept: translation_unit . $end

    $end  deslocar, e ir ao estado 35


State 19

    1 translation_unit: program_file .

    $padrão  reduzir usando a regra 1 (translation_unit)


State 20

    2 program_file: declarations .  [$end]
    4 declarations: declarations . declaration
    5 declaration: . function_declaration
    6            | . procedure_declaration
    7            | . type_declaration
    8            | . variable_declaration
    9 function_declaration: . FUNCTION
   10 procedure_declaration: . PROCEDURE
   11 type_declaration: . STRUCT IDENTIFIER variable_declarations END_STRUCT
   12                 | . UNION IDENTIFIER discriminant union_body END_UNION
   13                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   16 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   17                     | . type_specifier variable_declarators SEMICOLON
   18 modifiers: . modifier
   19          | . modifiers modifier
   20 modifier: . CONST
   21         | . STATIC
   22 type_specifier: . type_name
   23 type_name: . primitive_type
   24          | . qualified_name
   25 primitive_type: . AUTO
   26               | . BOOL
   27               | . CHAR
   28               | . DOUBLE
   29               | . FLOAT
   30               | . INT
   31               | . LONG
   32               | . SHORT
   33               | . STRING
   39 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    ENUM        deslocar, e ir ao estado 7
    FLOAT       deslocar, e ir ao estado 8
    FUNCTION    deslocar, e ir ao estado 9
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    PROCEDURE   deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STRUCT      deslocar, e ir ao estado 15
    STATIC      deslocar, e ir ao estado 16
    UNION       deslocar, e ir ao estado 17

    $padrão  reduzir usando a regra 2 (program_file)

    declaration            ir ao estado 36
    function_declaration   ir ao estado 22
    procedure_declaration  ir ao estado 23
    type_declaration       ir ao estado 24
    variable_declaration   ir ao estado 25
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31


State 21

    3 declarations: declaration .

    $padrão  reduzir usando a regra 3 (declarations)


State 22

    5 declaration: function_declaration .

    $padrão  reduzir usando a regra 5 (declaration)


State 23

    6 declaration: procedure_declaration .

    $padrão  reduzir usando a regra 6 (declaration)


State 24

    7 declaration: type_declaration .

    $padrão  reduzir usando a regra 7 (declaration)


State 25

    8 declaration: variable_declaration .

    $padrão  reduzir usando a regra 8 (declaration)


State 26

   16 variable_declaration: modifiers . type_specifier variable_declarators SEMICOLON
   19 modifiers: modifiers . modifier
   20 modifier: . CONST
   21         | . STATIC
   22 type_specifier: . type_name
   23 type_name: . primitive_type
   24          | . qualified_name
   25 primitive_type: . AUTO
   26               | . BOOL
   27               | . CHAR
   28               | . DOUBLE
   29               | . FLOAT
   30               | . INT
   31               | . LONG
   32               | . SHORT
   33               | . STRING
   39 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    modifier        ir ao estado 37
    type_specifier  ir ao estado 38
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 27

   18 modifiers: modifier .

    $padrão  reduzir usando a regra 18 (modifiers)


State 28

   17 variable_declaration: type_specifier . variable_declarators SEMICOLON
   41 variable_declarators: . variable_declarator
   42                     | . variable_declarators COMMA variable_declarator
   43 variable_declarator: . declarator_name
   44                    | . declarator_name ASSIGN variable_initializer
   45 declarator_name: . IDENTIFIER
   46                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 39

    variable_declarators  ir ao estado 40
    variable_declarator   ir ao estado 41
    declarator_name       ir ao estado 42


State 29

   22 type_specifier: type_name .

    $padrão  reduzir usando a regra 22 (type_specifier)


State 30

   23 type_name: primitive_type .

    $padrão  reduzir usando a regra 23 (type_name)


State 31

   24 type_name: qualified_name .

    $padrão  reduzir usando a regra 24 (type_name)


State 32

   13 type_declaration: ENUM IDENTIFIER . enumerator_list END_ENUM
   35 enumerator_list: . enumerator
   36                | . enumerator_list COMMA enumerator
   37 enumerator: . IDENTIFIER ASSIGN expression
   38           | . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 43

    enumerator_list  ir ao estado 44
    enumerator       ir ao estado 45


State 33

   11 type_declaration: STRUCT IDENTIFIER . variable_declarations END_STRUCT
   14 variable_declarations: . variable_declaration
   15                      | . variable_declarations variable_declaration
   16 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   17                     | . type_specifier variable_declarators SEMICOLON
   18 modifiers: . modifier
   19          | . modifiers modifier
   20 modifier: . CONST
   21         | . STATIC
   22 type_specifier: . type_name
   23 type_name: . primitive_type
   24          | . qualified_name
   25 primitive_type: . AUTO
   26               | . BOOL
   27               | . CHAR
   28               | . DOUBLE
   29               | . FLOAT
   30               | . INT
   31               | . LONG
   32               | . SHORT
   33               | . STRING
   39 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    variable_declarations  ir ao estado 46
    variable_declaration   ir ao estado 47
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31


State 34

   12 type_declaration: UNION IDENTIFIER . discriminant union_body END_UNION
   34 discriminant: . %empty

    $padrão  reduzir usando a regra 34 (discriminant)

    discriminant  ir ao estado 48


State 35

    0 $accept: translation_unit $end .

    $padrão  aceitar


State 36

    4 declarations: declarations declaration .

    $padrão  reduzir usando a regra 4 (declarations)


State 37

   19 modifiers: modifiers modifier .

    $padrão  reduzir usando a regra 19 (modifiers)


State 38

   16 variable_declaration: modifiers type_specifier . variable_declarators SEMICOLON
   41 variable_declarators: . variable_declarator
   42                     | . variable_declarators COMMA variable_declarator
   43 variable_declarator: . declarator_name
   44                    | . declarator_name ASSIGN variable_initializer
   45 declarator_name: . IDENTIFIER
   46                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 39

    variable_declarators  ir ao estado 49
    variable_declarator   ir ao estado 41
    declarator_name       ir ao estado 42


State 39

   45 declarator_name: IDENTIFIER .

    $padrão  reduzir usando a regra 45 (declarator_name)


State 40

   17 variable_declaration: type_specifier variable_declarators . SEMICOLON
   42 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 50
    SEMICOLON  deslocar, e ir ao estado 51


State 41

   41 variable_declarators: variable_declarator .

    $padrão  reduzir usando a regra 41 (variable_declarators)


State 42

   43 variable_declarator: declarator_name .  [COMMA, SEMICOLON]
   44                    | declarator_name . ASSIGN variable_initializer
   46 declarator_name: declarator_name . L_SQ_PAREN expression R_SQ_PAREN

    ASSIGN      deslocar, e ir ao estado 52
    L_SQ_PAREN  deslocar, e ir ao estado 53

    $padrão  reduzir usando a regra 43 (variable_declarator)


State 43

   37 enumerator: IDENTIFIER . ASSIGN expression
   38           | IDENTIFIER .  [COMMA, END_ENUM]

    ASSIGN  deslocar, e ir ao estado 54

    $padrão  reduzir usando a regra 38 (enumerator)


State 44

   13 type_declaration: ENUM IDENTIFIER enumerator_list . END_ENUM
   36 enumerator_list: enumerator_list . COMMA enumerator

    COMMA     deslocar, e ir ao estado 55
    END_ENUM  deslocar, e ir ao estado 56


State 45

   35 enumerator_list: enumerator .

    $padrão  reduzir usando a regra 35 (enumerator_list)


State 46

   11 type_declaration: STRUCT IDENTIFIER variable_declarations . END_STRUCT
   15 variable_declarations: variable_declarations . variable_declaration
   16 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   17                     | . type_specifier variable_declarators SEMICOLON
   18 modifiers: . modifier
   19          | . modifiers modifier
   20 modifier: . CONST
   21         | . STATIC
   22 type_specifier: . type_name
   23 type_name: . primitive_type
   24          | . qualified_name
   25 primitive_type: . AUTO
   26               | . BOOL
   27               | . CHAR
   28               | . DOUBLE
   29               | . FLOAT
   30               | . INT
   31               | . LONG
   32               | . SHORT
   33               | . STRING
   39 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    END_STRUCT  deslocar, e ir ao estado 57
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    variable_declaration  ir ao estado 58
    modifiers             ir ao estado 26
    modifier              ir ao estado 27
    type_specifier        ir ao estado 28
    type_name             ir ao estado 29
    primitive_type        ir ao estado 30
    qualified_name        ir ao estado 31


State 47

   14 variable_declarations: variable_declaration .

    $padrão  reduzir usando a regra 14 (variable_declarations)


State 48

   12 type_declaration: UNION IDENTIFIER discriminant . union_body END_UNION
   40 union_body: . %empty

    $padrão  reduzir usando a regra 40 (union_body)

    union_body  ir ao estado 59


State 49

   16 variable_declaration: modifiers type_specifier variable_declarators . SEMICOLON
   42 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 50
    SEMICOLON  deslocar, e ir ao estado 60


State 50

   42 variable_declarators: variable_declarators COMMA . variable_declarator
   43 variable_declarator: . declarator_name
   44                    | . declarator_name ASSIGN variable_initializer
   45 declarator_name: . IDENTIFIER
   46                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 39

    variable_declarator  ir ao estado 61
    declarator_name      ir ao estado 42


State 51

   17 variable_declaration: type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 17 (variable_declaration)


State 52

   39 qualified_name: . IDENTIFIER
   44 variable_declarator: declarator_name ASSIGN . variable_initializer
   47 variable_initializer: . expression
   48                     | . L_BRACE R_BRACE
   49                     | . L_BRACE array_initializers R_BRACE
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    L_BRACE             deslocar, e ir ao estado 70
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    variable_initializer            ir ao estado 75
    expression                      ir ao estado 76
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 53

   39 qualified_name: . IDENTIFIER
   46 declarator_name: declarator_name L_SQ_PAREN . expression R_SQ_PAREN
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    expression                      ir ao estado 102
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 54

   37 enumerator: IDENTIFIER ASSIGN . expression
   39 qualified_name: . IDENTIFIER
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    expression                      ir ao estado 103
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 55

   36 enumerator_list: enumerator_list COMMA . enumerator
   37 enumerator: . IDENTIFIER ASSIGN expression
   38           | . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 43

    enumerator  ir ao estado 104


State 56

   13 type_declaration: ENUM IDENTIFIER enumerator_list END_ENUM .

    $padrão  reduzir usando a regra 13 (type_declaration)


State 57

   11 type_declaration: STRUCT IDENTIFIER variable_declarations END_STRUCT .

    $padrão  reduzir usando a regra 11 (type_declaration)


State 58

   15 variable_declarations: variable_declarations variable_declaration .

    $padrão  reduzir usando a regra 15 (variable_declarations)


State 59

   12 type_declaration: UNION IDENTIFIER discriminant union_body . END_UNION

    END_UNION  deslocar, e ir ao estado 105


State 60

   16 variable_declaration: modifiers type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 16 (variable_declaration)


State 61

   42 variable_declarators: variable_declarators COMMA variable_declarator .

    $padrão  reduzir usando a regra 42 (variable_declarators)


State 62

  124 complex_primary_no_parenthesis: STRING_LITERAL .

    $padrão  reduzir usando a regra 124 (complex_primary_no_parenthesis)


State 63

  121 complex_primary_no_parenthesis: DECIMAL .

    $padrão  reduzir usando a regra 121 (complex_primary_no_parenthesis)


State 64

  122 complex_primary_no_parenthesis: HEX .

    $padrão  reduzir usando a regra 122 (complex_primary_no_parenthesis)


State 65

  120 complex_primary_no_parenthesis: OCTAL .

    $padrão  reduzir usando a regra 120 (complex_primary_no_parenthesis)


State 66

  123 complex_primary_no_parenthesis: FLOATING_POINT .

    $padrão  reduzir usando a regra 123 (complex_primary_no_parenthesis)


State 67

  119 complex_primary_no_parenthesis: BOOL_LITERAL .

    $padrão  reduzir usando a regra 119 (complex_primary_no_parenthesis)


State 68

   65 logical_unary_operator: BITWISE_COMPLEMENT .

    $padrão  reduzir usando a regra 65 (logical_unary_operator)


State 69

   25 primitive_type: . AUTO
   26               | . BOOL
   27               | . CHAR
   28               | . DOUBLE
   29               | . FLOAT
   30               | . INT
   31               | . LONG
   32               | . SHORT
   33               | . STRING
   39 qualified_name: . IDENTIFIER
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
   99                | L_PAREN . primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  100                | L_PAREN . user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  101                | L_PAREN . expression R_PAREN logical_unary_expression
  102 primitive_type_expression: . primitive_type
  103                          | . primitive_type dims
  104 user_type_expression: . qualified_name dims
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  117                | L_PAREN . expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    CHAR                deslocar, e ir ao estado 4
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    LONG                deslocar, e ir ao estado 11
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14

    primitive_type                  ir ao estado 106
    qualified_name                  ir ao estado 107
    expression                      ir ao estado 108
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    primitive_type_expression       ir ao estado 109
    user_type_expression            ir ao estado 110
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 70

   39 qualified_name: . IDENTIFIER
   47 variable_initializer: . expression
   48                     | . L_BRACE R_BRACE
   48                     | L_BRACE . R_BRACE
   49                     | . L_BRACE array_initializers R_BRACE
   49                     | L_BRACE . array_initializers R_BRACE
   50 array_initializers: . variable_initializer
   51                   | . array_initializers COMMA variable_initializer
   52                   | . array_initializers COMMA
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    L_BRACE             deslocar, e ir ao estado 70
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73
    R_BRACE             deslocar, e ir ao estado 111

    qualified_name                  ir ao estado 74
    variable_initializer            ir ao estado 112
    array_initializers              ir ao estado 113
    expression                      ir ao estado 76
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 71

   66 logical_unary_operator: LOG_NOT .

    $padrão  reduzir usando a regra 66 (logical_unary_operator)


State 72

   63 arithmetic_unary_operator: OP_PLUS .

    $padrão  reduzir usando a regra 63 (arithmetic_unary_operator)


State 73

   64 arithmetic_unary_operator: OP_MINUS .

    $padrão  reduzir usando a regra 64 (arithmetic_unary_operator)


State 74

   61 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  128 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  135 subprogram_access: qualified_name .  [L_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 114

    L_PAREN   reduzir usando a regra 135 (subprogram_access)
    $padrão  reduzir usando a regra 61 (primary_expression)


State 75

   44 variable_declarator: declarator_name ASSIGN variable_initializer .

    $padrão  reduzir usando a regra 44 (variable_declarator)


State 76

   47 variable_initializer: expression .

    $padrão  reduzir usando a regra 47 (variable_initializer)


State 77

   53 expression: assignment_expression .

    $padrão  reduzir usando a regra 53 (expression)


State 78

   55 assignment_expression: unary_expression . assignment_operator assignment_expression
   98 cast_expression: unary_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  105 assignment_operator: . ASSIGN
  106                    | . ASSIGN_PLUS
  107                    | . ASSIGN_MINUS
  108                    | . ASSIGN_PRODUCT
  109                    | . ASSIGN_DIV
  110                    | . ASSIGN_MOD
  111                    | . ASSIGN_BITWISE_AND
  112                    | . ASSIGN_BITWISE_OR
  113                    | . ASSIGN_BITWISE_OR_EXC
  114                    | . ASSIGN_L_SHIFT
  115                    | . ASSIGN_R_SHIFT

    ASSIGN                 deslocar, e ir ao estado 115
    ASSIGN_PLUS            deslocar, e ir ao estado 116
    ASSIGN_MINUS           deslocar, e ir ao estado 117
    ASSIGN_PRODUCT         deslocar, e ir ao estado 118
    ASSIGN_DIV             deslocar, e ir ao estado 119
    ASSIGN_MOD             deslocar, e ir ao estado 120
    ASSIGN_BITWISE_AND     deslocar, e ir ao estado 121
    ASSIGN_BITWISE_OR      deslocar, e ir ao estado 122
    ASSIGN_BITWISE_OR_EXC  deslocar, e ir ao estado 123
    ASSIGN_L_SHIFT         deslocar, e ir ao estado 124
    ASSIGN_R_SHIFT         deslocar, e ir ao estado 125

    $padrão  reduzir usando a regra 98 (cast_expression)

    assignment_operator  ir ao estado 126


State 79

   57 unary_expression: logical_unary_expression .

    $padrão  reduzir usando a regra 57 (unary_expression)


State 80

   58 logical_unary_expression: postfix_expression .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  131 field_access: postfix_expression . DOT IDENTIFIER

    DOT  deslocar, e ir ao estado 127

    $padrão  reduzir usando a regra 58 (logical_unary_expression)


State 81

   60 postfix_expression: primary_expression .

    $padrão  reduzir usando a regra 60 (postfix_expression)


State 82

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   56                 | arithmetic_unary_operator . cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    cast_expression                 ir ao estado 129
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 83

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   59                         | logical_unary_operator . unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 130
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 131
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 84

   54 assignment_expression: conditional_or_expression .  [COMMA, END_ENUM, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   68 conditional_or_expression: conditional_or_expression . LOG_OR conditional_and_expression
   69                          | conditional_or_expression . LOG_SC_OR conditional_and_expression

    LOG_OR     deslocar, e ir ao estado 132
    LOG_SC_OR  deslocar, e ir ao estado 133

    $padrão  reduzir usando a regra 54 (assignment_expression)


State 85

   67 conditional_or_expression: conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   71 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
   72                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 134
    LOG_SC_AND  deslocar, e ir ao estado 135

    $padrão  reduzir usando a regra 67 (conditional_or_expression)


State 86

   70 conditional_and_expression: inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   74 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 136

    $padrão  reduzir usando a regra 70 (conditional_and_expression)


State 87

   73 inclusive_or_expression: exclusive_or_expression .  [BITWISE_OR, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   76 exclusive_or_expression: exclusive_or_expression . BITWISE_OR_EXC and_expression

    BITWISE_OR_EXC  deslocar, e ir ao estado 137

    $padrão  reduzir usando a regra 73 (inclusive_or_expression)


State 88

   75 exclusive_or_expression: and_expression .  [BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   78 and_expression: and_expression . AMPERSAND equality_expression

    AMPERSAND  deslocar, e ir ao estado 138

    $padrão  reduzir usando a regra 75 (exclusive_or_expression)


State 89

   77 and_expression: equality_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   80 equality_expression: equality_expression . OP_EQ relational_expression
   81                    | equality_expression . OP_NE relational_expression

    OP_EQ  deslocar, e ir ao estado 139
    OP_NE  deslocar, e ir ao estado 140

    $padrão  reduzir usando a regra 77 (and_expression)


State 90

   79 equality_expression: relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   83 relational_expression: relational_expression . OP_LT shift_expression
   84                      | relational_expression . OP_GT shift_expression
   85                      | relational_expression . OP_LET shift_expression
   86                      | relational_expression . OP_GET shift_expression
   87                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 141
    OP_LT   deslocar, e ir ao estado 142
    OP_GET  deslocar, e ir ao estado 143
    OP_GT   deslocar, e ir ao estado 144
    TYPEOF  deslocar, e ir ao estado 145

    $padrão  reduzir usando a regra 79 (equality_expression)


State 91

   82 relational_expression: shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   89 shift_expression: shift_expression . L_SHIFT additive_expression
   90                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 146
    R_SHIFT  deslocar, e ir ao estado 147

    $padrão  reduzir usando a regra 82 (relational_expression)


State 92

   88 shift_expression: additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
   92 additive_expression: additive_expression . OP_PLUS multiplicative_expression
   93                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 148
    OP_MINUS  deslocar, e ir ao estado 149

    $padrão  reduzir usando a regra 88 (shift_expression)


State 93

   91 additive_expression: multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
   95 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
   96                          | multiplicative_expression . OP_DIV cast_expression
   97                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 150
    OP_DIV       deslocar, e ir ao estado 151
    OP_MOD       deslocar, e ir ao estado 152

    $padrão  reduzir usando a regra 91 (additive_expression)


State 94

   94 multiplicative_expression: cast_expression .

    $padrão  reduzir usando a regra 94 (multiplicative_expression)


State 95

   62 primary_expression: not_just_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  130 field_access: not_just_name . DOT IDENTIFIER

    DOT  deslocar, e ir ao estado 153

    DOT       [reduzir usando a regra 62 (primary_expression)]
    $padrão  reduzir usando a regra 62 (primary_expression)


State 96

  116 not_just_name: complex_primary .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  129 array_access: complex_primary . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 154

    $padrão  reduzir usando a regra 116 (not_just_name)


State 97

  118 complex_primary: complex_primary_no_parenthesis .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  134 subprogram_access: complex_primary_no_parenthesis .  [L_PAREN]

    L_PAREN   reduzir usando a regra 134 (subprogram_access)
    $padrão  reduzir usando a regra 118 (complex_primary)


State 98

  125 complex_primary_no_parenthesis: array_access .

    $padrão  reduzir usando a regra 125 (complex_primary_no_parenthesis)


State 99

  126 complex_primary_no_parenthesis: field_access .

    $padrão  reduzir usando a regra 126 (complex_primary_no_parenthesis)


State 100

  127 complex_primary_no_parenthesis: subprogram_call .

    $padrão  reduzir usando a regra 127 (complex_primary_no_parenthesis)


State 101

  132 subprogram_call: subprogram_access . L_PAREN argument_list R_PAREN
  133                | subprogram_access . L_PAREN R_PAREN

    L_PAREN  deslocar, e ir ao estado 155


State 102

   46 declarator_name: declarator_name L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 156


State 103

   37 enumerator: IDENTIFIER ASSIGN expression .

    $padrão  reduzir usando a regra 37 (enumerator)


State 104

   36 enumerator_list: enumerator_list COMMA enumerator .

    $padrão  reduzir usando a regra 36 (enumerator_list)


State 105

   12 type_declaration: UNION IDENTIFIER discriminant union_body END_UNION .

    $padrão  reduzir usando a regra 12 (type_declaration)


State 106

  102 primitive_type_expression: primitive_type .  [R_PAREN]
  103                          | primitive_type . dims
  138 dims: . L_SQ_PAREN R_SQ_PAREN
  139     | . dims L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 157

    $padrão  reduzir usando a regra 102 (primitive_type_expression)

    dims  ir ao estado 158


State 107

   61 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SHIFT, TYPEOF]
  104 user_type_expression: qualified_name . dims
  128 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  135 subprogram_access: qualified_name .  [L_PAREN]
  138 dims: . L_SQ_PAREN R_SQ_PAREN
  139     | . dims L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 159

    L_PAREN   reduzir usando a regra 135 (subprogram_access)
    $padrão  reduzir usando a regra 61 (primary_expression)

    dims  ir ao estado 160


State 108

  101 cast_expression: L_PAREN expression . R_PAREN logical_unary_expression
  117 complex_primary: L_PAREN expression . R_PAREN

    R_PAREN  deslocar, e ir ao estado 161


State 109

   99 cast_expression: L_PAREN primitive_type_expression . R_PAREN cast_expression

    R_PAREN  deslocar, e ir ao estado 162


State 110

  100 cast_expression: L_PAREN user_type_expression . R_PAREN cast_expression

    R_PAREN  deslocar, e ir ao estado 163


State 111

   48 variable_initializer: L_BRACE R_BRACE .

    $padrão  reduzir usando a regra 48 (variable_initializer)


State 112

   50 array_initializers: variable_initializer .

    $padrão  reduzir usando a regra 50 (array_initializers)


State 113

   49 variable_initializer: L_BRACE array_initializers . R_BRACE
   51 array_initializers: array_initializers . COMMA variable_initializer
   52                   | array_initializers . COMMA

    COMMA    deslocar, e ir ao estado 164
    R_BRACE  deslocar, e ir ao estado 165


State 114

   39 qualified_name: . IDENTIFIER
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  128             | qualified_name L_SQ_PAREN . expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    expression                      ir ao estado 166
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 115

  105 assignment_operator: ASSIGN .

    $padrão  reduzir usando a regra 105 (assignment_operator)


State 116

  106 assignment_operator: ASSIGN_PLUS .

    $padrão  reduzir usando a regra 106 (assignment_operator)


State 117

  107 assignment_operator: ASSIGN_MINUS .

    $padrão  reduzir usando a regra 107 (assignment_operator)


State 118

  108 assignment_operator: ASSIGN_PRODUCT .

    $padrão  reduzir usando a regra 108 (assignment_operator)


State 119

  109 assignment_operator: ASSIGN_DIV .

    $padrão  reduzir usando a regra 109 (assignment_operator)


State 120

  110 assignment_operator: ASSIGN_MOD .

    $padrão  reduzir usando a regra 110 (assignment_operator)


State 121

  111 assignment_operator: ASSIGN_BITWISE_AND .

    $padrão  reduzir usando a regra 111 (assignment_operator)


State 122

  112 assignment_operator: ASSIGN_BITWISE_OR .

    $padrão  reduzir usando a regra 112 (assignment_operator)


State 123

  113 assignment_operator: ASSIGN_BITWISE_OR_EXC .

    $padrão  reduzir usando a regra 113 (assignment_operator)


State 124

  114 assignment_operator: ASSIGN_L_SHIFT .

    $padrão  reduzir usando a regra 114 (assignment_operator)


State 125

  115 assignment_operator: ASSIGN_R_SHIFT .

    $padrão  reduzir usando a regra 115 (assignment_operator)


State 126

   39 qualified_name: . IDENTIFIER
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   55                      | unary_expression assignment_operator . assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    assignment_expression           ir ao estado 167
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 127

  131 field_access: postfix_expression DOT . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 168


State 128

   98 cast_expression: unary_expression .

    $padrão  reduzir usando a regra 98 (cast_expression)


State 129

   56 unary_expression: arithmetic_unary_operator cast_expression .

    $padrão  reduzir usando a regra 56 (unary_expression)


State 130

   39 qualified_name: . IDENTIFIER
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  117                | L_PAREN . expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    expression                      ir ao estado 169
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 131

   59 logical_unary_expression: logical_unary_operator unary_expression .

    $padrão  reduzir usando a regra 59 (logical_unary_expression)


State 132

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   68 conditional_or_expression: conditional_or_expression LOG_OR . conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_and_expression      ir ao estado 170
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 133

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   69 conditional_or_expression: conditional_or_expression LOG_SC_OR . conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_and_expression      ir ao estado 171
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 134

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   71 conditional_and_expression: conditional_and_expression LOG_AND . inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    inclusive_or_expression         ir ao estado 172
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 135

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   72 conditional_and_expression: conditional_and_expression LOG_SC_AND . inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    inclusive_or_expression         ir ao estado 173
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 136

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   74 inclusive_or_expression: inclusive_or_expression BITWISE_OR . exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    exclusive_or_expression         ir ao estado 174
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 137

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   76 exclusive_or_expression: exclusive_or_expression BITWISE_OR_EXC . and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    and_expression                  ir ao estado 175
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 138

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   78 and_expression: and_expression AMPERSAND . equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    equality_expression             ir ao estado 176
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 139

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   80 equality_expression: equality_expression OP_EQ . relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    relational_expression           ir ao estado 177
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 140

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   81 equality_expression: equality_expression OP_NE . relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    relational_expression           ir ao estado 178
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 141

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   85 relational_expression: relational_expression OP_LET . shift_expression
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    shift_expression                ir ao estado 179
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 142

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   83 relational_expression: relational_expression OP_LT . shift_expression
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    shift_expression                ir ao estado 180
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 143

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   86 relational_expression: relational_expression OP_GET . shift_expression
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    shift_expression                ir ao estado 181
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 144

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   84 relational_expression: relational_expression OP_GT . shift_expression
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    shift_expression                ir ao estado 182
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 145

   22 type_specifier: . type_name
   23 type_name: . primitive_type
   24          | . qualified_name
   25 primitive_type: . AUTO
   26               | . BOOL
   27               | . CHAR
   28               | . DOUBLE
   29               | . FLOAT
   30               | . INT
   31               | . LONG
   32               | . SHORT
   33               | . STRING
   39 qualified_name: . IDENTIFIER
   87 relational_expression: relational_expression TYPEOF . type_specifier

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 183
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 146

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   89 shift_expression: shift_expression L_SHIFT . additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    additive_expression             ir ao estado 184
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 147

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   90 shift_expression: shift_expression R_SHIFT . additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    additive_expression             ir ao estado 185
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 148

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   92 additive_expression: additive_expression OP_PLUS . multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    multiplicative_expression       ir ao estado 186
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 149

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   93 additive_expression: additive_expression OP_MINUS . multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    multiplicative_expression       ir ao estado 187
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 150

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   95 multiplicative_expression: multiplicative_expression OP_ASTERISK . cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    cast_expression                 ir ao estado 188
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 151

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   96 multiplicative_expression: multiplicative_expression OP_DIV . cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    cast_expression                 ir ao estado 189
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 152

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   97 multiplicative_expression: multiplicative_expression OP_MOD . cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    cast_expression                 ir ao estado 190
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 153

  130 field_access: not_just_name DOT . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 191


State 154

   39 qualified_name: . IDENTIFIER
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  129             | complex_primary L_SQ_PAREN . expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    expression                      ir ao estado 192
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 155

   39 qualified_name: . IDENTIFIER
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  132                | subprogram_access L_PAREN . argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  133                | subprogram_access L_PAREN . R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name
  136 argument_list: . expression
  137              | . argument_list COMMA expression

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73
    R_PAREN             deslocar, e ir ao estado 193

    qualified_name                  ir ao estado 74
    expression                      ir ao estado 194
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101
    argument_list                   ir ao estado 195


State 156

   46 declarator_name: declarator_name L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 46 (declarator_name)


State 157

  138 dims: L_SQ_PAREN . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 196


State 158

  103 primitive_type_expression: primitive_type dims .  [R_PAREN]
  139 dims: dims . L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 197

    $padrão  reduzir usando a regra 103 (primitive_type_expression)


State 159

   39 qualified_name: . IDENTIFIER
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  128             | qualified_name L_SQ_PAREN . expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name
  138 dims: L_SQ_PAREN . R_SQ_PAREN

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73
    R_SQ_PAREN          deslocar, e ir ao estado 196

    qualified_name                  ir ao estado 74
    expression                      ir ao estado 166
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 160

  104 user_type_expression: qualified_name dims .  [R_PAREN]
  139 dims: dims . L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 197

    $padrão  reduzir usando a regra 104 (user_type_expression)


State 161

   39 qualified_name: . IDENTIFIER
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
  101 cast_expression: L_PAREN expression R_PAREN . logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  117                | L_PAREN expression R_PAREN .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 130
    LOG_NOT             deslocar, e ir ao estado 71

    $padrão  reduzir usando a regra 117 (complex_primary)

    qualified_name                  ir ao estado 74
    logical_unary_expression        ir ao estado 198
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    logical_unary_operator          ir ao estado 83
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 162

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
   99                | L_PAREN primitive_type_expression R_PAREN . cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    cast_expression                 ir ao estado 199
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 163

   39 qualified_name: . IDENTIFIER
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  100                | L_PAREN user_type_expression R_PAREN . cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    unary_expression                ir ao estado 128
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    cast_expression                 ir ao estado 200
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 164

   39 qualified_name: . IDENTIFIER
   47 variable_initializer: . expression
   48                     | . L_BRACE R_BRACE
   49                     | . L_BRACE array_initializers R_BRACE
   51 array_initializers: array_initializers COMMA . variable_initializer
   52                   | array_initializers COMMA .  [COMMA, R_BRACE]
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    L_BRACE             deslocar, e ir ao estado 70
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    $padrão  reduzir usando a regra 52 (array_initializers)

    qualified_name                  ir ao estado 74
    variable_initializer            ir ao estado 201
    expression                      ir ao estado 76
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 165

   49 variable_initializer: L_BRACE array_initializers R_BRACE .

    $padrão  reduzir usando a regra 49 (variable_initializer)


State 166

  128 array_access: qualified_name L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 202


State 167

   55 assignment_expression: unary_expression assignment_operator assignment_expression .

    $padrão  reduzir usando a regra 55 (assignment_expression)


State 168

  131 field_access: postfix_expression DOT IDENTIFIER .

    $padrão  reduzir usando a regra 131 (field_access)


State 169

  117 complex_primary: L_PAREN expression . R_PAREN

    R_PAREN  deslocar, e ir ao estado 203


State 170

   68 conditional_or_expression: conditional_or_expression LOG_OR conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   71 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
   72                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 134
    LOG_SC_AND  deslocar, e ir ao estado 135

    $padrão  reduzir usando a regra 68 (conditional_or_expression)


State 171

   69 conditional_or_expression: conditional_or_expression LOG_SC_OR conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   71 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
   72                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 134
    LOG_SC_AND  deslocar, e ir ao estado 135

    $padrão  reduzir usando a regra 69 (conditional_or_expression)


State 172

   71 conditional_and_expression: conditional_and_expression LOG_AND inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   74 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 136

    $padrão  reduzir usando a regra 71 (conditional_and_expression)


State 173

   72 conditional_and_expression: conditional_and_expression LOG_SC_AND inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   74 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 136

    $padrão  reduzir usando a regra 72 (conditional_and_expression)


State 174

   74 inclusive_or_expression: inclusive_or_expression BITWISE_OR exclusive_or_expression .  [BITWISE_OR, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   76 exclusive_or_expression: exclusive_or_expression . BITWISE_OR_EXC and_expression

    BITWISE_OR_EXC  deslocar, e ir ao estado 137

    $padrão  reduzir usando a regra 74 (inclusive_or_expression)


State 175

   76 exclusive_or_expression: exclusive_or_expression BITWISE_OR_EXC and_expression .  [BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   78 and_expression: and_expression . AMPERSAND equality_expression

    AMPERSAND  deslocar, e ir ao estado 138

    $padrão  reduzir usando a regra 76 (exclusive_or_expression)


State 176

   78 and_expression: and_expression AMPERSAND equality_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   80 equality_expression: equality_expression . OP_EQ relational_expression
   81                    | equality_expression . OP_NE relational_expression

    OP_EQ  deslocar, e ir ao estado 139
    OP_NE  deslocar, e ir ao estado 140

    $padrão  reduzir usando a regra 78 (and_expression)


State 177

   80 equality_expression: equality_expression OP_EQ relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   83 relational_expression: relational_expression . OP_LT shift_expression
   84                      | relational_expression . OP_GT shift_expression
   85                      | relational_expression . OP_LET shift_expression
   86                      | relational_expression . OP_GET shift_expression
   87                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 141
    OP_LT   deslocar, e ir ao estado 142
    OP_GET  deslocar, e ir ao estado 143
    OP_GT   deslocar, e ir ao estado 144
    TYPEOF  deslocar, e ir ao estado 145

    $padrão  reduzir usando a regra 80 (equality_expression)


State 178

   81 equality_expression: equality_expression OP_NE relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   83 relational_expression: relational_expression . OP_LT shift_expression
   84                      | relational_expression . OP_GT shift_expression
   85                      | relational_expression . OP_LET shift_expression
   86                      | relational_expression . OP_GET shift_expression
   87                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 141
    OP_LT   deslocar, e ir ao estado 142
    OP_GET  deslocar, e ir ao estado 143
    OP_GT   deslocar, e ir ao estado 144
    TYPEOF  deslocar, e ir ao estado 145

    $padrão  reduzir usando a regra 81 (equality_expression)


State 179

   85 relational_expression: relational_expression OP_LET shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   89 shift_expression: shift_expression . L_SHIFT additive_expression
   90                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 146
    R_SHIFT  deslocar, e ir ao estado 147

    $padrão  reduzir usando a regra 85 (relational_expression)


State 180

   83 relational_expression: relational_expression OP_LT shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   89 shift_expression: shift_expression . L_SHIFT additive_expression
   90                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 146
    R_SHIFT  deslocar, e ir ao estado 147

    $padrão  reduzir usando a regra 83 (relational_expression)


State 181

   86 relational_expression: relational_expression OP_GET shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   89 shift_expression: shift_expression . L_SHIFT additive_expression
   90                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 146
    R_SHIFT  deslocar, e ir ao estado 147

    $padrão  reduzir usando a regra 86 (relational_expression)


State 182

   84 relational_expression: relational_expression OP_GT shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   89 shift_expression: shift_expression . L_SHIFT additive_expression
   90                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 146
    R_SHIFT  deslocar, e ir ao estado 147

    $padrão  reduzir usando a regra 84 (relational_expression)


State 183

   87 relational_expression: relational_expression TYPEOF type_specifier .

    $padrão  reduzir usando a regra 87 (relational_expression)


State 184

   89 shift_expression: shift_expression L_SHIFT additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
   92 additive_expression: additive_expression . OP_PLUS multiplicative_expression
   93                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 148
    OP_MINUS  deslocar, e ir ao estado 149

    $padrão  reduzir usando a regra 89 (shift_expression)


State 185

   90 shift_expression: shift_expression R_SHIFT additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
   92 additive_expression: additive_expression . OP_PLUS multiplicative_expression
   93                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 148
    OP_MINUS  deslocar, e ir ao estado 149

    $padrão  reduzir usando a regra 90 (shift_expression)


State 186

   92 additive_expression: additive_expression OP_PLUS multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
   95 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
   96                          | multiplicative_expression . OP_DIV cast_expression
   97                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 150
    OP_DIV       deslocar, e ir ao estado 151
    OP_MOD       deslocar, e ir ao estado 152

    $padrão  reduzir usando a regra 92 (additive_expression)


State 187

   93 additive_expression: additive_expression OP_MINUS multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
   95 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
   96                          | multiplicative_expression . OP_DIV cast_expression
   97                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 150
    OP_DIV       deslocar, e ir ao estado 151
    OP_MOD       deslocar, e ir ao estado 152

    $padrão  reduzir usando a regra 93 (additive_expression)


State 188

   95 multiplicative_expression: multiplicative_expression OP_ASTERISK cast_expression .

    $padrão  reduzir usando a regra 95 (multiplicative_expression)


State 189

   96 multiplicative_expression: multiplicative_expression OP_DIV cast_expression .

    $padrão  reduzir usando a regra 96 (multiplicative_expression)


State 190

   97 multiplicative_expression: multiplicative_expression OP_MOD cast_expression .

    $padrão  reduzir usando a regra 97 (multiplicative_expression)


State 191

  130 field_access: not_just_name DOT IDENTIFIER .

    $padrão  reduzir usando a regra 130 (field_access)


State 192

  129 array_access: complex_primary L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 204


State 193

  133 subprogram_call: subprogram_access L_PAREN R_PAREN .

    $padrão  reduzir usando a regra 133 (subprogram_call)


State 194

  136 argument_list: expression .

    $padrão  reduzir usando a regra 136 (argument_list)


State 195

  132 subprogram_call: subprogram_access L_PAREN argument_list . R_PAREN
  137 argument_list: argument_list . COMMA expression

    COMMA    deslocar, e ir ao estado 205
    R_PAREN  deslocar, e ir ao estado 206


State 196

  138 dims: L_SQ_PAREN R_SQ_PAREN .

    $padrão  reduzir usando a regra 138 (dims)


State 197

  139 dims: dims L_SQ_PAREN . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 207


State 198

  101 cast_expression: L_PAREN expression R_PAREN logical_unary_expression .

    $padrão  reduzir usando a regra 101 (cast_expression)


State 199

   99 cast_expression: L_PAREN primitive_type_expression R_PAREN cast_expression .

    $padrão  reduzir usando a regra 99 (cast_expression)


State 200

  100 cast_expression: L_PAREN user_type_expression R_PAREN cast_expression .

    $padrão  reduzir usando a regra 100 (cast_expression)


State 201

   51 array_initializers: array_initializers COMMA variable_initializer .

    $padrão  reduzir usando a regra 51 (array_initializers)


State 202

  128 array_access: qualified_name L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 128 (array_access)


State 203

  117 complex_primary: L_PAREN expression R_PAREN .

    $padrão  reduzir usando a regra 117 (complex_primary)


State 204

  129 array_access: complex_primary L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 129 (array_access)


State 205

   39 qualified_name: . IDENTIFIER
   53 expression: . assignment_expression
   54 assignment_expression: . conditional_or_expression
   55                      | . unary_expression assignment_operator assignment_expression
   56 unary_expression: . arithmetic_unary_operator cast_expression
   57                 | . logical_unary_expression
   58 logical_unary_expression: . postfix_expression
   59                         | . logical_unary_operator unary_expression
   60 postfix_expression: . primary_expression
   61 primary_expression: . qualified_name
   62                   | . not_just_name
   63 arithmetic_unary_operator: . OP_PLUS
   64                          | . OP_MINUS
   65 logical_unary_operator: . BITWISE_COMPLEMENT
   66                       | . LOG_NOT
   67 conditional_or_expression: . conditional_and_expression
   68                          | . conditional_or_expression LOG_OR conditional_and_expression
   69                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   70 conditional_and_expression: . inclusive_or_expression
   71                           | . conditional_and_expression LOG_AND inclusive_or_expression
   72                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   73 inclusive_or_expression: . exclusive_or_expression
   74                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   75 exclusive_or_expression: . and_expression
   76                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   77 and_expression: . equality_expression
   78               | . and_expression AMPERSAND equality_expression
   79 equality_expression: . relational_expression
   80                    | . equality_expression OP_EQ relational_expression
   81                    | . equality_expression OP_NE relational_expression
   82 relational_expression: . shift_expression
   83                      | . relational_expression OP_LT shift_expression
   84                      | . relational_expression OP_GT shift_expression
   85                      | . relational_expression OP_LET shift_expression
   86                      | . relational_expression OP_GET shift_expression
   87                      | . relational_expression TYPEOF type_specifier
   88 shift_expression: . additive_expression
   89                 | . shift_expression L_SHIFT additive_expression
   90                 | . shift_expression R_SHIFT additive_expression
   91 additive_expression: . multiplicative_expression
   92                    | . additive_expression OP_PLUS multiplicative_expression
   93                    | . additive_expression OP_MINUS multiplicative_expression
   94 multiplicative_expression: . cast_expression
   95                          | . multiplicative_expression OP_ASTERISK cast_expression
   96                          | . multiplicative_expression OP_DIV cast_expression
   97                          | . multiplicative_expression OP_MOD cast_expression
   98 cast_expression: . unary_expression
   99                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  100                | . L_PAREN user_type_expression R_PAREN cast_expression
  101                | . L_PAREN expression R_PAREN logical_unary_expression
  116 not_just_name: . complex_primary
  117 complex_primary: . L_PAREN expression R_PAREN
  118                | . complex_primary_no_parenthesis
  119 complex_primary_no_parenthesis: . BOOL_LITERAL
  120                               | . OCTAL
  121                               | . DECIMAL
  122                               | . HEX
  123                               | . FLOATING_POINT
  124                               | . STRING_LITERAL
  125                               | . array_access
  126                               | . field_access
  127                               | . subprogram_call
  128 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  129             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  130 field_access: . not_just_name DOT IDENTIFIER
  131             | . postfix_expression DOT IDENTIFIER
  132 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  133                | . subprogram_access L_PAREN R_PAREN
  134 subprogram_access: . complex_primary_no_parenthesis
  135                  | . qualified_name
  137 argument_list: argument_list COMMA . expression

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 62
    DECIMAL             deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    OCTAL               deslocar, e ir ao estado 65
    FLOATING_POINT      deslocar, e ir ao estado 66
    BOOL_LITERAL        deslocar, e ir ao estado 67
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 68
    L_PAREN             deslocar, e ir ao estado 69
    LOG_NOT             deslocar, e ir ao estado 71
    OP_PLUS             deslocar, e ir ao estado 72
    OP_MINUS            deslocar, e ir ao estado 73

    qualified_name                  ir ao estado 74
    expression                      ir ao estado 208
    assignment_expression           ir ao estado 77
    unary_expression                ir ao estado 78
    logical_unary_expression        ir ao estado 79
    postfix_expression              ir ao estado 80
    primary_expression              ir ao estado 81
    arithmetic_unary_operator       ir ao estado 82
    logical_unary_operator          ir ao estado 83
    conditional_or_expression       ir ao estado 84
    conditional_and_expression      ir ao estado 85
    inclusive_or_expression         ir ao estado 86
    exclusive_or_expression         ir ao estado 87
    and_expression                  ir ao estado 88
    equality_expression             ir ao estado 89
    relational_expression           ir ao estado 90
    shift_expression                ir ao estado 91
    additive_expression             ir ao estado 92
    multiplicative_expression       ir ao estado 93
    cast_expression                 ir ao estado 94
    not_just_name                   ir ao estado 95
    complex_primary                 ir ao estado 96
    complex_primary_no_parenthesis  ir ao estado 97
    array_access                    ir ao estado 98
    field_access                    ir ao estado 99
    subprogram_call                 ir ao estado 100
    subprogram_access               ir ao estado 101


State 206

  132 subprogram_call: subprogram_access L_PAREN argument_list R_PAREN .

    $padrão  reduzir usando a regra 132 (subprogram_call)


State 207

  139 dims: dims L_SQ_PAREN R_SQ_PAREN .

    $padrão  reduzir usando a regra 139 (dims)


State 208

  137 argument_list: argument_list COMMA expression .

    $padrão  reduzir usando a regra 137 (argument_list)
