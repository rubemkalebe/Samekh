Terminais não utilizados na gramática

   CHAR_LITERAL
   BYTE
   CASE
   DO
   ELSE
   END_CASE
   END_FOR
   END_IF
   END_WHILE
   OP_PTR
   PRINT
   PRINTLN
   READ
   SIZEOF
   WHEN
   WHILE


Estado 99 conflitos: 1 de deslocamento/redução


Gramática

    0 $accept: translation_unit $end

    1 translation_unit: program_file

    2 program_file: declarations

    3 declarations: declaration
    4             | declarations declaration

    5 declaration: function_declaration
    6            | procedure_declaration
    7            | type_declaration
    8            | variable_declaration

    9 function_declaration: FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION

   10 procedure_declaration: PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE

   11 subprogram_declarator: IDENTIFIER L_PAREN parameter_list R_PAREN
   12                      | IDENTIFIER L_PAREN R_PAREN

   13 parameter_list: parameter
   14               | parameter_list COMMA parameter

   15 parameter: type_specifier declarator_name
   16          | CONST type_specifier declarator_name

   17 subprogram_body: block
   18                | SEMICOLON

   19 block: local_variable_declarations_and_statements

   20 local_variable_declarations_and_statements: local_variable_declarations_or_statements
   21                                           | local_variable_declarations_and_statements local_variable_declarations_or_statements

   22 local_variable_declarations_or_statements: local_variable_declaration_statement
   23                                          | statement

   24 local_variable_declaration_statement: type_specifier variable_declarators SEMICOLON
   25                                     | STATIC type_specifier variable_declarators SEMICOLON

   26 statement: assignment_expression SEMICOLON
   27          | selection_statement
   28          | iteration_statement
   29          | jump_statement

   30 selection_statement: IF

   31 iteration_statement: FOR

   32 jump_statement: BREAK IDENTIFIER SEMICOLON
   33               | BREAK SEMICOLON
   34               | CONTINUE IDENTIFIER SEMICOLON
   35               | CONTINUE SEMICOLON
   36               | RETURN expression SEMICOLON
   37               | RETURN SEMICOLON

   38 type_declaration: STRUCT IDENTIFIER variable_declarations END_STRUCT
   39                 | UNION IDENTIFIER discriminant union_body END_UNION
   40                 | ENUM IDENTIFIER enumerator_list END_ENUM

   41 variable_declarations: variable_declaration
   42                      | variable_declarations variable_declaration

   43 variable_declaration: modifiers type_specifier variable_declarators SEMICOLON
   44                     | type_specifier variable_declarators SEMICOLON

   45 modifiers: modifier
   46          | modifiers modifier

   47 modifier: CONST
   48         | STATIC

   49 type_specifier: type_name

   50 type_name: primitive_type
   51          | qualified_name

   52 primitive_type: AUTO
   53               | BOOL
   54               | CHAR
   55               | DOUBLE
   56               | FLOAT
   57               | INT
   58               | LONG
   59               | SHORT
   60               | STRING

   61 discriminant: %empty

   62 enumerator_list: enumerator
   63                | enumerator_list COMMA enumerator

   64 enumerator: IDENTIFIER ASSIGN expression
   65           | IDENTIFIER

   66 qualified_name: IDENTIFIER

   67 union_body: %empty

   68 variable_declarators: variable_declarator
   69                     | variable_declarators COMMA variable_declarator

   70 variable_declarator: declarator_name
   71                    | declarator_name ASSIGN variable_initializer

   72 declarator_name: IDENTIFIER
   73                | declarator_name L_SQ_PAREN expression R_SQ_PAREN

   74 variable_initializer: expression
   75                     | L_BRACE R_BRACE
   76                     | L_BRACE array_initializers R_BRACE

   77 array_initializers: variable_initializer
   78                   | array_initializers COMMA variable_initializer
   79                   | array_initializers COMMA

   80 expression: assignment_expression

   81 assignment_expression: conditional_or_expression
   82                      | unary_expression assignment_operator assignment_expression

   83 unary_expression: arithmetic_unary_operator cast_expression
   84                 | logical_unary_expression

   85 logical_unary_expression: postfix_expression
   86                         | logical_unary_operator unary_expression

   87 postfix_expression: primary_expression

   88 primary_expression: qualified_name
   89                   | not_just_name

   90 arithmetic_unary_operator: OP_PLUS
   91                          | OP_MINUS

   92 logical_unary_operator: BITWISE_COMPLEMENT
   93                       | LOG_NOT

   94 conditional_or_expression: conditional_and_expression
   95                          | conditional_or_expression LOG_OR conditional_and_expression
   96                          | conditional_or_expression LOG_SC_OR conditional_and_expression

   97 conditional_and_expression: inclusive_or_expression
   98                           | conditional_and_expression LOG_AND inclusive_or_expression
   99                           | conditional_and_expression LOG_SC_AND inclusive_or_expression

  100 inclusive_or_expression: exclusive_or_expression
  101                        | inclusive_or_expression BITWISE_OR exclusive_or_expression

  102 exclusive_or_expression: and_expression
  103                        | exclusive_or_expression BITWISE_OR_EXC and_expression

  104 and_expression: equality_expression
  105               | and_expression AMPERSAND equality_expression

  106 equality_expression: relational_expression
  107                    | equality_expression OP_EQ relational_expression
  108                    | equality_expression OP_NE relational_expression

  109 relational_expression: shift_expression
  110                      | relational_expression OP_LT shift_expression
  111                      | relational_expression OP_GT shift_expression
  112                      | relational_expression OP_LET shift_expression
  113                      | relational_expression OP_GET shift_expression
  114                      | relational_expression TYPEOF type_specifier

  115 shift_expression: additive_expression
  116                 | shift_expression L_SHIFT additive_expression
  117                 | shift_expression R_SHIFT additive_expression

  118 additive_expression: multiplicative_expression
  119                    | additive_expression OP_PLUS multiplicative_expression
  120                    | additive_expression OP_MINUS multiplicative_expression

  121 multiplicative_expression: cast_expression
  122                          | multiplicative_expression OP_ASTERISK cast_expression
  123                          | multiplicative_expression OP_DIV cast_expression
  124                          | multiplicative_expression OP_MOD cast_expression

  125 cast_expression: unary_expression
  126                | L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | L_PAREN user_type_expression R_PAREN cast_expression
  128                | L_PAREN expression R_PAREN logical_unary_expression

  129 primitive_type_expression: primitive_type
  130                          | primitive_type dims

  131 user_type_expression: qualified_name dims

  132 assignment_operator: ASSIGN
  133                    | ASSIGN_PLUS
  134                    | ASSIGN_MINUS
  135                    | ASSIGN_PRODUCT
  136                    | ASSIGN_DIV
  137                    | ASSIGN_MOD
  138                    | ASSIGN_BITWISE_AND
  139                    | ASSIGN_BITWISE_OR
  140                    | ASSIGN_BITWISE_OR_EXC
  141                    | ASSIGN_L_SHIFT
  142                    | ASSIGN_R_SHIFT

  143 not_just_name: complex_primary

  144 complex_primary: L_PAREN expression R_PAREN
  145                | complex_primary_no_parenthesis

  146 complex_primary_no_parenthesis: BOOL_LITERAL
  147                               | OCTAL
  148                               | DECIMAL
  149                               | HEX
  150                               | FLOATING_POINT
  151                               | STRING_LITERAL
  152                               | NNULL
  153                               | array_access
  154                               | field_access
  155                               | subprogram_call

  156 array_access: qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | complex_primary L_SQ_PAREN expression R_SQ_PAREN

  158 field_access: not_just_name DOT IDENTIFIER
  159             | postfix_expression DOT IDENTIFIER

  160 subprogram_call: subprogram_access L_PAREN argument_list R_PAREN
  161                | subprogram_access L_PAREN R_PAREN

  162 subprogram_access: complex_primary_no_parenthesis
  163                  | qualified_name

  164 argument_list: expression
  165              | argument_list COMMA expression

  166 dims: L_SQ_PAREN R_SQ_PAREN
  167     | dims L_SQ_PAREN R_SQ_PAREN


Terminais, com as regras onde eles aparecem

$end (0) 0
error (256)
IDENTIFIER (258) 11 12 32 34 38 39 40 64 65 66 72 158 159
STRING_LITERAL (259) 151
DECIMAL (260) 148
HEX (261) 149
OCTAL (262) 147
FLOATING_POINT (263) 150
BOOL_LITERAL (264) 146
CHAR_LITERAL (265)
ASSIGN (266) 64 71 132
ASSIGN_PLUS (267) 133
ASSIGN_MINUS (268) 134
ASSIGN_PRODUCT (269) 135
ASSIGN_DIV (270) 136
ASSIGN_MOD (271) 137
ASSIGN_BITWISE_AND (272) 138
ASSIGN_BITWISE_OR (273) 139
ASSIGN_BITWISE_OR_EXC (274) 140
ASSIGN_L_SHIFT (275) 141
ASSIGN_R_SHIFT (276) 142
AMPERSAND (277) 105
AUTO (278) 52
BOOL (279) 53
BREAK (280) 32 33
BYTE (281)
BITWISE_COMPLEMENT (282) 92
BITWISE_OR (283) 101
BITWISE_OR_EXC (284) 103
CASE (285)
CHAR (286) 54
COMMA (287) 14 63 69 78 79 165
CONTINUE (288) 34 35
CONST (289) 16 47
DO (290)
DOT (291) 158 159
DOUBLE (292) 55
ENUM (293) 40
ELSE (294)
END_CASE (295)
END_ENUM (296) 40
END_FOR (297)
END_FUNCTION (298) 9
END_IF (299)
END_PROCEDURE (300) 10
END_STRUCT (301) 38
END_UNION (302) 39
END_WHILE (303)
FLOAT (304) 56
FOR (305) 31
FUNCTION (306) 9
IF (307) 30
INT (308) 57
L_PAREN (309) 11 12 126 127 128 144 160 161
L_SQ_PAREN (310) 73 156 157 166 167
L_BRACE (311) 75 76
L_SHIFT (312) 116
LOG_NOT (313) 93
LOG_AND (314) 98
LOG_OR (315) 95
LOG_SC_AND (316) 99
LOG_SC_OR (317) 96
LONG (318) 58
NNULL (319) 152
OP_EQ (320) 107
OP_NE (321) 108
OP_PTR (322)
OP_PLUS (323) 90 119
OP_MINUS (324) 91 120
OP_ASTERISK (325) 122
OP_DIV (326) 123
OP_MOD (327) 124
OP_LET (328) 112
OP_LT (329) 110
OP_GET (330) 113
OP_GT (331) 111
PRINT (332)
PRINTLN (333)
PROCEDURE (334) 10
READ (335)
RETURN (336) 36 37
R_PAREN (337) 11 12 126 127 128 144 160 161
R_SQ_PAREN (338) 73 156 157 166 167
R_BRACE (339) 75 76
R_SHIFT (340) 117
SHORT (341) 59
STRING (342) 60
STRUCT (343) 38
STATIC (344) 25 48
SIZEOF (345)
SEMICOLON (346) 18 24 25 26 32 33 34 35 36 37 43 44
TYPEOF (347) 114
UNION (348) 39
WHEN (349)
WHILE (350)


Não-terminais com as regras onde eles aparecem

$accept (96)
    à esquerda: 0
translation_unit (97)
    à esquerda: 1, à direita: 0
program_file (98)
    à esquerda: 2, à direita: 1
declarations (99)
    à esquerda: 3 4, à direita: 2 4
declaration (100)
    à esquerda: 5 6 7 8, à direita: 3 4
function_declaration (101)
    à esquerda: 9, à direita: 5
procedure_declaration (102)
    à esquerda: 10, à direita: 6
subprogram_declarator (103)
    à esquerda: 11 12, à direita: 9 10
parameter_list (104)
    à esquerda: 13 14, à direita: 11 14
parameter (105)
    à esquerda: 15 16, à direita: 13 14
subprogram_body (106)
    à esquerda: 17 18, à direita: 9 10
block (107)
    à esquerda: 19, à direita: 17
local_variable_declarations_and_statements (108)
    à esquerda: 20 21, à direita: 19 21
local_variable_declarations_or_statements (109)
    à esquerda: 22 23, à direita: 20 21
local_variable_declaration_statement (110)
    à esquerda: 24 25, à direita: 22
statement (111)
    à esquerda: 26 27 28 29, à direita: 23
selection_statement (112)
    à esquerda: 30, à direita: 27
iteration_statement (113)
    à esquerda: 31, à direita: 28
jump_statement (114)
    à esquerda: 32 33 34 35 36 37, à direita: 29
type_declaration (115)
    à esquerda: 38 39 40, à direita: 7
variable_declarations (116)
    à esquerda: 41 42, à direita: 38 42
variable_declaration (117)
    à esquerda: 43 44, à direita: 8 41 42
modifiers (118)
    à esquerda: 45 46, à direita: 43 46
modifier (119)
    à esquerda: 47 48, à direita: 45 46
type_specifier (120)
    à esquerda: 49, à direita: 9 15 16 24 25 43 44 114
type_name (121)
    à esquerda: 50 51, à direita: 49
primitive_type (122)
    à esquerda: 52 53 54 55 56 57 58 59 60, à direita: 50 129 130
discriminant (123)
    à esquerda: 61, à direita: 39
enumerator_list (124)
    à esquerda: 62 63, à direita: 40 63
enumerator (125)
    à esquerda: 64 65, à direita: 62 63
qualified_name (126)
    à esquerda: 66, à direita: 51 88 131 156 163
union_body (127)
    à esquerda: 67, à direita: 39
variable_declarators (128)
    à esquerda: 68 69, à direita: 24 25 43 44 69
variable_declarator (129)
    à esquerda: 70 71, à direita: 68 69
declarator_name (130)
    à esquerda: 72 73, à direita: 15 16 70 71 73
variable_initializer (131)
    à esquerda: 74 75 76, à direita: 71 77 78
array_initializers (132)
    à esquerda: 77 78 79, à direita: 76 78 79
expression (133)
    à esquerda: 80, à direita: 36 64 73 74 128 144 156 157 164 165
assignment_expression (134)
    à esquerda: 81 82, à direita: 26 80 82
unary_expression (135)
    à esquerda: 83 84, à direita: 82 86 125
logical_unary_expression (136)
    à esquerda: 85 86, à direita: 84 128
postfix_expression (137)
    à esquerda: 87, à direita: 85 159
primary_expression (138)
    à esquerda: 88 89, à direita: 87
arithmetic_unary_operator (139)
    à esquerda: 90 91, à direita: 83
logical_unary_operator (140)
    à esquerda: 92 93, à direita: 86
conditional_or_expression (141)
    à esquerda: 94 95 96, à direita: 81 95 96
conditional_and_expression (142)
    à esquerda: 97 98 99, à direita: 94 95 96 98 99
inclusive_or_expression (143)
    à esquerda: 100 101, à direita: 97 98 99 101
exclusive_or_expression (144)
    à esquerda: 102 103, à direita: 100 101 103
and_expression (145)
    à esquerda: 104 105, à direita: 102 103 105
equality_expression (146)
    à esquerda: 106 107 108, à direita: 104 105 107 108
relational_expression (147)
    à esquerda: 109 110 111 112 113 114, à direita: 106 107 108 110
    111 112 113 114
shift_expression (148)
    à esquerda: 115 116 117, à direita: 109 110 111 112 113 116 117
additive_expression (149)
    à esquerda: 118 119 120, à direita: 115 116 117 119 120
multiplicative_expression (150)
    à esquerda: 121 122 123 124, à direita: 118 119 120 122 123 124
cast_expression (151)
    à esquerda: 125 126 127 128, à direita: 83 121 122 123 124 126
    127
primitive_type_expression (152)
    à esquerda: 129 130, à direita: 126
user_type_expression (153)
    à esquerda: 131, à direita: 127
assignment_operator (154)
    à esquerda: 132 133 134 135 136 137 138 139 140 141 142, à direita:
    82
not_just_name (155)
    à esquerda: 143, à direita: 89 158
complex_primary (156)
    à esquerda: 144 145, à direita: 143 157
complex_primary_no_parenthesis (157)
    à esquerda: 146 147 148 149 150 151 152 153 154 155, à direita:
    145 162
array_access (158)
    à esquerda: 156 157, à direita: 153
field_access (159)
    à esquerda: 158 159, à direita: 154
subprogram_call (160)
    à esquerda: 160 161, à direita: 155
subprogram_access (161)
    à esquerda: 162 163, à direita: 160 161
argument_list (162)
    à esquerda: 164 165, à direita: 160 165
dims (163)
    à esquerda: 166 167, à direita: 130 131 167


State 0

    0 $accept: . translation_unit $end
    1 translation_unit: . program_file
    2 program_file: . declarations
    3 declarations: . declaration
    4             | . declarations declaration
    5 declaration: . function_declaration
    6            | . procedure_declaration
    7            | . type_declaration
    8            | . variable_declaration
    9 function_declaration: . FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION
   10 procedure_declaration: . PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE
   38 type_declaration: . STRUCT IDENTIFIER variable_declarations END_STRUCT
   39                 | . UNION IDENTIFIER discriminant union_body END_UNION
   40                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   43 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   44                     | . type_specifier variable_declarators SEMICOLON
   45 modifiers: . modifier
   46          | . modifiers modifier
   47 modifier: . CONST
   48         | . STATIC
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    ENUM        deslocar, e ir ao estado 7
    FLOAT       deslocar, e ir ao estado 8
    FUNCTION    deslocar, e ir ao estado 9
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    PROCEDURE   deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STRUCT      deslocar, e ir ao estado 15
    STATIC      deslocar, e ir ao estado 16
    UNION       deslocar, e ir ao estado 17

    translation_unit       ir ao estado 18
    program_file           ir ao estado 19
    declarations           ir ao estado 20
    declaration            ir ao estado 21
    function_declaration   ir ao estado 22
    procedure_declaration  ir ao estado 23
    type_declaration       ir ao estado 24
    variable_declaration   ir ao estado 25
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31


State 1

   66 qualified_name: IDENTIFIER .

    $padrão  reduzir usando a regra 66 (qualified_name)


State 2

   52 primitive_type: AUTO .

    $padrão  reduzir usando a regra 52 (primitive_type)


State 3

   53 primitive_type: BOOL .

    $padrão  reduzir usando a regra 53 (primitive_type)


State 4

   54 primitive_type: CHAR .

    $padrão  reduzir usando a regra 54 (primitive_type)


State 5

   47 modifier: CONST .

    $padrão  reduzir usando a regra 47 (modifier)


State 6

   55 primitive_type: DOUBLE .

    $padrão  reduzir usando a regra 55 (primitive_type)


State 7

   40 type_declaration: ENUM . IDENTIFIER enumerator_list END_ENUM

    IDENTIFIER  deslocar, e ir ao estado 32


State 8

   56 primitive_type: FLOAT .

    $padrão  reduzir usando a regra 56 (primitive_type)


State 9

    9 function_declaration: FUNCTION . type_specifier subprogram_declarator subprogram_body END_FUNCTION
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 33
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 10

   57 primitive_type: INT .

    $padrão  reduzir usando a regra 57 (primitive_type)


State 11

   58 primitive_type: LONG .

    $padrão  reduzir usando a regra 58 (primitive_type)


State 12

   10 procedure_declaration: PROCEDURE . subprogram_declarator subprogram_body END_PROCEDURE
   11 subprogram_declarator: . IDENTIFIER L_PAREN parameter_list R_PAREN
   12                      | . IDENTIFIER L_PAREN R_PAREN

    IDENTIFIER  deslocar, e ir ao estado 34

    subprogram_declarator  ir ao estado 35


State 13

   59 primitive_type: SHORT .

    $padrão  reduzir usando a regra 59 (primitive_type)


State 14

   60 primitive_type: STRING .

    $padrão  reduzir usando a regra 60 (primitive_type)


State 15

   38 type_declaration: STRUCT . IDENTIFIER variable_declarations END_STRUCT

    IDENTIFIER  deslocar, e ir ao estado 36


State 16

   48 modifier: STATIC .

    $padrão  reduzir usando a regra 48 (modifier)


State 17

   39 type_declaration: UNION . IDENTIFIER discriminant union_body END_UNION

    IDENTIFIER  deslocar, e ir ao estado 37


State 18

    0 $accept: translation_unit . $end

    $end  deslocar, e ir ao estado 38


State 19

    1 translation_unit: program_file .

    $padrão  reduzir usando a regra 1 (translation_unit)


State 20

    2 program_file: declarations .  [$end]
    4 declarations: declarations . declaration
    5 declaration: . function_declaration
    6            | . procedure_declaration
    7            | . type_declaration
    8            | . variable_declaration
    9 function_declaration: . FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION
   10 procedure_declaration: . PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE
   38 type_declaration: . STRUCT IDENTIFIER variable_declarations END_STRUCT
   39                 | . UNION IDENTIFIER discriminant union_body END_UNION
   40                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   43 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   44                     | . type_specifier variable_declarators SEMICOLON
   45 modifiers: . modifier
   46          | . modifiers modifier
   47 modifier: . CONST
   48         | . STATIC
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    ENUM        deslocar, e ir ao estado 7
    FLOAT       deslocar, e ir ao estado 8
    FUNCTION    deslocar, e ir ao estado 9
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    PROCEDURE   deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STRUCT      deslocar, e ir ao estado 15
    STATIC      deslocar, e ir ao estado 16
    UNION       deslocar, e ir ao estado 17

    $padrão  reduzir usando a regra 2 (program_file)

    declaration            ir ao estado 39
    function_declaration   ir ao estado 22
    procedure_declaration  ir ao estado 23
    type_declaration       ir ao estado 24
    variable_declaration   ir ao estado 25
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31


State 21

    3 declarations: declaration .

    $padrão  reduzir usando a regra 3 (declarations)


State 22

    5 declaration: function_declaration .

    $padrão  reduzir usando a regra 5 (declaration)


State 23

    6 declaration: procedure_declaration .

    $padrão  reduzir usando a regra 6 (declaration)


State 24

    7 declaration: type_declaration .

    $padrão  reduzir usando a regra 7 (declaration)


State 25

    8 declaration: variable_declaration .

    $padrão  reduzir usando a regra 8 (declaration)


State 26

   43 variable_declaration: modifiers . type_specifier variable_declarators SEMICOLON
   46 modifiers: modifiers . modifier
   47 modifier: . CONST
   48         | . STATIC
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    modifier        ir ao estado 40
    type_specifier  ir ao estado 41
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 27

   45 modifiers: modifier .

    $padrão  reduzir usando a regra 45 (modifiers)


State 28

   44 variable_declaration: type_specifier . variable_declarators SEMICOLON
   68 variable_declarators: . variable_declarator
   69                     | . variable_declarators COMMA variable_declarator
   70 variable_declarator: . declarator_name
   71                    | . declarator_name ASSIGN variable_initializer
   72 declarator_name: . IDENTIFIER
   73                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    variable_declarators  ir ao estado 43
    variable_declarator   ir ao estado 44
    declarator_name       ir ao estado 45


State 29

   49 type_specifier: type_name .

    $padrão  reduzir usando a regra 49 (type_specifier)


State 30

   50 type_name: primitive_type .

    $padrão  reduzir usando a regra 50 (type_name)


State 31

   51 type_name: qualified_name .

    $padrão  reduzir usando a regra 51 (type_name)


State 32

   40 type_declaration: ENUM IDENTIFIER . enumerator_list END_ENUM
   62 enumerator_list: . enumerator
   63                | . enumerator_list COMMA enumerator
   64 enumerator: . IDENTIFIER ASSIGN expression
   65           | . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 46

    enumerator_list  ir ao estado 47
    enumerator       ir ao estado 48


State 33

    9 function_declaration: FUNCTION type_specifier . subprogram_declarator subprogram_body END_FUNCTION
   11 subprogram_declarator: . IDENTIFIER L_PAREN parameter_list R_PAREN
   12                      | . IDENTIFIER L_PAREN R_PAREN

    IDENTIFIER  deslocar, e ir ao estado 34

    subprogram_declarator  ir ao estado 49


State 34

   11 subprogram_declarator: IDENTIFIER . L_PAREN parameter_list R_PAREN
   12                      | IDENTIFIER . L_PAREN R_PAREN

    L_PAREN  deslocar, e ir ao estado 50


State 35

   10 procedure_declaration: PROCEDURE subprogram_declarator . subprogram_body END_PROCEDURE
   17 subprogram_body: . block
   18                | . SEMICOLON
   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30 selection_statement: . IF
   31 iteration_statement: . FOR
   32 jump_statement: . BREAK IDENTIFIER SEMICOLON
   33               | . BREAK SEMICOLON
   34               | . CONTINUE IDENTIFIER SEMICOLON
   35               | . CONTINUE SEMICOLON
   36               | . RETURN expression SEMICOLON
   37               | . RETURN SEMICOLON
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 59
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 60
    IF                  deslocar, e ir ao estado 61
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66
    RETURN              deslocar, e ir ao estado 67
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 68
    SEMICOLON           deslocar, e ir ao estado 69

    subprogram_body                             ir ao estado 70
    block                                       ir ao estado 71
    local_variable_declarations_and_statements  ir ao estado 72
    local_variable_declarations_or_statements   ir ao estado 73
    local_variable_declaration_statement        ir ao estado 74
    statement                                   ir ao estado 75
    selection_statement                         ir ao estado 76
    iteration_statement                         ir ao estado 77
    jump_statement                              ir ao estado 78
    type_specifier                              ir ao estado 79
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 80
    assignment_expression                       ir ao estado 81
    unary_expression                            ir ao estado 82
    logical_unary_expression                    ir ao estado 83
    postfix_expression                          ir ao estado 84
    primary_expression                          ir ao estado 85
    arithmetic_unary_operator                   ir ao estado 86
    logical_unary_operator                      ir ao estado 87
    conditional_or_expression                   ir ao estado 88
    conditional_and_expression                  ir ao estado 89
    inclusive_or_expression                     ir ao estado 90
    exclusive_or_expression                     ir ao estado 91
    and_expression                              ir ao estado 92
    equality_expression                         ir ao estado 93
    relational_expression                       ir ao estado 94
    shift_expression                            ir ao estado 95
    additive_expression                         ir ao estado 96
    multiplicative_expression                   ir ao estado 97
    cast_expression                             ir ao estado 98
    not_just_name                               ir ao estado 99
    complex_primary                             ir ao estado 100
    complex_primary_no_parenthesis              ir ao estado 101
    array_access                                ir ao estado 102
    field_access                                ir ao estado 103
    subprogram_call                             ir ao estado 104
    subprogram_access                           ir ao estado 105


State 36

   38 type_declaration: STRUCT IDENTIFIER . variable_declarations END_STRUCT
   41 variable_declarations: . variable_declaration
   42                      | . variable_declarations variable_declaration
   43 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   44                     | . type_specifier variable_declarators SEMICOLON
   45 modifiers: . modifier
   46          | . modifiers modifier
   47 modifier: . CONST
   48         | . STATIC
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    variable_declarations  ir ao estado 106
    variable_declaration   ir ao estado 107
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31


State 37

   39 type_declaration: UNION IDENTIFIER . discriminant union_body END_UNION
   61 discriminant: . %empty

    $padrão  reduzir usando a regra 61 (discriminant)

    discriminant  ir ao estado 108


State 38

    0 $accept: translation_unit $end .

    $padrão  aceitar


State 39

    4 declarations: declarations declaration .

    $padrão  reduzir usando a regra 4 (declarations)


State 40

   46 modifiers: modifiers modifier .

    $padrão  reduzir usando a regra 46 (modifiers)


State 41

   43 variable_declaration: modifiers type_specifier . variable_declarators SEMICOLON
   68 variable_declarators: . variable_declarator
   69                     | . variable_declarators COMMA variable_declarator
   70 variable_declarator: . declarator_name
   71                    | . declarator_name ASSIGN variable_initializer
   72 declarator_name: . IDENTIFIER
   73                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    variable_declarators  ir ao estado 109
    variable_declarator   ir ao estado 44
    declarator_name       ir ao estado 45


State 42

   72 declarator_name: IDENTIFIER .

    $padrão  reduzir usando a regra 72 (declarator_name)


State 43

   44 variable_declaration: type_specifier variable_declarators . SEMICOLON
   69 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 110
    SEMICOLON  deslocar, e ir ao estado 111


State 44

   68 variable_declarators: variable_declarator .

    $padrão  reduzir usando a regra 68 (variable_declarators)


State 45

   70 variable_declarator: declarator_name .  [COMMA, SEMICOLON]
   71                    | declarator_name . ASSIGN variable_initializer
   73 declarator_name: declarator_name . L_SQ_PAREN expression R_SQ_PAREN

    ASSIGN      deslocar, e ir ao estado 112
    L_SQ_PAREN  deslocar, e ir ao estado 113

    $padrão  reduzir usando a regra 70 (variable_declarator)


State 46

   64 enumerator: IDENTIFIER . ASSIGN expression
   65           | IDENTIFIER .  [COMMA, END_ENUM]

    ASSIGN  deslocar, e ir ao estado 114

    $padrão  reduzir usando a regra 65 (enumerator)


State 47

   40 type_declaration: ENUM IDENTIFIER enumerator_list . END_ENUM
   63 enumerator_list: enumerator_list . COMMA enumerator

    COMMA     deslocar, e ir ao estado 115
    END_ENUM  deslocar, e ir ao estado 116


State 48

   62 enumerator_list: enumerator .

    $padrão  reduzir usando a regra 62 (enumerator_list)


State 49

    9 function_declaration: FUNCTION type_specifier subprogram_declarator . subprogram_body END_FUNCTION
   17 subprogram_body: . block
   18                | . SEMICOLON
   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30 selection_statement: . IF
   31 iteration_statement: . FOR
   32 jump_statement: . BREAK IDENTIFIER SEMICOLON
   33               | . BREAK SEMICOLON
   34               | . CONTINUE IDENTIFIER SEMICOLON
   35               | . CONTINUE SEMICOLON
   36               | . RETURN expression SEMICOLON
   37               | . RETURN SEMICOLON
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 59
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 60
    IF                  deslocar, e ir ao estado 61
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66
    RETURN              deslocar, e ir ao estado 67
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 68
    SEMICOLON           deslocar, e ir ao estado 69

    subprogram_body                             ir ao estado 117
    block                                       ir ao estado 71
    local_variable_declarations_and_statements  ir ao estado 72
    local_variable_declarations_or_statements   ir ao estado 73
    local_variable_declaration_statement        ir ao estado 74
    statement                                   ir ao estado 75
    selection_statement                         ir ao estado 76
    iteration_statement                         ir ao estado 77
    jump_statement                              ir ao estado 78
    type_specifier                              ir ao estado 79
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 80
    assignment_expression                       ir ao estado 81
    unary_expression                            ir ao estado 82
    logical_unary_expression                    ir ao estado 83
    postfix_expression                          ir ao estado 84
    primary_expression                          ir ao estado 85
    arithmetic_unary_operator                   ir ao estado 86
    logical_unary_operator                      ir ao estado 87
    conditional_or_expression                   ir ao estado 88
    conditional_and_expression                  ir ao estado 89
    inclusive_or_expression                     ir ao estado 90
    exclusive_or_expression                     ir ao estado 91
    and_expression                              ir ao estado 92
    equality_expression                         ir ao estado 93
    relational_expression                       ir ao estado 94
    shift_expression                            ir ao estado 95
    additive_expression                         ir ao estado 96
    multiplicative_expression                   ir ao estado 97
    cast_expression                             ir ao estado 98
    not_just_name                               ir ao estado 99
    complex_primary                             ir ao estado 100
    complex_primary_no_parenthesis              ir ao estado 101
    array_access                                ir ao estado 102
    field_access                                ir ao estado 103
    subprogram_call                             ir ao estado 104
    subprogram_access                           ir ao estado 105


State 50

   11 subprogram_declarator: IDENTIFIER L_PAREN . parameter_list R_PAREN
   12                      | IDENTIFIER L_PAREN . R_PAREN
   13 parameter_list: . parameter
   14               | . parameter_list COMMA parameter
   15 parameter: . type_specifier declarator_name
   16          | . CONST type_specifier declarator_name
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 118
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    R_PAREN     deslocar, e ir ao estado 119
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    parameter_list  ir ao estado 120
    parameter       ir ao estado 121
    type_specifier  ir ao estado 122
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 51

  151 complex_primary_no_parenthesis: STRING_LITERAL .

    $padrão  reduzir usando a regra 151 (complex_primary_no_parenthesis)


State 52

  148 complex_primary_no_parenthesis: DECIMAL .

    $padrão  reduzir usando a regra 148 (complex_primary_no_parenthesis)


State 53

  149 complex_primary_no_parenthesis: HEX .

    $padrão  reduzir usando a regra 149 (complex_primary_no_parenthesis)


State 54

  147 complex_primary_no_parenthesis: OCTAL .

    $padrão  reduzir usando a regra 147 (complex_primary_no_parenthesis)


State 55

  150 complex_primary_no_parenthesis: FLOATING_POINT .

    $padrão  reduzir usando a regra 150 (complex_primary_no_parenthesis)


State 56

  146 complex_primary_no_parenthesis: BOOL_LITERAL .

    $padrão  reduzir usando a regra 146 (complex_primary_no_parenthesis)


State 57

   32 jump_statement: BREAK . IDENTIFIER SEMICOLON
   33               | BREAK . SEMICOLON

    IDENTIFIER  deslocar, e ir ao estado 123
    SEMICOLON   deslocar, e ir ao estado 124


State 58

   92 logical_unary_operator: BITWISE_COMPLEMENT .

    $padrão  reduzir usando a regra 92 (logical_unary_operator)


State 59

   34 jump_statement: CONTINUE . IDENTIFIER SEMICOLON
   35               | CONTINUE . SEMICOLON

    IDENTIFIER  deslocar, e ir ao estado 125
    SEMICOLON   deslocar, e ir ao estado 126


State 60

   31 iteration_statement: FOR .

    $padrão  reduzir usando a regra 31 (iteration_statement)


State 61

   30 selection_statement: IF .

    $padrão  reduzir usando a regra 30 (selection_statement)


State 62

   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  126                | L_PAREN . primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  127                | L_PAREN . user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  128                | L_PAREN . expression R_PAREN logical_unary_expression
  129 primitive_type_expression: . primitive_type
  130                          | . primitive_type dims
  131 user_type_expression: . qualified_name dims
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  144                | L_PAREN . expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    CHAR                deslocar, e ir ao estado 4
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14

    primitive_type                  ir ao estado 127
    qualified_name                  ir ao estado 128
    expression                      ir ao estado 129
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    primitive_type_expression       ir ao estado 131
    user_type_expression            ir ao estado 132
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 63

   93 logical_unary_operator: LOG_NOT .

    $padrão  reduzir usando a regra 93 (logical_unary_operator)


State 64

  152 complex_primary_no_parenthesis: NNULL .

    $padrão  reduzir usando a regra 152 (complex_primary_no_parenthesis)


State 65

   90 arithmetic_unary_operator: OP_PLUS .

    $padrão  reduzir usando a regra 90 (arithmetic_unary_operator)


State 66

   91 arithmetic_unary_operator: OP_MINUS .

    $padrão  reduzir usando a regra 91 (arithmetic_unary_operator)


State 67

   36 jump_statement: RETURN . expression SEMICOLON
   37               | RETURN . SEMICOLON
   66 qualified_name: . IDENTIFIER
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66
    SEMICOLON           deslocar, e ir ao estado 133

    qualified_name                  ir ao estado 134
    expression                      ir ao estado 135
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 68

   25 local_variable_declaration_statement: STATIC . type_specifier variable_declarators SEMICOLON
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 136
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 69

   18 subprogram_body: SEMICOLON .

    $padrão  reduzir usando a regra 18 (subprogram_body)


State 70

   10 procedure_declaration: PROCEDURE subprogram_declarator subprogram_body . END_PROCEDURE

    END_PROCEDURE  deslocar, e ir ao estado 137


State 71

   17 subprogram_body: block .

    $padrão  reduzir usando a regra 17 (subprogram_body)


State 72

   19 block: local_variable_declarations_and_statements .  [END_FUNCTION, END_PROCEDURE]
   21 local_variable_declarations_and_statements: local_variable_declarations_and_statements . local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30 selection_statement: . IF
   31 iteration_statement: . FOR
   32 jump_statement: . BREAK IDENTIFIER SEMICOLON
   33               | . BREAK SEMICOLON
   34               | . CONTINUE IDENTIFIER SEMICOLON
   35               | . CONTINUE SEMICOLON
   36               | . RETURN expression SEMICOLON
   37               | . RETURN SEMICOLON
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 59
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 60
    IF                  deslocar, e ir ao estado 61
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66
    RETURN              deslocar, e ir ao estado 67
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 68

    $padrão  reduzir usando a regra 19 (block)

    local_variable_declarations_or_statements  ir ao estado 138
    local_variable_declaration_statement       ir ao estado 74
    statement                                  ir ao estado 75
    selection_statement                        ir ao estado 76
    iteration_statement                        ir ao estado 77
    jump_statement                             ir ao estado 78
    type_specifier                             ir ao estado 79
    type_name                                  ir ao estado 29
    primitive_type                             ir ao estado 30
    qualified_name                             ir ao estado 80
    assignment_expression                      ir ao estado 81
    unary_expression                           ir ao estado 82
    logical_unary_expression                   ir ao estado 83
    postfix_expression                         ir ao estado 84
    primary_expression                         ir ao estado 85
    arithmetic_unary_operator                  ir ao estado 86
    logical_unary_operator                     ir ao estado 87
    conditional_or_expression                  ir ao estado 88
    conditional_and_expression                 ir ao estado 89
    inclusive_or_expression                    ir ao estado 90
    exclusive_or_expression                    ir ao estado 91
    and_expression                             ir ao estado 92
    equality_expression                        ir ao estado 93
    relational_expression                      ir ao estado 94
    shift_expression                           ir ao estado 95
    additive_expression                        ir ao estado 96
    multiplicative_expression                  ir ao estado 97
    cast_expression                            ir ao estado 98
    not_just_name                              ir ao estado 99
    complex_primary                            ir ao estado 100
    complex_primary_no_parenthesis             ir ao estado 101
    array_access                               ir ao estado 102
    field_access                               ir ao estado 103
    subprogram_call                            ir ao estado 104
    subprogram_access                          ir ao estado 105


State 73

   20 local_variable_declarations_and_statements: local_variable_declarations_or_statements .

    $padrão  reduzir usando a regra 20 (local_variable_declarations_and_statements)


State 74

   22 local_variable_declarations_or_statements: local_variable_declaration_statement .

    $padrão  reduzir usando a regra 22 (local_variable_declarations_or_statements)


State 75

   23 local_variable_declarations_or_statements: statement .

    $padrão  reduzir usando a regra 23 (local_variable_declarations_or_statements)


State 76

   27 statement: selection_statement .

    $padrão  reduzir usando a regra 27 (statement)


State 77

   28 statement: iteration_statement .

    $padrão  reduzir usando a regra 28 (statement)


State 78

   29 statement: jump_statement .

    $padrão  reduzir usando a regra 29 (statement)


State 79

   24 local_variable_declaration_statement: type_specifier . variable_declarators SEMICOLON
   68 variable_declarators: . variable_declarator
   69                     | . variable_declarators COMMA variable_declarator
   70 variable_declarator: . declarator_name
   71                    | . declarator_name ASSIGN variable_initializer
   72 declarator_name: . IDENTIFIER
   73                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    variable_declarators  ir ao estado 139
    variable_declarator   ir ao estado 44
    declarator_name       ir ao estado 45


State 80

   51 type_name: qualified_name .  [IDENTIFIER]
   88 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_SHIFT, SEMICOLON, TYPEOF]
  156 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  163 subprogram_access: qualified_name .  [L_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 140

    IDENTIFIER  reduzir usando a regra 51 (type_name)
    L_PAREN     reduzir usando a regra 163 (subprogram_access)
    $padrão    reduzir usando a regra 88 (primary_expression)


State 81

   26 statement: assignment_expression . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 141


State 82

   82 assignment_expression: unary_expression . assignment_operator assignment_expression
  125 cast_expression: unary_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  132 assignment_operator: . ASSIGN
  133                    | . ASSIGN_PLUS
  134                    | . ASSIGN_MINUS
  135                    | . ASSIGN_PRODUCT
  136                    | . ASSIGN_DIV
  137                    | . ASSIGN_MOD
  138                    | . ASSIGN_BITWISE_AND
  139                    | . ASSIGN_BITWISE_OR
  140                    | . ASSIGN_BITWISE_OR_EXC
  141                    | . ASSIGN_L_SHIFT
  142                    | . ASSIGN_R_SHIFT

    ASSIGN                 deslocar, e ir ao estado 142
    ASSIGN_PLUS            deslocar, e ir ao estado 143
    ASSIGN_MINUS           deslocar, e ir ao estado 144
    ASSIGN_PRODUCT         deslocar, e ir ao estado 145
    ASSIGN_DIV             deslocar, e ir ao estado 146
    ASSIGN_MOD             deslocar, e ir ao estado 147
    ASSIGN_BITWISE_AND     deslocar, e ir ao estado 148
    ASSIGN_BITWISE_OR      deslocar, e ir ao estado 149
    ASSIGN_BITWISE_OR_EXC  deslocar, e ir ao estado 150
    ASSIGN_L_SHIFT         deslocar, e ir ao estado 151
    ASSIGN_R_SHIFT         deslocar, e ir ao estado 152

    $padrão  reduzir usando a regra 125 (cast_expression)

    assignment_operator  ir ao estado 153


State 83

   84 unary_expression: logical_unary_expression .

    $padrão  reduzir usando a regra 84 (unary_expression)


State 84

   85 logical_unary_expression: postfix_expression .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  159 field_access: postfix_expression . DOT IDENTIFIER

    DOT  deslocar, e ir ao estado 154

    $padrão  reduzir usando a regra 85 (logical_unary_expression)


State 85

   87 postfix_expression: primary_expression .

    $padrão  reduzir usando a regra 87 (postfix_expression)


State 86

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   83                 | arithmetic_unary_operator . cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    cast_expression                 ir ao estado 156
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 87

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   86                         | logical_unary_operator . unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 157
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 158
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 88

   81 assignment_expression: conditional_or_expression .  [COMMA, END_ENUM, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   95 conditional_or_expression: conditional_or_expression . LOG_OR conditional_and_expression
   96                          | conditional_or_expression . LOG_SC_OR conditional_and_expression

    LOG_OR     deslocar, e ir ao estado 159
    LOG_SC_OR  deslocar, e ir ao estado 160

    $padrão  reduzir usando a regra 81 (assignment_expression)


State 89

   94 conditional_or_expression: conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   98 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
   99                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 161
    LOG_SC_AND  deslocar, e ir ao estado 162

    $padrão  reduzir usando a regra 94 (conditional_or_expression)


State 90

   97 conditional_and_expression: inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  101 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 163

    $padrão  reduzir usando a regra 97 (conditional_and_expression)


State 91

  100 inclusive_or_expression: exclusive_or_expression .  [BITWISE_OR, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  103 exclusive_or_expression: exclusive_or_expression . BITWISE_OR_EXC and_expression

    BITWISE_OR_EXC  deslocar, e ir ao estado 164

    $padrão  reduzir usando a regra 100 (inclusive_or_expression)


State 92

  102 exclusive_or_expression: and_expression .  [BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  105 and_expression: and_expression . AMPERSAND equality_expression

    AMPERSAND  deslocar, e ir ao estado 165

    $padrão  reduzir usando a regra 102 (exclusive_or_expression)


State 93

  104 and_expression: equality_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  107 equality_expression: equality_expression . OP_EQ relational_expression
  108                    | equality_expression . OP_NE relational_expression

    OP_EQ  deslocar, e ir ao estado 166
    OP_NE  deslocar, e ir ao estado 167

    $padrão  reduzir usando a regra 104 (and_expression)


State 94

  106 equality_expression: relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  110 relational_expression: relational_expression . OP_LT shift_expression
  111                      | relational_expression . OP_GT shift_expression
  112                      | relational_expression . OP_LET shift_expression
  113                      | relational_expression . OP_GET shift_expression
  114                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 168
    OP_LT   deslocar, e ir ao estado 169
    OP_GET  deslocar, e ir ao estado 170
    OP_GT   deslocar, e ir ao estado 171
    TYPEOF  deslocar, e ir ao estado 172

    $padrão  reduzir usando a regra 106 (equality_expression)


State 95

  109 relational_expression: shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
  116 shift_expression: shift_expression . L_SHIFT additive_expression
  117                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 173
    R_SHIFT  deslocar, e ir ao estado 174

    $padrão  reduzir usando a regra 109 (relational_expression)


State 96

  115 shift_expression: additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  119 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  120                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 175
    OP_MINUS  deslocar, e ir ao estado 176

    $padrão  reduzir usando a regra 115 (shift_expression)


State 97

  118 additive_expression: multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  122 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  123                          | multiplicative_expression . OP_DIV cast_expression
  124                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 177
    OP_DIV       deslocar, e ir ao estado 178
    OP_MOD       deslocar, e ir ao estado 179

    $padrão  reduzir usando a regra 118 (additive_expression)


State 98

  121 multiplicative_expression: cast_expression .

    $padrão  reduzir usando a regra 121 (multiplicative_expression)


State 99

   89 primary_expression: not_just_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  158 field_access: not_just_name . DOT IDENTIFIER

    DOT  deslocar, e ir ao estado 180

    DOT       [reduzir usando a regra 89 (primary_expression)]
    $padrão  reduzir usando a regra 89 (primary_expression)


State 100

  143 not_just_name: complex_primary .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  157 array_access: complex_primary . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 181

    $padrão  reduzir usando a regra 143 (not_just_name)


State 101

  145 complex_primary: complex_primary_no_parenthesis .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  162 subprogram_access: complex_primary_no_parenthesis .  [L_PAREN]

    L_PAREN   reduzir usando a regra 162 (subprogram_access)
    $padrão  reduzir usando a regra 145 (complex_primary)


State 102

  153 complex_primary_no_parenthesis: array_access .

    $padrão  reduzir usando a regra 153 (complex_primary_no_parenthesis)


State 103

  154 complex_primary_no_parenthesis: field_access .

    $padrão  reduzir usando a regra 154 (complex_primary_no_parenthesis)


State 104

  155 complex_primary_no_parenthesis: subprogram_call .

    $padrão  reduzir usando a regra 155 (complex_primary_no_parenthesis)


State 105

  160 subprogram_call: subprogram_access . L_PAREN argument_list R_PAREN
  161                | subprogram_access . L_PAREN R_PAREN

    L_PAREN  deslocar, e ir ao estado 182


State 106

   38 type_declaration: STRUCT IDENTIFIER variable_declarations . END_STRUCT
   42 variable_declarations: variable_declarations . variable_declaration
   43 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   44                     | . type_specifier variable_declarators SEMICOLON
   45 modifiers: . modifier
   46          | . modifiers modifier
   47 modifier: . CONST
   48         | . STATIC
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    END_STRUCT  deslocar, e ir ao estado 183
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    variable_declaration  ir ao estado 184
    modifiers             ir ao estado 26
    modifier              ir ao estado 27
    type_specifier        ir ao estado 28
    type_name             ir ao estado 29
    primitive_type        ir ao estado 30
    qualified_name        ir ao estado 31


State 107

   41 variable_declarations: variable_declaration .

    $padrão  reduzir usando a regra 41 (variable_declarations)


State 108

   39 type_declaration: UNION IDENTIFIER discriminant . union_body END_UNION
   67 union_body: . %empty

    $padrão  reduzir usando a regra 67 (union_body)

    union_body  ir ao estado 185


State 109

   43 variable_declaration: modifiers type_specifier variable_declarators . SEMICOLON
   69 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 110
    SEMICOLON  deslocar, e ir ao estado 186


State 110

   69 variable_declarators: variable_declarators COMMA . variable_declarator
   70 variable_declarator: . declarator_name
   71                    | . declarator_name ASSIGN variable_initializer
   72 declarator_name: . IDENTIFIER
   73                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    variable_declarator  ir ao estado 187
    declarator_name      ir ao estado 45


State 111

   44 variable_declaration: type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 44 (variable_declaration)


State 112

   66 qualified_name: . IDENTIFIER
   71 variable_declarator: declarator_name ASSIGN . variable_initializer
   74 variable_initializer: . expression
   75                     | . L_BRACE R_BRACE
   76                     | . L_BRACE array_initializers R_BRACE
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    L_BRACE             deslocar, e ir ao estado 188
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    variable_initializer            ir ao estado 189
    expression                      ir ao estado 190
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 113

   66 qualified_name: . IDENTIFIER
   73 declarator_name: declarator_name L_SQ_PAREN . expression R_SQ_PAREN
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    expression                      ir ao estado 191
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 114

   64 enumerator: IDENTIFIER ASSIGN . expression
   66 qualified_name: . IDENTIFIER
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    expression                      ir ao estado 192
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 115

   63 enumerator_list: enumerator_list COMMA . enumerator
   64 enumerator: . IDENTIFIER ASSIGN expression
   65           | . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 46

    enumerator  ir ao estado 193


State 116

   40 type_declaration: ENUM IDENTIFIER enumerator_list END_ENUM .

    $padrão  reduzir usando a regra 40 (type_declaration)


State 117

    9 function_declaration: FUNCTION type_specifier subprogram_declarator subprogram_body . END_FUNCTION

    END_FUNCTION  deslocar, e ir ao estado 194


State 118

   16 parameter: CONST . type_specifier declarator_name
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 195
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 119

   12 subprogram_declarator: IDENTIFIER L_PAREN R_PAREN .

    $padrão  reduzir usando a regra 12 (subprogram_declarator)


State 120

   11 subprogram_declarator: IDENTIFIER L_PAREN parameter_list . R_PAREN
   14 parameter_list: parameter_list . COMMA parameter

    COMMA    deslocar, e ir ao estado 196
    R_PAREN  deslocar, e ir ao estado 197


State 121

   13 parameter_list: parameter .

    $padrão  reduzir usando a regra 13 (parameter_list)


State 122

   15 parameter: type_specifier . declarator_name
   72 declarator_name: . IDENTIFIER
   73                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    declarator_name  ir ao estado 198


State 123

   32 jump_statement: BREAK IDENTIFIER . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 199


State 124

   33 jump_statement: BREAK SEMICOLON .

    $padrão  reduzir usando a regra 33 (jump_statement)


State 125

   34 jump_statement: CONTINUE IDENTIFIER . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 200


State 126

   35 jump_statement: CONTINUE SEMICOLON .

    $padrão  reduzir usando a regra 35 (jump_statement)


State 127

  129 primitive_type_expression: primitive_type .  [R_PAREN]
  130                          | primitive_type . dims
  166 dims: . L_SQ_PAREN R_SQ_PAREN
  167     | . dims L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 201

    $padrão  reduzir usando a regra 129 (primitive_type_expression)

    dims  ir ao estado 202


State 128

   88 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SHIFT, TYPEOF]
  131 user_type_expression: qualified_name . dims
  156 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  163 subprogram_access: qualified_name .  [L_PAREN]
  166 dims: . L_SQ_PAREN R_SQ_PAREN
  167     | . dims L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 203

    L_PAREN   reduzir usando a regra 163 (subprogram_access)
    $padrão  reduzir usando a regra 88 (primary_expression)

    dims  ir ao estado 204


State 129

  128 cast_expression: L_PAREN expression . R_PAREN logical_unary_expression
  144 complex_primary: L_PAREN expression . R_PAREN

    R_PAREN  deslocar, e ir ao estado 205


State 130

   80 expression: assignment_expression .

    $padrão  reduzir usando a regra 80 (expression)


State 131

  126 cast_expression: L_PAREN primitive_type_expression . R_PAREN cast_expression

    R_PAREN  deslocar, e ir ao estado 206


State 132

  127 cast_expression: L_PAREN user_type_expression . R_PAREN cast_expression

    R_PAREN  deslocar, e ir ao estado 207


State 133

   37 jump_statement: RETURN SEMICOLON .

    $padrão  reduzir usando a regra 37 (jump_statement)


State 134

   88 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  156 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  163 subprogram_access: qualified_name .  [L_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 140

    L_PAREN   reduzir usando a regra 163 (subprogram_access)
    $padrão  reduzir usando a regra 88 (primary_expression)


State 135

   36 jump_statement: RETURN expression . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 208


State 136

   25 local_variable_declaration_statement: STATIC type_specifier . variable_declarators SEMICOLON
   68 variable_declarators: . variable_declarator
   69                     | . variable_declarators COMMA variable_declarator
   70 variable_declarator: . declarator_name
   71                    | . declarator_name ASSIGN variable_initializer
   72 declarator_name: . IDENTIFIER
   73                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    variable_declarators  ir ao estado 209
    variable_declarator   ir ao estado 44
    declarator_name       ir ao estado 45


State 137

   10 procedure_declaration: PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE .

    $padrão  reduzir usando a regra 10 (procedure_declaration)


State 138

   21 local_variable_declarations_and_statements: local_variable_declarations_and_statements local_variable_declarations_or_statements .

    $padrão  reduzir usando a regra 21 (local_variable_declarations_and_statements)


State 139

   24 local_variable_declaration_statement: type_specifier variable_declarators . SEMICOLON
   69 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 110
    SEMICOLON  deslocar, e ir ao estado 210


State 140

   66 qualified_name: . IDENTIFIER
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  156             | qualified_name L_SQ_PAREN . expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    expression                      ir ao estado 211
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 141

   26 statement: assignment_expression SEMICOLON .

    $padrão  reduzir usando a regra 26 (statement)


State 142

  132 assignment_operator: ASSIGN .

    $padrão  reduzir usando a regra 132 (assignment_operator)


State 143

  133 assignment_operator: ASSIGN_PLUS .

    $padrão  reduzir usando a regra 133 (assignment_operator)


State 144

  134 assignment_operator: ASSIGN_MINUS .

    $padrão  reduzir usando a regra 134 (assignment_operator)


State 145

  135 assignment_operator: ASSIGN_PRODUCT .

    $padrão  reduzir usando a regra 135 (assignment_operator)


State 146

  136 assignment_operator: ASSIGN_DIV .

    $padrão  reduzir usando a regra 136 (assignment_operator)


State 147

  137 assignment_operator: ASSIGN_MOD .

    $padrão  reduzir usando a regra 137 (assignment_operator)


State 148

  138 assignment_operator: ASSIGN_BITWISE_AND .

    $padrão  reduzir usando a regra 138 (assignment_operator)


State 149

  139 assignment_operator: ASSIGN_BITWISE_OR .

    $padrão  reduzir usando a regra 139 (assignment_operator)


State 150

  140 assignment_operator: ASSIGN_BITWISE_OR_EXC .

    $padrão  reduzir usando a regra 140 (assignment_operator)


State 151

  141 assignment_operator: ASSIGN_L_SHIFT .

    $padrão  reduzir usando a regra 141 (assignment_operator)


State 152

  142 assignment_operator: ASSIGN_R_SHIFT .

    $padrão  reduzir usando a regra 142 (assignment_operator)


State 153

   66 qualified_name: . IDENTIFIER
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   82                      | unary_expression assignment_operator . assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    assignment_expression           ir ao estado 212
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 154

  159 field_access: postfix_expression DOT . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 213


State 155

  125 cast_expression: unary_expression .

    $padrão  reduzir usando a regra 125 (cast_expression)


State 156

   83 unary_expression: arithmetic_unary_operator cast_expression .

    $padrão  reduzir usando a regra 83 (unary_expression)


State 157

   66 qualified_name: . IDENTIFIER
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  144                | L_PAREN . expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    expression                      ir ao estado 214
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 158

   86 logical_unary_expression: logical_unary_operator unary_expression .

    $padrão  reduzir usando a regra 86 (logical_unary_expression)


State 159

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   95 conditional_or_expression: conditional_or_expression LOG_OR . conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_and_expression      ir ao estado 215
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 160

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   96 conditional_or_expression: conditional_or_expression LOG_SC_OR . conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_and_expression      ir ao estado 216
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 161

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   98 conditional_and_expression: conditional_and_expression LOG_AND . inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    inclusive_or_expression         ir ao estado 217
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 162

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   99 conditional_and_expression: conditional_and_expression LOG_SC_AND . inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    inclusive_or_expression         ir ao estado 218
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 163

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  101 inclusive_or_expression: inclusive_or_expression BITWISE_OR . exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    exclusive_or_expression         ir ao estado 219
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 164

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  103 exclusive_or_expression: exclusive_or_expression BITWISE_OR_EXC . and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    and_expression                  ir ao estado 220
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 165

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  105 and_expression: and_expression AMPERSAND . equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    equality_expression             ir ao estado 221
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 166

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  107 equality_expression: equality_expression OP_EQ . relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    relational_expression           ir ao estado 222
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 167

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  108 equality_expression: equality_expression OP_NE . relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    relational_expression           ir ao estado 223
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 168

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  112 relational_expression: relational_expression OP_LET . shift_expression
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    shift_expression                ir ao estado 224
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 169

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  110 relational_expression: relational_expression OP_LT . shift_expression
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    shift_expression                ir ao estado 225
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 170

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  113 relational_expression: relational_expression OP_GET . shift_expression
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    shift_expression                ir ao estado 226
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 171

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  111 relational_expression: relational_expression OP_GT . shift_expression
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    shift_expression                ir ao estado 227
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 172

   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER
  114 relational_expression: relational_expression TYPEOF . type_specifier

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 228
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 173

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  116 shift_expression: shift_expression L_SHIFT . additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    additive_expression             ir ao estado 229
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 174

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  117 shift_expression: shift_expression R_SHIFT . additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    additive_expression             ir ao estado 230
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 175

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  119 additive_expression: additive_expression OP_PLUS . multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    multiplicative_expression       ir ao estado 231
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 176

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  120 additive_expression: additive_expression OP_MINUS . multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    multiplicative_expression       ir ao estado 232
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 177

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  122 multiplicative_expression: multiplicative_expression OP_ASTERISK . cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    cast_expression                 ir ao estado 233
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 178

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  123 multiplicative_expression: multiplicative_expression OP_DIV . cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    cast_expression                 ir ao estado 234
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 179

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  124 multiplicative_expression: multiplicative_expression OP_MOD . cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    cast_expression                 ir ao estado 235
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 180

  158 field_access: not_just_name DOT . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 236


State 181

   66 qualified_name: . IDENTIFIER
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  157             | complex_primary L_SQ_PAREN . expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    expression                      ir ao estado 237
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 182

   66 qualified_name: . IDENTIFIER
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  160                | subprogram_access L_PAREN . argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  161                | subprogram_access L_PAREN . R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name
  164 argument_list: . expression
  165              | . argument_list COMMA expression

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66
    R_PAREN             deslocar, e ir ao estado 238

    qualified_name                  ir ao estado 134
    expression                      ir ao estado 239
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105
    argument_list                   ir ao estado 240


State 183

   38 type_declaration: STRUCT IDENTIFIER variable_declarations END_STRUCT .

    $padrão  reduzir usando a regra 38 (type_declaration)


State 184

   42 variable_declarations: variable_declarations variable_declaration .

    $padrão  reduzir usando a regra 42 (variable_declarations)


State 185

   39 type_declaration: UNION IDENTIFIER discriminant union_body . END_UNION

    END_UNION  deslocar, e ir ao estado 241


State 186

   43 variable_declaration: modifiers type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 43 (variable_declaration)


State 187

   69 variable_declarators: variable_declarators COMMA variable_declarator .

    $padrão  reduzir usando a regra 69 (variable_declarators)


State 188

   66 qualified_name: . IDENTIFIER
   74 variable_initializer: . expression
   75                     | . L_BRACE R_BRACE
   75                     | L_BRACE . R_BRACE
   76                     | . L_BRACE array_initializers R_BRACE
   76                     | L_BRACE . array_initializers R_BRACE
   77 array_initializers: . variable_initializer
   78                   | . array_initializers COMMA variable_initializer
   79                   | . array_initializers COMMA
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    L_BRACE             deslocar, e ir ao estado 188
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66
    R_BRACE             deslocar, e ir ao estado 242

    qualified_name                  ir ao estado 134
    variable_initializer            ir ao estado 243
    array_initializers              ir ao estado 244
    expression                      ir ao estado 190
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 189

   71 variable_declarator: declarator_name ASSIGN variable_initializer .

    $padrão  reduzir usando a regra 71 (variable_declarator)


State 190

   74 variable_initializer: expression .

    $padrão  reduzir usando a regra 74 (variable_initializer)


State 191

   73 declarator_name: declarator_name L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 245


State 192

   64 enumerator: IDENTIFIER ASSIGN expression .

    $padrão  reduzir usando a regra 64 (enumerator)


State 193

   63 enumerator_list: enumerator_list COMMA enumerator .

    $padrão  reduzir usando a regra 63 (enumerator_list)


State 194

    9 function_declaration: FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION .

    $padrão  reduzir usando a regra 9 (function_declaration)


State 195

   16 parameter: CONST type_specifier . declarator_name
   72 declarator_name: . IDENTIFIER
   73                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    declarator_name  ir ao estado 246


State 196

   14 parameter_list: parameter_list COMMA . parameter
   15 parameter: . type_specifier declarator_name
   16          | . CONST type_specifier declarator_name
   49 type_specifier: . type_name
   50 type_name: . primitive_type
   51          | . qualified_name
   52 primitive_type: . AUTO
   53               | . BOOL
   54               | . CHAR
   55               | . DOUBLE
   56               | . FLOAT
   57               | . INT
   58               | . LONG
   59               | . SHORT
   60               | . STRING
   66 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 118
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    parameter       ir ao estado 247
    type_specifier  ir ao estado 122
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 197

   11 subprogram_declarator: IDENTIFIER L_PAREN parameter_list R_PAREN .

    $padrão  reduzir usando a regra 11 (subprogram_declarator)


State 198

   15 parameter: type_specifier declarator_name .  [COMMA, R_PAREN]
   73 declarator_name: declarator_name . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 113

    $padrão  reduzir usando a regra 15 (parameter)


State 199

   32 jump_statement: BREAK IDENTIFIER SEMICOLON .

    $padrão  reduzir usando a regra 32 (jump_statement)


State 200

   34 jump_statement: CONTINUE IDENTIFIER SEMICOLON .

    $padrão  reduzir usando a regra 34 (jump_statement)


State 201

  166 dims: L_SQ_PAREN . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 248


State 202

  130 primitive_type_expression: primitive_type dims .  [R_PAREN]
  167 dims: dims . L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 249

    $padrão  reduzir usando a regra 130 (primitive_type_expression)


State 203

   66 qualified_name: . IDENTIFIER
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  156             | qualified_name L_SQ_PAREN . expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name
  166 dims: L_SQ_PAREN . R_SQ_PAREN

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66
    R_SQ_PAREN          deslocar, e ir ao estado 248

    qualified_name                  ir ao estado 134
    expression                      ir ao estado 211
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 204

  131 user_type_expression: qualified_name dims .  [R_PAREN]
  167 dims: dims . L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 249

    $padrão  reduzir usando a regra 131 (user_type_expression)


State 205

   66 qualified_name: . IDENTIFIER
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  128 cast_expression: L_PAREN expression R_PAREN . logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  144                | L_PAREN expression R_PAREN .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 157
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64

    $padrão  reduzir usando a regra 144 (complex_primary)

    qualified_name                  ir ao estado 134
    logical_unary_expression        ir ao estado 250
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    logical_unary_operator          ir ao estado 87
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 206

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  126                | L_PAREN primitive_type_expression R_PAREN . cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    cast_expression                 ir ao estado 251
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 207

   66 qualified_name: . IDENTIFIER
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  127                | L_PAREN user_type_expression R_PAREN . cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    unary_expression                ir ao estado 155
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    cast_expression                 ir ao estado 252
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 208

   36 jump_statement: RETURN expression SEMICOLON .

    $padrão  reduzir usando a regra 36 (jump_statement)


State 209

   25 local_variable_declaration_statement: STATIC type_specifier variable_declarators . SEMICOLON
   69 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 110
    SEMICOLON  deslocar, e ir ao estado 253


State 210

   24 local_variable_declaration_statement: type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 24 (local_variable_declaration_statement)


State 211

  156 array_access: qualified_name L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 254


State 212

   82 assignment_expression: unary_expression assignment_operator assignment_expression .

    $padrão  reduzir usando a regra 82 (assignment_expression)


State 213

  159 field_access: postfix_expression DOT IDENTIFIER .

    $padrão  reduzir usando a regra 159 (field_access)


State 214

  144 complex_primary: L_PAREN expression . R_PAREN

    R_PAREN  deslocar, e ir ao estado 255


State 215

   95 conditional_or_expression: conditional_or_expression LOG_OR conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   98 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
   99                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 161
    LOG_SC_AND  deslocar, e ir ao estado 162

    $padrão  reduzir usando a regra 95 (conditional_or_expression)


State 216

   96 conditional_or_expression: conditional_or_expression LOG_SC_OR conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   98 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
   99                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 161
    LOG_SC_AND  deslocar, e ir ao estado 162

    $padrão  reduzir usando a regra 96 (conditional_or_expression)


State 217

   98 conditional_and_expression: conditional_and_expression LOG_AND inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  101 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 163

    $padrão  reduzir usando a regra 98 (conditional_and_expression)


State 218

   99 conditional_and_expression: conditional_and_expression LOG_SC_AND inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  101 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 163

    $padrão  reduzir usando a regra 99 (conditional_and_expression)


State 219

  101 inclusive_or_expression: inclusive_or_expression BITWISE_OR exclusive_or_expression .  [BITWISE_OR, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  103 exclusive_or_expression: exclusive_or_expression . BITWISE_OR_EXC and_expression

    BITWISE_OR_EXC  deslocar, e ir ao estado 164

    $padrão  reduzir usando a regra 101 (inclusive_or_expression)


State 220

  103 exclusive_or_expression: exclusive_or_expression BITWISE_OR_EXC and_expression .  [BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  105 and_expression: and_expression . AMPERSAND equality_expression

    AMPERSAND  deslocar, e ir ao estado 165

    $padrão  reduzir usando a regra 103 (exclusive_or_expression)


State 221

  105 and_expression: and_expression AMPERSAND equality_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  107 equality_expression: equality_expression . OP_EQ relational_expression
  108                    | equality_expression . OP_NE relational_expression

    OP_EQ  deslocar, e ir ao estado 166
    OP_NE  deslocar, e ir ao estado 167

    $padrão  reduzir usando a regra 105 (and_expression)


State 222

  107 equality_expression: equality_expression OP_EQ relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  110 relational_expression: relational_expression . OP_LT shift_expression
  111                      | relational_expression . OP_GT shift_expression
  112                      | relational_expression . OP_LET shift_expression
  113                      | relational_expression . OP_GET shift_expression
  114                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 168
    OP_LT   deslocar, e ir ao estado 169
    OP_GET  deslocar, e ir ao estado 170
    OP_GT   deslocar, e ir ao estado 171
    TYPEOF  deslocar, e ir ao estado 172

    $padrão  reduzir usando a regra 107 (equality_expression)


State 223

  108 equality_expression: equality_expression OP_NE relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  110 relational_expression: relational_expression . OP_LT shift_expression
  111                      | relational_expression . OP_GT shift_expression
  112                      | relational_expression . OP_LET shift_expression
  113                      | relational_expression . OP_GET shift_expression
  114                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 168
    OP_LT   deslocar, e ir ao estado 169
    OP_GET  deslocar, e ir ao estado 170
    OP_GT   deslocar, e ir ao estado 171
    TYPEOF  deslocar, e ir ao estado 172

    $padrão  reduzir usando a regra 108 (equality_expression)


State 224

  112 relational_expression: relational_expression OP_LET shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
  116 shift_expression: shift_expression . L_SHIFT additive_expression
  117                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 173
    R_SHIFT  deslocar, e ir ao estado 174

    $padrão  reduzir usando a regra 112 (relational_expression)


State 225

  110 relational_expression: relational_expression OP_LT shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
  116 shift_expression: shift_expression . L_SHIFT additive_expression
  117                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 173
    R_SHIFT  deslocar, e ir ao estado 174

    $padrão  reduzir usando a regra 110 (relational_expression)


State 226

  113 relational_expression: relational_expression OP_GET shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
  116 shift_expression: shift_expression . L_SHIFT additive_expression
  117                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 173
    R_SHIFT  deslocar, e ir ao estado 174

    $padrão  reduzir usando a regra 113 (relational_expression)


State 227

  111 relational_expression: relational_expression OP_GT shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
  116 shift_expression: shift_expression . L_SHIFT additive_expression
  117                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 173
    R_SHIFT  deslocar, e ir ao estado 174

    $padrão  reduzir usando a regra 111 (relational_expression)


State 228

  114 relational_expression: relational_expression TYPEOF type_specifier .

    $padrão  reduzir usando a regra 114 (relational_expression)


State 229

  116 shift_expression: shift_expression L_SHIFT additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  119 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  120                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 175
    OP_MINUS  deslocar, e ir ao estado 176

    $padrão  reduzir usando a regra 116 (shift_expression)


State 230

  117 shift_expression: shift_expression R_SHIFT additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  119 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  120                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 175
    OP_MINUS  deslocar, e ir ao estado 176

    $padrão  reduzir usando a regra 117 (shift_expression)


State 231

  119 additive_expression: additive_expression OP_PLUS multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  122 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  123                          | multiplicative_expression . OP_DIV cast_expression
  124                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 177
    OP_DIV       deslocar, e ir ao estado 178
    OP_MOD       deslocar, e ir ao estado 179

    $padrão  reduzir usando a regra 119 (additive_expression)


State 232

  120 additive_expression: additive_expression OP_MINUS multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  122 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  123                          | multiplicative_expression . OP_DIV cast_expression
  124                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 177
    OP_DIV       deslocar, e ir ao estado 178
    OP_MOD       deslocar, e ir ao estado 179

    $padrão  reduzir usando a regra 120 (additive_expression)


State 233

  122 multiplicative_expression: multiplicative_expression OP_ASTERISK cast_expression .

    $padrão  reduzir usando a regra 122 (multiplicative_expression)


State 234

  123 multiplicative_expression: multiplicative_expression OP_DIV cast_expression .

    $padrão  reduzir usando a regra 123 (multiplicative_expression)


State 235

  124 multiplicative_expression: multiplicative_expression OP_MOD cast_expression .

    $padrão  reduzir usando a regra 124 (multiplicative_expression)


State 236

  158 field_access: not_just_name DOT IDENTIFIER .

    $padrão  reduzir usando a regra 158 (field_access)


State 237

  157 array_access: complex_primary L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 256


State 238

  161 subprogram_call: subprogram_access L_PAREN R_PAREN .

    $padrão  reduzir usando a regra 161 (subprogram_call)


State 239

  164 argument_list: expression .

    $padrão  reduzir usando a regra 164 (argument_list)


State 240

  160 subprogram_call: subprogram_access L_PAREN argument_list . R_PAREN
  165 argument_list: argument_list . COMMA expression

    COMMA    deslocar, e ir ao estado 257
    R_PAREN  deslocar, e ir ao estado 258


State 241

   39 type_declaration: UNION IDENTIFIER discriminant union_body END_UNION .

    $padrão  reduzir usando a regra 39 (type_declaration)


State 242

   75 variable_initializer: L_BRACE R_BRACE .

    $padrão  reduzir usando a regra 75 (variable_initializer)


State 243

   77 array_initializers: variable_initializer .

    $padrão  reduzir usando a regra 77 (array_initializers)


State 244

   76 variable_initializer: L_BRACE array_initializers . R_BRACE
   78 array_initializers: array_initializers . COMMA variable_initializer
   79                   | array_initializers . COMMA

    COMMA    deslocar, e ir ao estado 259
    R_BRACE  deslocar, e ir ao estado 260


State 245

   73 declarator_name: declarator_name L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 73 (declarator_name)


State 246

   16 parameter: CONST type_specifier declarator_name .  [COMMA, R_PAREN]
   73 declarator_name: declarator_name . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 113

    $padrão  reduzir usando a regra 16 (parameter)


State 247

   14 parameter_list: parameter_list COMMA parameter .

    $padrão  reduzir usando a regra 14 (parameter_list)


State 248

  166 dims: L_SQ_PAREN R_SQ_PAREN .

    $padrão  reduzir usando a regra 166 (dims)


State 249

  167 dims: dims L_SQ_PAREN . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 261


State 250

  128 cast_expression: L_PAREN expression R_PAREN logical_unary_expression .

    $padrão  reduzir usando a regra 128 (cast_expression)


State 251

  126 cast_expression: L_PAREN primitive_type_expression R_PAREN cast_expression .

    $padrão  reduzir usando a regra 126 (cast_expression)


State 252

  127 cast_expression: L_PAREN user_type_expression R_PAREN cast_expression .

    $padrão  reduzir usando a regra 127 (cast_expression)


State 253

   25 local_variable_declaration_statement: STATIC type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 25 (local_variable_declaration_statement)


State 254

  156 array_access: qualified_name L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 156 (array_access)


State 255

  144 complex_primary: L_PAREN expression R_PAREN .

    $padrão  reduzir usando a regra 144 (complex_primary)


State 256

  157 array_access: complex_primary L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 157 (array_access)


State 257

   66 qualified_name: . IDENTIFIER
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name
  165 argument_list: argument_list COMMA . expression

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    qualified_name                  ir ao estado 134
    expression                      ir ao estado 262
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 258

  160 subprogram_call: subprogram_access L_PAREN argument_list R_PAREN .

    $padrão  reduzir usando a regra 160 (subprogram_call)


State 259

   66 qualified_name: . IDENTIFIER
   74 variable_initializer: . expression
   75                     | . L_BRACE R_BRACE
   76                     | . L_BRACE array_initializers R_BRACE
   78 array_initializers: array_initializers COMMA . variable_initializer
   79                   | array_initializers COMMA .  [COMMA, R_BRACE]
   80 expression: . assignment_expression
   81 assignment_expression: . conditional_or_expression
   82                      | . unary_expression assignment_operator assignment_expression
   83 unary_expression: . arithmetic_unary_operator cast_expression
   84                 | . logical_unary_expression
   85 logical_unary_expression: . postfix_expression
   86                         | . logical_unary_operator unary_expression
   87 postfix_expression: . primary_expression
   88 primary_expression: . qualified_name
   89                   | . not_just_name
   90 arithmetic_unary_operator: . OP_PLUS
   91                          | . OP_MINUS
   92 logical_unary_operator: . BITWISE_COMPLEMENT
   93                       | . LOG_NOT
   94 conditional_or_expression: . conditional_and_expression
   95                          | . conditional_or_expression LOG_OR conditional_and_expression
   96                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   97 conditional_and_expression: . inclusive_or_expression
   98                           | . conditional_and_expression LOG_AND inclusive_or_expression
   99                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  100 inclusive_or_expression: . exclusive_or_expression
  101                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  102 exclusive_or_expression: . and_expression
  103                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  104 and_expression: . equality_expression
  105               | . and_expression AMPERSAND equality_expression
  106 equality_expression: . relational_expression
  107                    | . equality_expression OP_EQ relational_expression
  108                    | . equality_expression OP_NE relational_expression
  109 relational_expression: . shift_expression
  110                      | . relational_expression OP_LT shift_expression
  111                      | . relational_expression OP_GT shift_expression
  112                      | . relational_expression OP_LET shift_expression
  113                      | . relational_expression OP_GET shift_expression
  114                      | . relational_expression TYPEOF type_specifier
  115 shift_expression: . additive_expression
  116                 | . shift_expression L_SHIFT additive_expression
  117                 | . shift_expression R_SHIFT additive_expression
  118 additive_expression: . multiplicative_expression
  119                    | . additive_expression OP_PLUS multiplicative_expression
  120                    | . additive_expression OP_MINUS multiplicative_expression
  121 multiplicative_expression: . cast_expression
  122                          | . multiplicative_expression OP_ASTERISK cast_expression
  123                          | . multiplicative_expression OP_DIV cast_expression
  124                          | . multiplicative_expression OP_MOD cast_expression
  125 cast_expression: . unary_expression
  126                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  127                | . L_PAREN user_type_expression R_PAREN cast_expression
  128                | . L_PAREN expression R_PAREN logical_unary_expression
  143 not_just_name: . complex_primary
  144 complex_primary: . L_PAREN expression R_PAREN
  145                | . complex_primary_no_parenthesis
  146 complex_primary_no_parenthesis: . BOOL_LITERAL
  147                               | . OCTAL
  148                               | . DECIMAL
  149                               | . HEX
  150                               | . FLOATING_POINT
  151                               | . STRING_LITERAL
  152                               | . NNULL
  153                               | . array_access
  154                               | . field_access
  155                               | . subprogram_call
  156 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  157             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  158 field_access: . not_just_name DOT IDENTIFIER
  159             | . postfix_expression DOT IDENTIFIER
  160 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  161                | . subprogram_access L_PAREN R_PAREN
  162 subprogram_access: . complex_primary_no_parenthesis
  163                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 58
    L_PAREN             deslocar, e ir ao estado 62
    L_BRACE             deslocar, e ir ao estado 188
    LOG_NOT             deslocar, e ir ao estado 63
    NNULL               deslocar, e ir ao estado 64
    OP_PLUS             deslocar, e ir ao estado 65
    OP_MINUS            deslocar, e ir ao estado 66

    $padrão  reduzir usando a regra 79 (array_initializers)

    qualified_name                  ir ao estado 134
    variable_initializer            ir ao estado 263
    expression                      ir ao estado 190
    assignment_expression           ir ao estado 130
    unary_expression                ir ao estado 82
    logical_unary_expression        ir ao estado 83
    postfix_expression              ir ao estado 84
    primary_expression              ir ao estado 85
    arithmetic_unary_operator       ir ao estado 86
    logical_unary_operator          ir ao estado 87
    conditional_or_expression       ir ao estado 88
    conditional_and_expression      ir ao estado 89
    inclusive_or_expression         ir ao estado 90
    exclusive_or_expression         ir ao estado 91
    and_expression                  ir ao estado 92
    equality_expression             ir ao estado 93
    relational_expression           ir ao estado 94
    shift_expression                ir ao estado 95
    additive_expression             ir ao estado 96
    multiplicative_expression       ir ao estado 97
    cast_expression                 ir ao estado 98
    not_just_name                   ir ao estado 99
    complex_primary                 ir ao estado 100
    complex_primary_no_parenthesis  ir ao estado 101
    array_access                    ir ao estado 102
    field_access                    ir ao estado 103
    subprogram_call                 ir ao estado 104
    subprogram_access               ir ao estado 105


State 260

   76 variable_initializer: L_BRACE array_initializers R_BRACE .

    $padrão  reduzir usando a regra 76 (variable_initializer)


State 261

  167 dims: dims L_SQ_PAREN R_SQ_PAREN .

    $padrão  reduzir usando a regra 167 (dims)


State 262

  165 argument_list: argument_list COMMA expression .

    $padrão  reduzir usando a regra 165 (argument_list)


State 263

   78 array_initializers: array_initializers COMMA variable_initializer .

    $padrão  reduzir usando a regra 78 (array_initializers)
