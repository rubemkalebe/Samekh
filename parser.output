Terminais não utilizados na gramática

   BREAK
   BYTE
   CASE
   CONTINUE
   DO
   ELSE
   ELSIF
   END_CASE
   END_FOR
   END_FUNCTION
   END_IF
   END_PROCEDURE
   END_WHILE
   FOR
   FUNCTION
   IF
   NNULL
   OP_PTR
   PRINT
   PRINTLN
   PROCEDURE
   READ
   RETURN
   SIZEOF
   WHEN
   WHILE


Estado 10 conflitos: 1 de deslocamento/redução
Estado 52 conflitos: 1 de deslocamento/redução
Estado 92 conflitos: 1 de deslocamento/redução
Estado 206 conflitos: 1 de deslocamento/redução


Gramática

    0 $accept: translation_unit $end

    1 translation_unit: program_file

    2 program_file: declarations

    3 declarations: declaration
    4             | declarations declaration

    5 declaration: function_declaration
    6            | procedure_declaration
    7            | field_declaration

    8 type_declaration: STRUCT IDENTIFIER field_declarations END_STRUCT
    9                 | UNION IDENTIFIER discriminant union_body END_UNION
   10                 | ENUM IDENTIFIER enumerator_list END_ENUM

   11 field_declarations: field_declaration
   12                   | field_declarations field_declaration

   13 field_declaration: field_variable_declaration SEMICOLON
   14                  | type_declaration

   15 field_variable_declaration: modifiers type_specifier variable_declarators
   16                           | type_specifier variable_declarators

   17 modifiers: modifier
   18          | modifiers modifier

   19 modifier: CONST
   20         | STATIC

   21 type_specifier: type_name
   22               | type_name dims

   23 type_name: primitive_type
   24          | qualified_name

   25 dims: L_SQ_PAREN expression_or_empty R_SQ_PAREN
   26     | dims L_SQ_PAREN expression_or_empty R_SQ_PAREN

   27 expression_or_empty: expression
   28                    | %empty

   29 primitive_type: AUTO
   30               | BOOL
   31               | CHAR
   32               | DOUBLE
   33               | FLOAT
   34               | INT
   35               | LONG
   36               | SHORT
   37               | STRING

   38 qualified_name: IDENTIFIER qualified_name2

   39 qualified_name2: %empty
   40                | DOT IDENTIFIER qualified_name2

   41 variable_declarators: variable_declarator
   42                     | variable_declarators COMMA variable_declarator

   43 variable_declarator: declarator_name
   44                    | declarator_name ASSIGN variable_initializer

   45 declarator_name: IDENTIFIER
   46                | declarator_name L_SQ_PAREN R_SQ_PAREN

   47 variable_initializer: expression
   48                     | L_BRACE R_BRACE
   49                     | L_BRACE array_initializers R_BRACE

   50 array_initializers: variable_initializer
   51                   | array_initializers COMMA variable_initializer
   52                   | array_initializers COMMA

   53 discriminant: %empty

   54 union_body: %empty

   55 enumerator_list: enumerator
   56                | enumerator_list COMMA enumerator

   57 enumerator: IDENTIFIER ASSIGN expression
   58           | IDENTIFIER

   59 function_declaration: ASSIGN

   60 procedure_declaration: COMMA

   61 expression: assignment_expression

   62 assignment_expression: conditional_or_expression
   63                      | unary_expression assignment_operator assignment_expression

   64 unary_expression: arithmetic_unary_operator cast_expression
   65                 | logical_unary_expression

   66 logical_unary_expression: postfix_expression
   67                         | logical_unary_operator unary_expression

   68 postfix_expression: primary_expression

   69 primary_expression: qualified_name
   70                   | not_just_name

   71 arithmetic_unary_operator: OP_PLUS
   72                          | OP_MINUS

   73 logical_unary_operator: BITWISE_COMPLEMENT
   74                       | LOG_NOT

   75 conditional_or_expression: conditional_and_expression
   76                          | conditional_or_expression LOG_OR conditional_and_expression
   77                          | conditional_or_expression LOG_SC_OR conditional_and_expression

   78 conditional_and_expression: inclusive_or_expression
   79                           | conditional_and_expression LOG_AND inclusive_or_expression
   80                           | conditional_and_expression LOG_SC_AND inclusive_or_expression

   81 inclusive_or_expression: exclusive_or_expression
   82                        | inclusive_or_expression BITWISE_OR exclusive_or_expression

   83 exclusive_or_expression: and_expression
   84                        | exclusive_or_expression BITWISE_OR_EXC and_expression

   85 and_expression: equality_expression
   86               | and_expression AMPERSAND equality_expression

   87 equality_expression: relational_expression
   88                    | equality_expression OP_EQ relational_expression
   89                    | equality_expression OP_NE relational_expression

   90 relational_expression: shift_expression
   91                      | relational_expression OP_LT shift_expression
   92                      | relational_expression OP_GT shift_expression
   93                      | relational_expression OP_LET shift_expression
   94                      | relational_expression OP_GET shift_expression
   95                      | relational_expression TYPEOF type_specifier

   96 shift_expression: additive_expression
   97                 | shift_expression L_SHIFT additive_expression
   98                 | shift_expression R_SHIFT additive_expression

   99 additive_expression: multiplicative_expression
  100                    | additive_expression OP_PLUS multiplicative_expression
  101                    | additive_expression OP_MINUS multiplicative_expression

  102 multiplicative_expression: cast_expression
  103                          | multiplicative_expression OP_ASTERISK cast_expression
  104                          | multiplicative_expression OP_DIV cast_expression
  105                          | multiplicative_expression OP_MOD cast_expression

  106 cast_expression: unary_expression
  107                | L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | L_PAREN user_type_expression R_PAREN cast_expression
  109                | L_PAREN expression R_PAREN logical_unary_expression

  110 primitive_type_expression: primitive_type
  111                          | primitive_type dims

  112 user_type_expression: qualified_name dims

  113 assignment_operator: ASSIGN
  114                    | ASSIGN_PLUS
  115                    | ASSIGN_MINUS
  116                    | ASSIGN_PRODUCT
  117                    | ASSIGN_DIV
  118                    | ASSIGN_MOD
  119                    | ASSIGN_BITWISE_AND
  120                    | ASSIGN_BITWISE_OR
  121                    | ASSIGN_BITWISE_OR_EXC
  122                    | ASSIGN_L_SHIFT
  123                    | ASSIGN_R_SHIFT

  124 not_just_name: complex_primary

  125 complex_primary: L_PAREN expression R_PAREN
  126                | complex_primary_no_parenthesis

  127 complex_primary_no_parenthesis: BOOL_LITERAL
  128                               | OCTAL
  129                               | DECIMAL
  130                               | HEX
  131                               | FLOATING_POINT
  132                               | STRING_LITERAL
  133                               | array_access
  134                               | field_access
  135                               | subprogram_call

  136 array_access: qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | complex_primary L_SQ_PAREN expression R_SQ_PAREN

  138 field_access: not_just_name DOT IDENTIFIER
  139             | postfix_expression DOT IDENTIFIER

  140 subprogram_call: subprogram_access L_PAREN argument_list R_PAREN
  141                | subprogram_access L_PAREN R_PAREN

  142 subprogram_access: complex_primary_no_parenthesis
  143                  | qualified_name

  144 argument_list: expression
  145              | argument_list COMMA expression


Terminais, com as regras onde eles aparecem

$end (0) 0
error (256)
ASSIGN (258) 44 57 59 113
ASSIGN_PLUS (259) 114
ASSIGN_MINUS (260) 115
ASSIGN_PRODUCT (261) 116
ASSIGN_DIV (262) 117
ASSIGN_MOD (263) 118
ASSIGN_BITWISE_AND (264) 119
ASSIGN_BITWISE_OR (265) 120
ASSIGN_BITWISE_OR_EXC (266) 121
ASSIGN_L_SHIFT (267) 122
ASSIGN_R_SHIFT (268) 123
AMPERSAND (269) 86
AUTO (270) 29
BOOL (271) 30
BOOL_LITERAL (272) 127
BREAK (273)
BYTE (274)
BITWISE_COMPLEMENT (275) 73
BITWISE_OR (276) 82
BITWISE_OR_EXC (277) 84
CASE (278)
CHAR (279) 31
COMMA (280) 42 51 52 56 60 145
CONTINUE (281)
CONST (282) 19
DECIMAL (283) 129
DO (284)
DOT (285) 40 138 139
DOUBLE (286) 32
ENUM (287) 10
ELSE (288)
ELSIF (289)
END_CASE (290)
END_ENUM (291) 10
END_FOR (292)
END_FUNCTION (293)
END_IF (294)
END_PROCEDURE (295)
END_STRUCT (296) 8
END_UNION (297) 9
END_WHILE (298)
FLOAT (299) 33
FOR (300)
FUNCTION (301)
FLOATING_POINT (302) 131
HEX (303) 130
IDENTIFIER (304) 8 9 10 38 40 45 57 58 138 139
IF (305)
INT (306) 34
L_PAREN (307) 107 108 109 125 140 141
L_SQ_PAREN (308) 25 26 46 136 137
L_BRACE (309) 48 49
L_SHIFT (310) 97
LOG_NOT (311) 74
LOG_AND (312) 79
LOG_OR (313) 76
LOG_SC_AND (314) 80
LOG_SC_OR (315) 77
LONG (316) 35
NNULL (317)
OP_EQ (318) 88
OP_NE (319) 89
OP_PTR (320)
OP_PLUS (321) 71 100
OP_MINUS (322) 72 101
OP_ASTERISK (323) 103
OP_DIV (324) 104
OP_MOD (325) 105
OP_LET (326) 93
OP_LT (327) 91
OP_GET (328) 94
OP_GT (329) 92
OCTAL (330) 128
PRINT (331)
PRINTLN (332)
PROCEDURE (333)
READ (334)
RETURN (335)
R_PAREN (336) 107 108 109 125 140 141
R_SQ_PAREN (337) 25 26 46 136 137
R_BRACE (338) 48 49
R_SHIFT (339) 98
SHORT (340) 36
STRING (341) 37
STRING_LITERAL (342) 132
STRUCT (343) 8
STATIC (344) 20
SIZEOF (345)
SEMICOLON (346) 13
TYPEOF (347) 95
UNION (348) 9
WHEN (349)
WHILE (350)


Não-terminais com as regras onde eles aparecem

$accept (96)
    à esquerda: 0
translation_unit (97)
    à esquerda: 1, à direita: 0
program_file (98)
    à esquerda: 2, à direita: 1
declarations (99)
    à esquerda: 3 4, à direita: 2 4
declaration (100)
    à esquerda: 5 6 7, à direita: 3 4
type_declaration (101)
    à esquerda: 8 9 10, à direita: 14
field_declarations (102)
    à esquerda: 11 12, à direita: 8 12
field_declaration (103)
    à esquerda: 13 14, à direita: 7 11 12
field_variable_declaration (104)
    à esquerda: 15 16, à direita: 13
modifiers (105)
    à esquerda: 17 18, à direita: 15 18
modifier (106)
    à esquerda: 19 20, à direita: 17 18
type_specifier (107)
    à esquerda: 21 22, à direita: 15 16 95
type_name (108)
    à esquerda: 23 24, à direita: 21 22
dims (109)
    à esquerda: 25 26, à direita: 22 26 111 112
expression_or_empty (110)
    à esquerda: 27 28, à direita: 25 26
primitive_type (111)
    à esquerda: 29 30 31 32 33 34 35 36 37, à direita: 23 110 111
qualified_name (112)
    à esquerda: 38, à direita: 24 69 112 136 143
qualified_name2 (113)
    à esquerda: 39 40, à direita: 38 40
variable_declarators (114)
    à esquerda: 41 42, à direita: 15 16 42
variable_declarator (115)
    à esquerda: 43 44, à direita: 41 42
declarator_name (116)
    à esquerda: 45 46, à direita: 43 44 46
variable_initializer (117)
    à esquerda: 47 48 49, à direita: 44 50 51
array_initializers (118)
    à esquerda: 50 51 52, à direita: 49 51 52
discriminant (119)
    à esquerda: 53, à direita: 9
union_body (120)
    à esquerda: 54, à direita: 9
enumerator_list (121)
    à esquerda: 55 56, à direita: 10 56
enumerator (122)
    à esquerda: 57 58, à direita: 55 56
function_declaration (123)
    à esquerda: 59, à direita: 5
procedure_declaration (124)
    à esquerda: 60, à direita: 6
expression (125)
    à esquerda: 61, à direita: 27 47 57 109 125 136 137 144 145
assignment_expression (126)
    à esquerda: 62 63, à direita: 61 63
unary_expression (127)
    à esquerda: 64 65, à direita: 63 67 106
logical_unary_expression (128)
    à esquerda: 66 67, à direita: 65 109
postfix_expression (129)
    à esquerda: 68, à direita: 66 139
primary_expression (130)
    à esquerda: 69 70, à direita: 68
arithmetic_unary_operator (131)
    à esquerda: 71 72, à direita: 64
logical_unary_operator (132)
    à esquerda: 73 74, à direita: 67
conditional_or_expression (133)
    à esquerda: 75 76 77, à direita: 62 76 77
conditional_and_expression (134)
    à esquerda: 78 79 80, à direita: 75 76 77 79 80
inclusive_or_expression (135)
    à esquerda: 81 82, à direita: 78 79 80 82
exclusive_or_expression (136)
    à esquerda: 83 84, à direita: 81 82 84
and_expression (137)
    à esquerda: 85 86, à direita: 83 84 86
equality_expression (138)
    à esquerda: 87 88 89, à direita: 85 86 88 89
relational_expression (139)
    à esquerda: 90 91 92 93 94 95, à direita: 87 88 89 91 92 93 94
    95
shift_expression (140)
    à esquerda: 96 97 98, à direita: 90 91 92 93 94 97 98
additive_expression (141)
    à esquerda: 99 100 101, à direita: 96 97 98 100 101
multiplicative_expression (142)
    à esquerda: 102 103 104 105, à direita: 99 100 101 103 104 105
cast_expression (143)
    à esquerda: 106 107 108 109, à direita: 64 102 103 104 105 107
    108
primitive_type_expression (144)
    à esquerda: 110 111, à direita: 107
user_type_expression (145)
    à esquerda: 112, à direita: 108
assignment_operator (146)
    à esquerda: 113 114 115 116 117 118 119 120 121 122 123, à direita:
    63
not_just_name (147)
    à esquerda: 124, à direita: 70 138
complex_primary (148)
    à esquerda: 125 126, à direita: 124 137
complex_primary_no_parenthesis (149)
    à esquerda: 127 128 129 130 131 132 133 134 135, à direita: 126
    142
array_access (150)
    à esquerda: 136 137, à direita: 133
field_access (151)
    à esquerda: 138 139, à direita: 134
subprogram_call (152)
    à esquerda: 140 141, à direita: 135
subprogram_access (153)
    à esquerda: 142 143, à direita: 140 141
argument_list (154)
    à esquerda: 144 145, à direita: 140 145


State 0

    0 $accept: . translation_unit $end
    1 translation_unit: . program_file
    2 program_file: . declarations
    3 declarations: . declaration
    4             | . declarations declaration
    5 declaration: . function_declaration
    6            | . procedure_declaration
    7            | . field_declaration
    8 type_declaration: . STRUCT IDENTIFIER field_declarations END_STRUCT
    9                 | . UNION IDENTIFIER discriminant union_body END_UNION
   10                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   13 field_declaration: . field_variable_declaration SEMICOLON
   14                  | . type_declaration
   15 field_variable_declaration: . modifiers type_specifier variable_declarators
   16                           | . type_specifier variable_declarators
   17 modifiers: . modifier
   18          | . modifiers modifier
   19 modifier: . CONST
   20         | . STATIC
   21 type_specifier: . type_name
   22               | . type_name dims
   23 type_name: . primitive_type
   24          | . qualified_name
   29 primitive_type: . AUTO
   30               | . BOOL
   31               | . CHAR
   32               | . DOUBLE
   33               | . FLOAT
   34               | . INT
   35               | . LONG
   36               | . SHORT
   37               | . STRING
   38 qualified_name: . IDENTIFIER qualified_name2
   59 function_declaration: . ASSIGN
   60 procedure_declaration: . COMMA

    ASSIGN      deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    COMMA       deslocar, e ir ao estado 5
    CONST       deslocar, e ir ao estado 6
    DOUBLE      deslocar, e ir ao estado 7
    ENUM        deslocar, e ir ao estado 8
    FLOAT       deslocar, e ir ao estado 9
    IDENTIFIER  deslocar, e ir ao estado 10
    INT         deslocar, e ir ao estado 11
    LONG        deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STRUCT      deslocar, e ir ao estado 15
    STATIC      deslocar, e ir ao estado 16
    UNION       deslocar, e ir ao estado 17

    translation_unit            ir ao estado 18
    program_file                ir ao estado 19
    declarations                ir ao estado 20
    declaration                 ir ao estado 21
    type_declaration            ir ao estado 22
    field_declaration           ir ao estado 23
    field_variable_declaration  ir ao estado 24
    modifiers                   ir ao estado 25
    modifier                    ir ao estado 26
    type_specifier              ir ao estado 27
    type_name                   ir ao estado 28
    primitive_type              ir ao estado 29
    qualified_name              ir ao estado 30
    function_declaration        ir ao estado 31
    procedure_declaration       ir ao estado 32


State 1

   59 function_declaration: ASSIGN .

    $padrão  reduzir usando a regra 59 (function_declaration)


State 2

   29 primitive_type: AUTO .

    $padrão  reduzir usando a regra 29 (primitive_type)


State 3

   30 primitive_type: BOOL .

    $padrão  reduzir usando a regra 30 (primitive_type)


State 4

   31 primitive_type: CHAR .

    $padrão  reduzir usando a regra 31 (primitive_type)


State 5

   60 procedure_declaration: COMMA .

    $padrão  reduzir usando a regra 60 (procedure_declaration)


State 6

   19 modifier: CONST .

    $padrão  reduzir usando a regra 19 (modifier)


State 7

   32 primitive_type: DOUBLE .

    $padrão  reduzir usando a regra 32 (primitive_type)


State 8

   10 type_declaration: ENUM . IDENTIFIER enumerator_list END_ENUM

    IDENTIFIER  deslocar, e ir ao estado 33


State 9

   33 primitive_type: FLOAT .

    $padrão  reduzir usando a regra 33 (primitive_type)


State 10

   38 qualified_name: IDENTIFIER . qualified_name2
   39 qualified_name2: . %empty  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, IDENTIFIER, L_PAREN, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
   40                | . DOT IDENTIFIER qualified_name2

    DOT  deslocar, e ir ao estado 34

    DOT       [reduzir usando a regra 39 (qualified_name2)]
    $padrão  reduzir usando a regra 39 (qualified_name2)

    qualified_name2  ir ao estado 35


State 11

   34 primitive_type: INT .

    $padrão  reduzir usando a regra 34 (primitive_type)


State 12

   35 primitive_type: LONG .

    $padrão  reduzir usando a regra 35 (primitive_type)


State 13

   36 primitive_type: SHORT .

    $padrão  reduzir usando a regra 36 (primitive_type)


State 14

   37 primitive_type: STRING .

    $padrão  reduzir usando a regra 37 (primitive_type)


State 15

    8 type_declaration: STRUCT . IDENTIFIER field_declarations END_STRUCT

    IDENTIFIER  deslocar, e ir ao estado 36


State 16

   20 modifier: STATIC .

    $padrão  reduzir usando a regra 20 (modifier)


State 17

    9 type_declaration: UNION . IDENTIFIER discriminant union_body END_UNION

    IDENTIFIER  deslocar, e ir ao estado 37


State 18

    0 $accept: translation_unit . $end

    $end  deslocar, e ir ao estado 38


State 19

    1 translation_unit: program_file .

    $padrão  reduzir usando a regra 1 (translation_unit)


State 20

    2 program_file: declarations .  [$end]
    4 declarations: declarations . declaration
    5 declaration: . function_declaration
    6            | . procedure_declaration
    7            | . field_declaration
    8 type_declaration: . STRUCT IDENTIFIER field_declarations END_STRUCT
    9                 | . UNION IDENTIFIER discriminant union_body END_UNION
   10                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   13 field_declaration: . field_variable_declaration SEMICOLON
   14                  | . type_declaration
   15 field_variable_declaration: . modifiers type_specifier variable_declarators
   16                           | . type_specifier variable_declarators
   17 modifiers: . modifier
   18          | . modifiers modifier
   19 modifier: . CONST
   20         | . STATIC
   21 type_specifier: . type_name
   22               | . type_name dims
   23 type_name: . primitive_type
   24          | . qualified_name
   29 primitive_type: . AUTO
   30               | . BOOL
   31               | . CHAR
   32               | . DOUBLE
   33               | . FLOAT
   34               | . INT
   35               | . LONG
   36               | . SHORT
   37               | . STRING
   38 qualified_name: . IDENTIFIER qualified_name2
   59 function_declaration: . ASSIGN
   60 procedure_declaration: . COMMA

    ASSIGN      deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    COMMA       deslocar, e ir ao estado 5
    CONST       deslocar, e ir ao estado 6
    DOUBLE      deslocar, e ir ao estado 7
    ENUM        deslocar, e ir ao estado 8
    FLOAT       deslocar, e ir ao estado 9
    IDENTIFIER  deslocar, e ir ao estado 10
    INT         deslocar, e ir ao estado 11
    LONG        deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STRUCT      deslocar, e ir ao estado 15
    STATIC      deslocar, e ir ao estado 16
    UNION       deslocar, e ir ao estado 17

    $padrão  reduzir usando a regra 2 (program_file)

    declaration                 ir ao estado 39
    type_declaration            ir ao estado 22
    field_declaration           ir ao estado 23
    field_variable_declaration  ir ao estado 24
    modifiers                   ir ao estado 25
    modifier                    ir ao estado 26
    type_specifier              ir ao estado 27
    type_name                   ir ao estado 28
    primitive_type              ir ao estado 29
    qualified_name              ir ao estado 30
    function_declaration        ir ao estado 31
    procedure_declaration       ir ao estado 32


State 21

    3 declarations: declaration .

    $padrão  reduzir usando a regra 3 (declarations)


State 22

   14 field_declaration: type_declaration .

    $padrão  reduzir usando a regra 14 (field_declaration)


State 23

    7 declaration: field_declaration .

    $padrão  reduzir usando a regra 7 (declaration)


State 24

   13 field_declaration: field_variable_declaration . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 40


State 25

   15 field_variable_declaration: modifiers . type_specifier variable_declarators
   18 modifiers: modifiers . modifier
   19 modifier: . CONST
   20         | . STATIC
   21 type_specifier: . type_name
   22               | . type_name dims
   23 type_name: . primitive_type
   24          | . qualified_name
   29 primitive_type: . AUTO
   30               | . BOOL
   31               | . CHAR
   32               | . DOUBLE
   33               | . FLOAT
   34               | . INT
   35               | . LONG
   36               | . SHORT
   37               | . STRING
   38 qualified_name: . IDENTIFIER qualified_name2

    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 6
    DOUBLE      deslocar, e ir ao estado 7
    FLOAT       deslocar, e ir ao estado 9
    IDENTIFIER  deslocar, e ir ao estado 10
    INT         deslocar, e ir ao estado 11
    LONG        deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    modifier        ir ao estado 41
    type_specifier  ir ao estado 42
    type_name       ir ao estado 28
    primitive_type  ir ao estado 29
    qualified_name  ir ao estado 30


State 26

   17 modifiers: modifier .

    $padrão  reduzir usando a regra 17 (modifiers)


State 27

   16 field_variable_declaration: type_specifier . variable_declarators
   41 variable_declarators: . variable_declarator
   42                     | . variable_declarators COMMA variable_declarator
   43 variable_declarator: . declarator_name
   44                    | . declarator_name ASSIGN variable_initializer
   45 declarator_name: . IDENTIFIER
   46                | . declarator_name L_SQ_PAREN R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 43

    variable_declarators  ir ao estado 44
    variable_declarator   ir ao estado 45
    declarator_name       ir ao estado 46


State 28

   21 type_specifier: type_name .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, IDENTIFIER, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   22               | type_name . dims
   25 dims: . L_SQ_PAREN expression_or_empty R_SQ_PAREN
   26     | . dims L_SQ_PAREN expression_or_empty R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 47

    $padrão  reduzir usando a regra 21 (type_specifier)

    dims  ir ao estado 48


State 29

   23 type_name: primitive_type .

    $padrão  reduzir usando a regra 23 (type_name)


State 30

   24 type_name: qualified_name .

    $padrão  reduzir usando a regra 24 (type_name)


State 31

    5 declaration: function_declaration .

    $padrão  reduzir usando a regra 5 (declaration)


State 32

    6 declaration: procedure_declaration .

    $padrão  reduzir usando a regra 6 (declaration)


State 33

   10 type_declaration: ENUM IDENTIFIER . enumerator_list END_ENUM
   55 enumerator_list: . enumerator
   56                | . enumerator_list COMMA enumerator
   57 enumerator: . IDENTIFIER ASSIGN expression
   58           | . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 49

    enumerator_list  ir ao estado 50
    enumerator       ir ao estado 51


State 34

   40 qualified_name2: DOT . IDENTIFIER qualified_name2

    IDENTIFIER  deslocar, e ir ao estado 52


State 35

   38 qualified_name: IDENTIFIER qualified_name2 .

    $padrão  reduzir usando a regra 38 (qualified_name)


State 36

    8 type_declaration: . STRUCT IDENTIFIER field_declarations END_STRUCT
    8                 | STRUCT IDENTIFIER . field_declarations END_STRUCT
    9                 | . UNION IDENTIFIER discriminant union_body END_UNION
   10                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   11 field_declarations: . field_declaration
   12                   | . field_declarations field_declaration
   13 field_declaration: . field_variable_declaration SEMICOLON
   14                  | . type_declaration
   15 field_variable_declaration: . modifiers type_specifier variable_declarators
   16                           | . type_specifier variable_declarators
   17 modifiers: . modifier
   18          | . modifiers modifier
   19 modifier: . CONST
   20         | . STATIC
   21 type_specifier: . type_name
   22               | . type_name dims
   23 type_name: . primitive_type
   24          | . qualified_name
   29 primitive_type: . AUTO
   30               | . BOOL
   31               | . CHAR
   32               | . DOUBLE
   33               | . FLOAT
   34               | . INT
   35               | . LONG
   36               | . SHORT
   37               | . STRING
   38 qualified_name: . IDENTIFIER qualified_name2

    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 6
    DOUBLE      deslocar, e ir ao estado 7
    ENUM        deslocar, e ir ao estado 8
    FLOAT       deslocar, e ir ao estado 9
    IDENTIFIER  deslocar, e ir ao estado 10
    INT         deslocar, e ir ao estado 11
    LONG        deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STRUCT      deslocar, e ir ao estado 15
    STATIC      deslocar, e ir ao estado 16
    UNION       deslocar, e ir ao estado 17

    type_declaration            ir ao estado 22
    field_declarations          ir ao estado 53
    field_declaration           ir ao estado 54
    field_variable_declaration  ir ao estado 24
    modifiers                   ir ao estado 25
    modifier                    ir ao estado 26
    type_specifier              ir ao estado 27
    type_name                   ir ao estado 28
    primitive_type              ir ao estado 29
    qualified_name              ir ao estado 30


State 37

    9 type_declaration: UNION IDENTIFIER . discriminant union_body END_UNION
   53 discriminant: . %empty

    $padrão  reduzir usando a regra 53 (discriminant)

    discriminant  ir ao estado 55


State 38

    0 $accept: translation_unit $end .

    $padrão  aceitar


State 39

    4 declarations: declarations declaration .

    $padrão  reduzir usando a regra 4 (declarations)


State 40

   13 field_declaration: field_variable_declaration SEMICOLON .

    $padrão  reduzir usando a regra 13 (field_declaration)


State 41

   18 modifiers: modifiers modifier .

    $padrão  reduzir usando a regra 18 (modifiers)


State 42

   15 field_variable_declaration: modifiers type_specifier . variable_declarators
   41 variable_declarators: . variable_declarator
   42                     | . variable_declarators COMMA variable_declarator
   43 variable_declarator: . declarator_name
   44                    | . declarator_name ASSIGN variable_initializer
   45 declarator_name: . IDENTIFIER
   46                | . declarator_name L_SQ_PAREN R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 43

    variable_declarators  ir ao estado 56
    variable_declarator   ir ao estado 45
    declarator_name       ir ao estado 46


State 43

   45 declarator_name: IDENTIFIER .

    $padrão  reduzir usando a regra 45 (declarator_name)


State 44

   16 field_variable_declaration: type_specifier variable_declarators .  [SEMICOLON]
   42 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA  deslocar, e ir ao estado 57

    $padrão  reduzir usando a regra 16 (field_variable_declaration)


State 45

   41 variable_declarators: variable_declarator .

    $padrão  reduzir usando a regra 41 (variable_declarators)


State 46

   43 variable_declarator: declarator_name .  [COMMA, SEMICOLON]
   44                    | declarator_name . ASSIGN variable_initializer
   46 declarator_name: declarator_name . L_SQ_PAREN R_SQ_PAREN

    ASSIGN      deslocar, e ir ao estado 58
    L_SQ_PAREN  deslocar, e ir ao estado 59

    $padrão  reduzir usando a regra 43 (variable_declarator)


State 47

   25 dims: L_SQ_PAREN . expression_or_empty R_SQ_PAREN
   27 expression_or_empty: . expression
   28                    | . %empty  [R_SQ_PAREN]
   38 qualified_name: . IDENTIFIER qualified_name2
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    $padrão  reduzir usando a regra 28 (expression_or_empty)

    expression_or_empty             ir ao estado 71
    qualified_name                  ir ao estado 72
    expression                      ir ao estado 73
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 48

   22 type_specifier: type_name dims .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, IDENTIFIER, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   26 dims: dims . L_SQ_PAREN expression_or_empty R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 99

    $padrão  reduzir usando a regra 22 (type_specifier)


State 49

   57 enumerator: IDENTIFIER . ASSIGN expression
   58           | IDENTIFIER .  [COMMA, END_ENUM]

    ASSIGN  deslocar, e ir ao estado 100

    $padrão  reduzir usando a regra 58 (enumerator)


State 50

   10 type_declaration: ENUM IDENTIFIER enumerator_list . END_ENUM
   56 enumerator_list: enumerator_list . COMMA enumerator

    COMMA     deslocar, e ir ao estado 101
    END_ENUM  deslocar, e ir ao estado 102


State 51

   55 enumerator_list: enumerator .

    $padrão  reduzir usando a regra 55 (enumerator_list)


State 52

   39 qualified_name2: . %empty  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, IDENTIFIER, L_PAREN, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
   40                | . DOT IDENTIFIER qualified_name2
   40                | DOT IDENTIFIER . qualified_name2

    DOT  deslocar, e ir ao estado 34

    DOT       [reduzir usando a regra 39 (qualified_name2)]
    $padrão  reduzir usando a regra 39 (qualified_name2)

    qualified_name2  ir ao estado 103


State 53

    8 type_declaration: . STRUCT IDENTIFIER field_declarations END_STRUCT
    8                 | STRUCT IDENTIFIER field_declarations . END_STRUCT
    9                 | . UNION IDENTIFIER discriminant union_body END_UNION
   10                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   12 field_declarations: field_declarations . field_declaration
   13 field_declaration: . field_variable_declaration SEMICOLON
   14                  | . type_declaration
   15 field_variable_declaration: . modifiers type_specifier variable_declarators
   16                           | . type_specifier variable_declarators
   17 modifiers: . modifier
   18          | . modifiers modifier
   19 modifier: . CONST
   20         | . STATIC
   21 type_specifier: . type_name
   22               | . type_name dims
   23 type_name: . primitive_type
   24          | . qualified_name
   29 primitive_type: . AUTO
   30               | . BOOL
   31               | . CHAR
   32               | . DOUBLE
   33               | . FLOAT
   34               | . INT
   35               | . LONG
   36               | . SHORT
   37               | . STRING
   38 qualified_name: . IDENTIFIER qualified_name2

    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 6
    DOUBLE      deslocar, e ir ao estado 7
    ENUM        deslocar, e ir ao estado 8
    END_STRUCT  deslocar, e ir ao estado 104
    FLOAT       deslocar, e ir ao estado 9
    IDENTIFIER  deslocar, e ir ao estado 10
    INT         deslocar, e ir ao estado 11
    LONG        deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STRUCT      deslocar, e ir ao estado 15
    STATIC      deslocar, e ir ao estado 16
    UNION       deslocar, e ir ao estado 17

    type_declaration            ir ao estado 22
    field_declaration           ir ao estado 105
    field_variable_declaration  ir ao estado 24
    modifiers                   ir ao estado 25
    modifier                    ir ao estado 26
    type_specifier              ir ao estado 27
    type_name                   ir ao estado 28
    primitive_type              ir ao estado 29
    qualified_name              ir ao estado 30


State 54

   11 field_declarations: field_declaration .

    $padrão  reduzir usando a regra 11 (field_declarations)


State 55

    9 type_declaration: UNION IDENTIFIER discriminant . union_body END_UNION
   54 union_body: . %empty

    $padrão  reduzir usando a regra 54 (union_body)

    union_body  ir ao estado 106


State 56

   15 field_variable_declaration: modifiers type_specifier variable_declarators .  [SEMICOLON]
   42 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA  deslocar, e ir ao estado 57

    $padrão  reduzir usando a regra 15 (field_variable_declaration)


State 57

   42 variable_declarators: variable_declarators COMMA . variable_declarator
   43 variable_declarator: . declarator_name
   44                    | . declarator_name ASSIGN variable_initializer
   45 declarator_name: . IDENTIFIER
   46                | . declarator_name L_SQ_PAREN R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 43

    variable_declarator  ir ao estado 107
    declarator_name      ir ao estado 46


State 58

   38 qualified_name: . IDENTIFIER qualified_name2
   44 variable_declarator: declarator_name ASSIGN . variable_initializer
   47 variable_initializer: . expression
   48                     | . L_BRACE R_BRACE
   49                     | . L_BRACE array_initializers R_BRACE
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    L_BRACE             deslocar, e ir ao estado 108
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    variable_initializer            ir ao estado 109
    expression                      ir ao estado 110
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 59

   46 declarator_name: declarator_name L_SQ_PAREN . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 111


State 60

  127 complex_primary_no_parenthesis: BOOL_LITERAL .

    $padrão  reduzir usando a regra 127 (complex_primary_no_parenthesis)


State 61

   73 logical_unary_operator: BITWISE_COMPLEMENT .

    $padrão  reduzir usando a regra 73 (logical_unary_operator)


State 62

  129 complex_primary_no_parenthesis: DECIMAL .

    $padrão  reduzir usando a regra 129 (complex_primary_no_parenthesis)


State 63

  131 complex_primary_no_parenthesis: FLOATING_POINT .

    $padrão  reduzir usando a regra 131 (complex_primary_no_parenthesis)


State 64

  130 complex_primary_no_parenthesis: HEX .

    $padrão  reduzir usando a regra 130 (complex_primary_no_parenthesis)


State 65

   29 primitive_type: . AUTO
   30               | . BOOL
   31               | . CHAR
   32               | . DOUBLE
   33               | . FLOAT
   34               | . INT
   35               | . LONG
   36               | . SHORT
   37               | . STRING
   38 qualified_name: . IDENTIFIER qualified_name2
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  107                | L_PAREN . primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  108                | L_PAREN . user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  109                | L_PAREN . expression R_PAREN logical_unary_expression
  110 primitive_type_expression: . primitive_type
  111                          | . primitive_type dims
  112 user_type_expression: . qualified_name dims
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  125                | L_PAREN . expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    CHAR                deslocar, e ir ao estado 4
    DECIMAL             deslocar, e ir ao estado 62
    DOUBLE              deslocar, e ir ao estado 7
    FLOAT               deslocar, e ir ao estado 9
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    INT                 deslocar, e ir ao estado 11
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    LONG                deslocar, e ir ao estado 12
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STRING_LITERAL      deslocar, e ir ao estado 70

    primitive_type                  ir ao estado 112
    qualified_name                  ir ao estado 113
    expression                      ir ao estado 114
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    primitive_type_expression       ir ao estado 115
    user_type_expression            ir ao estado 116
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 66

   74 logical_unary_operator: LOG_NOT .

    $padrão  reduzir usando a regra 74 (logical_unary_operator)


State 67

   71 arithmetic_unary_operator: OP_PLUS .

    $padrão  reduzir usando a regra 71 (arithmetic_unary_operator)


State 68

   72 arithmetic_unary_operator: OP_MINUS .

    $padrão  reduzir usando a regra 72 (arithmetic_unary_operator)


State 69

  128 complex_primary_no_parenthesis: OCTAL .

    $padrão  reduzir usando a regra 128 (complex_primary_no_parenthesis)


State 70

  132 complex_primary_no_parenthesis: STRING_LITERAL .

    $padrão  reduzir usando a regra 132 (complex_primary_no_parenthesis)


State 71

   25 dims: L_SQ_PAREN expression_or_empty . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 117


State 72

   69 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  136 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  143 subprogram_access: qualified_name .  [L_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 118

    L_PAREN   reduzir usando a regra 143 (subprogram_access)
    $padrão  reduzir usando a regra 69 (primary_expression)


State 73

   27 expression_or_empty: expression .

    $padrão  reduzir usando a regra 27 (expression_or_empty)


State 74

   61 expression: assignment_expression .

    $padrão  reduzir usando a regra 61 (expression)


State 75

   63 assignment_expression: unary_expression . assignment_operator assignment_expression
  106 cast_expression: unary_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  113 assignment_operator: . ASSIGN
  114                    | . ASSIGN_PLUS
  115                    | . ASSIGN_MINUS
  116                    | . ASSIGN_PRODUCT
  117                    | . ASSIGN_DIV
  118                    | . ASSIGN_MOD
  119                    | . ASSIGN_BITWISE_AND
  120                    | . ASSIGN_BITWISE_OR
  121                    | . ASSIGN_BITWISE_OR_EXC
  122                    | . ASSIGN_L_SHIFT
  123                    | . ASSIGN_R_SHIFT

    ASSIGN                 deslocar, e ir ao estado 119
    ASSIGN_PLUS            deslocar, e ir ao estado 120
    ASSIGN_MINUS           deslocar, e ir ao estado 121
    ASSIGN_PRODUCT         deslocar, e ir ao estado 122
    ASSIGN_DIV             deslocar, e ir ao estado 123
    ASSIGN_MOD             deslocar, e ir ao estado 124
    ASSIGN_BITWISE_AND     deslocar, e ir ao estado 125
    ASSIGN_BITWISE_OR      deslocar, e ir ao estado 126
    ASSIGN_BITWISE_OR_EXC  deslocar, e ir ao estado 127
    ASSIGN_L_SHIFT         deslocar, e ir ao estado 128
    ASSIGN_R_SHIFT         deslocar, e ir ao estado 129

    $padrão  reduzir usando a regra 106 (cast_expression)

    assignment_operator  ir ao estado 130


State 76

   65 unary_expression: logical_unary_expression .

    $padrão  reduzir usando a regra 65 (unary_expression)


State 77

   66 logical_unary_expression: postfix_expression .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  139 field_access: postfix_expression . DOT IDENTIFIER

    DOT  deslocar, e ir ao estado 131

    $padrão  reduzir usando a regra 66 (logical_unary_expression)


State 78

   68 postfix_expression: primary_expression .

    $padrão  reduzir usando a regra 68 (postfix_expression)


State 79

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   64                 | arithmetic_unary_operator . cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    cast_expression                 ir ao estado 133
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 80

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   67                         | logical_unary_operator . unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 134
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 135
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 81

   62 assignment_expression: conditional_or_expression .  [COMMA, END_ENUM, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   76 conditional_or_expression: conditional_or_expression . LOG_OR conditional_and_expression
   77                          | conditional_or_expression . LOG_SC_OR conditional_and_expression

    LOG_OR     deslocar, e ir ao estado 136
    LOG_SC_OR  deslocar, e ir ao estado 137

    $padrão  reduzir usando a regra 62 (assignment_expression)


State 82

   75 conditional_or_expression: conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   79 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
   80                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 138
    LOG_SC_AND  deslocar, e ir ao estado 139

    $padrão  reduzir usando a regra 75 (conditional_or_expression)


State 83

   78 conditional_and_expression: inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   82 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 140

    $padrão  reduzir usando a regra 78 (conditional_and_expression)


State 84

   81 inclusive_or_expression: exclusive_or_expression .  [BITWISE_OR, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   84 exclusive_or_expression: exclusive_or_expression . BITWISE_OR_EXC and_expression

    BITWISE_OR_EXC  deslocar, e ir ao estado 141

    $padrão  reduzir usando a regra 81 (inclusive_or_expression)


State 85

   83 exclusive_or_expression: and_expression .  [BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   86 and_expression: and_expression . AMPERSAND equality_expression

    AMPERSAND  deslocar, e ir ao estado 142

    $padrão  reduzir usando a regra 83 (exclusive_or_expression)


State 86

   85 and_expression: equality_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   88 equality_expression: equality_expression . OP_EQ relational_expression
   89                    | equality_expression . OP_NE relational_expression

    OP_EQ  deslocar, e ir ao estado 143
    OP_NE  deslocar, e ir ao estado 144

    $padrão  reduzir usando a regra 85 (and_expression)


State 87

   87 equality_expression: relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   91 relational_expression: relational_expression . OP_LT shift_expression
   92                      | relational_expression . OP_GT shift_expression
   93                      | relational_expression . OP_LET shift_expression
   94                      | relational_expression . OP_GET shift_expression
   95                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 145
    OP_LT   deslocar, e ir ao estado 146
    OP_GET  deslocar, e ir ao estado 147
    OP_GT   deslocar, e ir ao estado 148
    TYPEOF  deslocar, e ir ao estado 149

    $padrão  reduzir usando a regra 87 (equality_expression)


State 88

   90 relational_expression: shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   97 shift_expression: shift_expression . L_SHIFT additive_expression
   98                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 150
    R_SHIFT  deslocar, e ir ao estado 151

    $padrão  reduzir usando a regra 90 (relational_expression)


State 89

   96 shift_expression: additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  100 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  101                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 152
    OP_MINUS  deslocar, e ir ao estado 153

    $padrão  reduzir usando a regra 96 (shift_expression)


State 90

   99 additive_expression: multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  103 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  104                          | multiplicative_expression . OP_DIV cast_expression
  105                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 154
    OP_DIV       deslocar, e ir ao estado 155
    OP_MOD       deslocar, e ir ao estado 156

    $padrão  reduzir usando a regra 99 (additive_expression)


State 91

  102 multiplicative_expression: cast_expression .

    $padrão  reduzir usando a regra 102 (multiplicative_expression)


State 92

   70 primary_expression: not_just_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  138 field_access: not_just_name . DOT IDENTIFIER

    DOT  deslocar, e ir ao estado 157

    DOT       [reduzir usando a regra 70 (primary_expression)]
    $padrão  reduzir usando a regra 70 (primary_expression)


State 93

  124 not_just_name: complex_primary .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  137 array_access: complex_primary . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 158

    $padrão  reduzir usando a regra 124 (not_just_name)


State 94

  126 complex_primary: complex_primary_no_parenthesis .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  142 subprogram_access: complex_primary_no_parenthesis .  [L_PAREN]

    L_PAREN   reduzir usando a regra 142 (subprogram_access)
    $padrão  reduzir usando a regra 126 (complex_primary)


State 95

  133 complex_primary_no_parenthesis: array_access .

    $padrão  reduzir usando a regra 133 (complex_primary_no_parenthesis)


State 96

  134 complex_primary_no_parenthesis: field_access .

    $padrão  reduzir usando a regra 134 (complex_primary_no_parenthesis)


State 97

  135 complex_primary_no_parenthesis: subprogram_call .

    $padrão  reduzir usando a regra 135 (complex_primary_no_parenthesis)


State 98

  140 subprogram_call: subprogram_access . L_PAREN argument_list R_PAREN
  141                | subprogram_access . L_PAREN R_PAREN

    L_PAREN  deslocar, e ir ao estado 159


State 99

   26 dims: dims L_SQ_PAREN . expression_or_empty R_SQ_PAREN
   27 expression_or_empty: . expression
   28                    | . %empty  [R_SQ_PAREN]
   38 qualified_name: . IDENTIFIER qualified_name2
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    $padrão  reduzir usando a regra 28 (expression_or_empty)

    expression_or_empty             ir ao estado 160
    qualified_name                  ir ao estado 72
    expression                      ir ao estado 73
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 100

   38 qualified_name: . IDENTIFIER qualified_name2
   57 enumerator: IDENTIFIER ASSIGN . expression
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    expression                      ir ao estado 161
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 101

   56 enumerator_list: enumerator_list COMMA . enumerator
   57 enumerator: . IDENTIFIER ASSIGN expression
   58           | . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 49

    enumerator  ir ao estado 162


State 102

   10 type_declaration: ENUM IDENTIFIER enumerator_list END_ENUM .

    $padrão  reduzir usando a regra 10 (type_declaration)


State 103

   40 qualified_name2: DOT IDENTIFIER qualified_name2 .

    $padrão  reduzir usando a regra 40 (qualified_name2)


State 104

    8 type_declaration: STRUCT IDENTIFIER field_declarations END_STRUCT .

    $padrão  reduzir usando a regra 8 (type_declaration)


State 105

   12 field_declarations: field_declarations field_declaration .

    $padrão  reduzir usando a regra 12 (field_declarations)


State 106

    9 type_declaration: UNION IDENTIFIER discriminant union_body . END_UNION

    END_UNION  deslocar, e ir ao estado 163


State 107

   42 variable_declarators: variable_declarators COMMA variable_declarator .

    $padrão  reduzir usando a regra 42 (variable_declarators)


State 108

   38 qualified_name: . IDENTIFIER qualified_name2
   47 variable_initializer: . expression
   48                     | . L_BRACE R_BRACE
   48                     | L_BRACE . R_BRACE
   49                     | . L_BRACE array_initializers R_BRACE
   49                     | L_BRACE . array_initializers R_BRACE
   50 array_initializers: . variable_initializer
   51                   | . array_initializers COMMA variable_initializer
   52                   | . array_initializers COMMA
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    L_BRACE             deslocar, e ir ao estado 108
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    R_BRACE             deslocar, e ir ao estado 164
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    variable_initializer            ir ao estado 165
    array_initializers              ir ao estado 166
    expression                      ir ao estado 110
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 109

   44 variable_declarator: declarator_name ASSIGN variable_initializer .

    $padrão  reduzir usando a regra 44 (variable_declarator)


State 110

   47 variable_initializer: expression .

    $padrão  reduzir usando a regra 47 (variable_initializer)


State 111

   46 declarator_name: declarator_name L_SQ_PAREN R_SQ_PAREN .

    $padrão  reduzir usando a regra 46 (declarator_name)


State 112

   25 dims: . L_SQ_PAREN expression_or_empty R_SQ_PAREN
   26     | . dims L_SQ_PAREN expression_or_empty R_SQ_PAREN
  110 primitive_type_expression: primitive_type .  [R_PAREN]
  111                          | primitive_type . dims

    L_SQ_PAREN  deslocar, e ir ao estado 47

    $padrão  reduzir usando a regra 110 (primitive_type_expression)

    dims  ir ao estado 167


State 113

   25 dims: . L_SQ_PAREN expression_or_empty R_SQ_PAREN
   26     | . dims L_SQ_PAREN expression_or_empty R_SQ_PAREN
   69 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SHIFT, TYPEOF]
  112 user_type_expression: qualified_name . dims
  136 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  143 subprogram_access: qualified_name .  [L_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 168

    L_PAREN   reduzir usando a regra 143 (subprogram_access)
    $padrão  reduzir usando a regra 69 (primary_expression)

    dims  ir ao estado 169


State 114

  109 cast_expression: L_PAREN expression . R_PAREN logical_unary_expression
  125 complex_primary: L_PAREN expression . R_PAREN

    R_PAREN  deslocar, e ir ao estado 170


State 115

  107 cast_expression: L_PAREN primitive_type_expression . R_PAREN cast_expression

    R_PAREN  deslocar, e ir ao estado 171


State 116

  108 cast_expression: L_PAREN user_type_expression . R_PAREN cast_expression

    R_PAREN  deslocar, e ir ao estado 172


State 117

   25 dims: L_SQ_PAREN expression_or_empty R_SQ_PAREN .

    $padrão  reduzir usando a regra 25 (dims)


State 118

   38 qualified_name: . IDENTIFIER qualified_name2
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  136             | qualified_name L_SQ_PAREN . expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    expression                      ir ao estado 173
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 119

  113 assignment_operator: ASSIGN .

    $padrão  reduzir usando a regra 113 (assignment_operator)


State 120

  114 assignment_operator: ASSIGN_PLUS .

    $padrão  reduzir usando a regra 114 (assignment_operator)


State 121

  115 assignment_operator: ASSIGN_MINUS .

    $padrão  reduzir usando a regra 115 (assignment_operator)


State 122

  116 assignment_operator: ASSIGN_PRODUCT .

    $padrão  reduzir usando a regra 116 (assignment_operator)


State 123

  117 assignment_operator: ASSIGN_DIV .

    $padrão  reduzir usando a regra 117 (assignment_operator)


State 124

  118 assignment_operator: ASSIGN_MOD .

    $padrão  reduzir usando a regra 118 (assignment_operator)


State 125

  119 assignment_operator: ASSIGN_BITWISE_AND .

    $padrão  reduzir usando a regra 119 (assignment_operator)


State 126

  120 assignment_operator: ASSIGN_BITWISE_OR .

    $padrão  reduzir usando a regra 120 (assignment_operator)


State 127

  121 assignment_operator: ASSIGN_BITWISE_OR_EXC .

    $padrão  reduzir usando a regra 121 (assignment_operator)


State 128

  122 assignment_operator: ASSIGN_L_SHIFT .

    $padrão  reduzir usando a regra 122 (assignment_operator)


State 129

  123 assignment_operator: ASSIGN_R_SHIFT .

    $padrão  reduzir usando a regra 123 (assignment_operator)


State 130

   38 qualified_name: . IDENTIFIER qualified_name2
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   63                      | unary_expression assignment_operator . assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    assignment_expression           ir ao estado 174
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 131

  139 field_access: postfix_expression DOT . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 175


State 132

  106 cast_expression: unary_expression .

    $padrão  reduzir usando a regra 106 (cast_expression)


State 133

   64 unary_expression: arithmetic_unary_operator cast_expression .

    $padrão  reduzir usando a regra 64 (unary_expression)


State 134

   38 qualified_name: . IDENTIFIER qualified_name2
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  125                | L_PAREN . expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    expression                      ir ao estado 176
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 135

   67 logical_unary_expression: logical_unary_operator unary_expression .

    $padrão  reduzir usando a regra 67 (logical_unary_expression)


State 136

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   76 conditional_or_expression: conditional_or_expression LOG_OR . conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_and_expression      ir ao estado 177
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 137

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   77 conditional_or_expression: conditional_or_expression LOG_SC_OR . conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_and_expression      ir ao estado 178
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 138

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   79 conditional_and_expression: conditional_and_expression LOG_AND . inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    inclusive_or_expression         ir ao estado 179
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 139

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   80 conditional_and_expression: conditional_and_expression LOG_SC_AND . inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    inclusive_or_expression         ir ao estado 180
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 140

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   82 inclusive_or_expression: inclusive_or_expression BITWISE_OR . exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    exclusive_or_expression         ir ao estado 181
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 141

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   84 exclusive_or_expression: exclusive_or_expression BITWISE_OR_EXC . and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    and_expression                  ir ao estado 182
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 142

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   86 and_expression: and_expression AMPERSAND . equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    equality_expression             ir ao estado 183
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 143

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   88 equality_expression: equality_expression OP_EQ . relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    relational_expression           ir ao estado 184
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 144

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   89 equality_expression: equality_expression OP_NE . relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    relational_expression           ir ao estado 185
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 145

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   93 relational_expression: relational_expression OP_LET . shift_expression
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    shift_expression                ir ao estado 186
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 146

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   91 relational_expression: relational_expression OP_LT . shift_expression
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    shift_expression                ir ao estado 187
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 147

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   94 relational_expression: relational_expression OP_GET . shift_expression
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    shift_expression                ir ao estado 188
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 148

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   92 relational_expression: relational_expression OP_GT . shift_expression
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    shift_expression                ir ao estado 189
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 149

   21 type_specifier: . type_name
   22               | . type_name dims
   23 type_name: . primitive_type
   24          | . qualified_name
   29 primitive_type: . AUTO
   30               | . BOOL
   31               | . CHAR
   32               | . DOUBLE
   33               | . FLOAT
   34               | . INT
   35               | . LONG
   36               | . SHORT
   37               | . STRING
   38 qualified_name: . IDENTIFIER qualified_name2
   95 relational_expression: relational_expression TYPEOF . type_specifier

    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 7
    FLOAT       deslocar, e ir ao estado 9
    IDENTIFIER  deslocar, e ir ao estado 10
    INT         deslocar, e ir ao estado 11
    LONG        deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 190
    type_name       ir ao estado 28
    primitive_type  ir ao estado 29
    qualified_name  ir ao estado 30


State 150

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   97 shift_expression: shift_expression L_SHIFT . additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    additive_expression             ir ao estado 191
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 151

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   98 shift_expression: shift_expression R_SHIFT . additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    additive_expression             ir ao estado 192
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 152

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
  100 additive_expression: additive_expression OP_PLUS . multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    multiplicative_expression       ir ao estado 193
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 153

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
  101 additive_expression: additive_expression OP_MINUS . multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    multiplicative_expression       ir ao estado 194
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 154

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
  103 multiplicative_expression: multiplicative_expression OP_ASTERISK . cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    cast_expression                 ir ao estado 195
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 155

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
  104 multiplicative_expression: multiplicative_expression OP_DIV . cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    cast_expression                 ir ao estado 196
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 156

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
  105 multiplicative_expression: multiplicative_expression OP_MOD . cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    cast_expression                 ir ao estado 197
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 157

  138 field_access: not_just_name DOT . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 198


State 158

   38 qualified_name: . IDENTIFIER qualified_name2
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  137             | complex_primary L_SQ_PAREN . expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    expression                      ir ao estado 199
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 159

   38 qualified_name: . IDENTIFIER qualified_name2
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  140                | subprogram_access L_PAREN . argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  141                | subprogram_access L_PAREN . R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name
  144 argument_list: . expression
  145              | . argument_list COMMA expression

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    R_PAREN             deslocar, e ir ao estado 200
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    expression                      ir ao estado 201
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98
    argument_list                   ir ao estado 202


State 160

   26 dims: dims L_SQ_PAREN expression_or_empty . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 203


State 161

   57 enumerator: IDENTIFIER ASSIGN expression .

    $padrão  reduzir usando a regra 57 (enumerator)


State 162

   56 enumerator_list: enumerator_list COMMA enumerator .

    $padrão  reduzir usando a regra 56 (enumerator_list)


State 163

    9 type_declaration: UNION IDENTIFIER discriminant union_body END_UNION .

    $padrão  reduzir usando a regra 9 (type_declaration)


State 164

   48 variable_initializer: L_BRACE R_BRACE .

    $padrão  reduzir usando a regra 48 (variable_initializer)


State 165

   50 array_initializers: variable_initializer .

    $padrão  reduzir usando a regra 50 (array_initializers)


State 166

   49 variable_initializer: L_BRACE array_initializers . R_BRACE
   51 array_initializers: array_initializers . COMMA variable_initializer
   52                   | array_initializers . COMMA

    COMMA    deslocar, e ir ao estado 204
    R_BRACE  deslocar, e ir ao estado 205


State 167

   26 dims: dims . L_SQ_PAREN expression_or_empty R_SQ_PAREN
  111 primitive_type_expression: primitive_type dims .  [R_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 99

    $padrão  reduzir usando a regra 111 (primitive_type_expression)


State 168

   25 dims: L_SQ_PAREN . expression_or_empty R_SQ_PAREN
   27 expression_or_empty: . expression
   28                    | . %empty  [R_SQ_PAREN]
   38 qualified_name: . IDENTIFIER qualified_name2
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  136             | qualified_name L_SQ_PAREN . expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    $padrão  reduzir usando a regra 28 (expression_or_empty)

    expression_or_empty             ir ao estado 71
    qualified_name                  ir ao estado 72
    expression                      ir ao estado 206
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 169

   26 dims: dims . L_SQ_PAREN expression_or_empty R_SQ_PAREN
  112 user_type_expression: qualified_name dims .  [R_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 99

    $padrão  reduzir usando a regra 112 (user_type_expression)


State 170

   38 qualified_name: . IDENTIFIER qualified_name2
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
  109 cast_expression: L_PAREN expression R_PAREN . logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  125                | L_PAREN expression R_PAREN .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 134
    LOG_NOT             deslocar, e ir ao estado 66
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    $padrão  reduzir usando a regra 125 (complex_primary)

    qualified_name                  ir ao estado 72
    logical_unary_expression        ir ao estado 207
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    logical_unary_operator          ir ao estado 80
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 171

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  107                | L_PAREN primitive_type_expression R_PAREN . cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    cast_expression                 ir ao estado 208
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 172

   38 qualified_name: . IDENTIFIER qualified_name2
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  108                | L_PAREN user_type_expression R_PAREN . cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    unary_expression                ir ao estado 132
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    cast_expression                 ir ao estado 209
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 173

  136 array_access: qualified_name L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 210


State 174

   63 assignment_expression: unary_expression assignment_operator assignment_expression .

    $padrão  reduzir usando a regra 63 (assignment_expression)


State 175

  139 field_access: postfix_expression DOT IDENTIFIER .

    $padrão  reduzir usando a regra 139 (field_access)


State 176

  125 complex_primary: L_PAREN expression . R_PAREN

    R_PAREN  deslocar, e ir ao estado 211


State 177

   76 conditional_or_expression: conditional_or_expression LOG_OR conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   79 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
   80                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 138
    LOG_SC_AND  deslocar, e ir ao estado 139

    $padrão  reduzir usando a regra 76 (conditional_or_expression)


State 178

   77 conditional_or_expression: conditional_or_expression LOG_SC_OR conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   79 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
   80                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 138
    LOG_SC_AND  deslocar, e ir ao estado 139

    $padrão  reduzir usando a regra 77 (conditional_or_expression)


State 179

   79 conditional_and_expression: conditional_and_expression LOG_AND inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   82 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 140

    $padrão  reduzir usando a regra 79 (conditional_and_expression)


State 180

   80 conditional_and_expression: conditional_and_expression LOG_SC_AND inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   82 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 140

    $padrão  reduzir usando a regra 80 (conditional_and_expression)


State 181

   82 inclusive_or_expression: inclusive_or_expression BITWISE_OR exclusive_or_expression .  [BITWISE_OR, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   84 exclusive_or_expression: exclusive_or_expression . BITWISE_OR_EXC and_expression

    BITWISE_OR_EXC  deslocar, e ir ao estado 141

    $padrão  reduzir usando a regra 82 (inclusive_or_expression)


State 182

   84 exclusive_or_expression: exclusive_or_expression BITWISE_OR_EXC and_expression .  [BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   86 and_expression: and_expression . AMPERSAND equality_expression

    AMPERSAND  deslocar, e ir ao estado 142

    $padrão  reduzir usando a regra 84 (exclusive_or_expression)


State 183

   86 and_expression: and_expression AMPERSAND equality_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   88 equality_expression: equality_expression . OP_EQ relational_expression
   89                    | equality_expression . OP_NE relational_expression

    OP_EQ  deslocar, e ir ao estado 143
    OP_NE  deslocar, e ir ao estado 144

    $padrão  reduzir usando a regra 86 (and_expression)


State 184

   88 equality_expression: equality_expression OP_EQ relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   91 relational_expression: relational_expression . OP_LT shift_expression
   92                      | relational_expression . OP_GT shift_expression
   93                      | relational_expression . OP_LET shift_expression
   94                      | relational_expression . OP_GET shift_expression
   95                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 145
    OP_LT   deslocar, e ir ao estado 146
    OP_GET  deslocar, e ir ao estado 147
    OP_GT   deslocar, e ir ao estado 148
    TYPEOF  deslocar, e ir ao estado 149

    $padrão  reduzir usando a regra 88 (equality_expression)


State 185

   89 equality_expression: equality_expression OP_NE relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
   91 relational_expression: relational_expression . OP_LT shift_expression
   92                      | relational_expression . OP_GT shift_expression
   93                      | relational_expression . OP_LET shift_expression
   94                      | relational_expression . OP_GET shift_expression
   95                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 145
    OP_LT   deslocar, e ir ao estado 146
    OP_GET  deslocar, e ir ao estado 147
    OP_GT   deslocar, e ir ao estado 148
    TYPEOF  deslocar, e ir ao estado 149

    $padrão  reduzir usando a regra 89 (equality_expression)


State 186

   93 relational_expression: relational_expression OP_LET shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   97 shift_expression: shift_expression . L_SHIFT additive_expression
   98                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 150
    R_SHIFT  deslocar, e ir ao estado 151

    $padrão  reduzir usando a regra 93 (relational_expression)


State 187

   91 relational_expression: relational_expression OP_LT shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   97 shift_expression: shift_expression . L_SHIFT additive_expression
   98                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 150
    R_SHIFT  deslocar, e ir ao estado 151

    $padrão  reduzir usando a regra 91 (relational_expression)


State 188

   94 relational_expression: relational_expression OP_GET shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   97 shift_expression: shift_expression . L_SHIFT additive_expression
   98                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 150
    R_SHIFT  deslocar, e ir ao estado 151

    $padrão  reduzir usando a regra 94 (relational_expression)


State 189

   92 relational_expression: relational_expression OP_GT shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
   97 shift_expression: shift_expression . L_SHIFT additive_expression
   98                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 150
    R_SHIFT  deslocar, e ir ao estado 151

    $padrão  reduzir usando a regra 92 (relational_expression)


State 190

   95 relational_expression: relational_expression TYPEOF type_specifier .

    $padrão  reduzir usando a regra 95 (relational_expression)


State 191

   97 shift_expression: shift_expression L_SHIFT additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  100 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  101                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 152
    OP_MINUS  deslocar, e ir ao estado 153

    $padrão  reduzir usando a regra 97 (shift_expression)


State 192

   98 shift_expression: shift_expression R_SHIFT additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  100 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  101                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 152
    OP_MINUS  deslocar, e ir ao estado 153

    $padrão  reduzir usando a regra 98 (shift_expression)


State 193

  100 additive_expression: additive_expression OP_PLUS multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  103 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  104                          | multiplicative_expression . OP_DIV cast_expression
  105                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 154
    OP_DIV       deslocar, e ir ao estado 155
    OP_MOD       deslocar, e ir ao estado 156

    $padrão  reduzir usando a regra 100 (additive_expression)


State 194

  101 additive_expression: additive_expression OP_MINUS multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  103 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  104                          | multiplicative_expression . OP_DIV cast_expression
  105                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 154
    OP_DIV       deslocar, e ir ao estado 155
    OP_MOD       deslocar, e ir ao estado 156

    $padrão  reduzir usando a regra 101 (additive_expression)


State 195

  103 multiplicative_expression: multiplicative_expression OP_ASTERISK cast_expression .

    $padrão  reduzir usando a regra 103 (multiplicative_expression)


State 196

  104 multiplicative_expression: multiplicative_expression OP_DIV cast_expression .

    $padrão  reduzir usando a regra 104 (multiplicative_expression)


State 197

  105 multiplicative_expression: multiplicative_expression OP_MOD cast_expression .

    $padrão  reduzir usando a regra 105 (multiplicative_expression)


State 198

  138 field_access: not_just_name DOT IDENTIFIER .

    $padrão  reduzir usando a regra 138 (field_access)


State 199

  137 array_access: complex_primary L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 212


State 200

  141 subprogram_call: subprogram_access L_PAREN R_PAREN .

    $padrão  reduzir usando a regra 141 (subprogram_call)


State 201

  144 argument_list: expression .

    $padrão  reduzir usando a regra 144 (argument_list)


State 202

  140 subprogram_call: subprogram_access L_PAREN argument_list . R_PAREN
  145 argument_list: argument_list . COMMA expression

    COMMA    deslocar, e ir ao estado 213
    R_PAREN  deslocar, e ir ao estado 214


State 203

   26 dims: dims L_SQ_PAREN expression_or_empty R_SQ_PAREN .

    $padrão  reduzir usando a regra 26 (dims)


State 204

   38 qualified_name: . IDENTIFIER qualified_name2
   47 variable_initializer: . expression
   48                     | . L_BRACE R_BRACE
   49                     | . L_BRACE array_initializers R_BRACE
   51 array_initializers: array_initializers COMMA . variable_initializer
   52                   | array_initializers COMMA .  [COMMA, R_BRACE]
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    L_BRACE             deslocar, e ir ao estado 108
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    $padrão  reduzir usando a regra 52 (array_initializers)

    qualified_name                  ir ao estado 72
    variable_initializer            ir ao estado 215
    expression                      ir ao estado 110
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 205

   49 variable_initializer: L_BRACE array_initializers R_BRACE .

    $padrão  reduzir usando a regra 49 (variable_initializer)


State 206

   27 expression_or_empty: expression .  [R_SQ_PAREN]
  136 array_access: qualified_name L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 210

    R_SQ_PAREN  [reduzir usando a regra 27 (expression_or_empty)]


State 207

  109 cast_expression: L_PAREN expression R_PAREN logical_unary_expression .

    $padrão  reduzir usando a regra 109 (cast_expression)


State 208

  107 cast_expression: L_PAREN primitive_type_expression R_PAREN cast_expression .

    $padrão  reduzir usando a regra 107 (cast_expression)


State 209

  108 cast_expression: L_PAREN user_type_expression R_PAREN cast_expression .

    $padrão  reduzir usando a regra 108 (cast_expression)


State 210

  136 array_access: qualified_name L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 136 (array_access)


State 211

  125 complex_primary: L_PAREN expression R_PAREN .

    $padrão  reduzir usando a regra 125 (complex_primary)


State 212

  137 array_access: complex_primary L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 137 (array_access)


State 213

   38 qualified_name: . IDENTIFIER qualified_name2
   61 expression: . assignment_expression
   62 assignment_expression: . conditional_or_expression
   63                      | . unary_expression assignment_operator assignment_expression
   64 unary_expression: . arithmetic_unary_operator cast_expression
   65                 | . logical_unary_expression
   66 logical_unary_expression: . postfix_expression
   67                         | . logical_unary_operator unary_expression
   68 postfix_expression: . primary_expression
   69 primary_expression: . qualified_name
   70                   | . not_just_name
   71 arithmetic_unary_operator: . OP_PLUS
   72                          | . OP_MINUS
   73 logical_unary_operator: . BITWISE_COMPLEMENT
   74                       | . LOG_NOT
   75 conditional_or_expression: . conditional_and_expression
   76                          | . conditional_or_expression LOG_OR conditional_and_expression
   77                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
   78 conditional_and_expression: . inclusive_or_expression
   79                           | . conditional_and_expression LOG_AND inclusive_or_expression
   80                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
   81 inclusive_or_expression: . exclusive_or_expression
   82                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
   83 exclusive_or_expression: . and_expression
   84                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
   85 and_expression: . equality_expression
   86               | . and_expression AMPERSAND equality_expression
   87 equality_expression: . relational_expression
   88                    | . equality_expression OP_EQ relational_expression
   89                    | . equality_expression OP_NE relational_expression
   90 relational_expression: . shift_expression
   91                      | . relational_expression OP_LT shift_expression
   92                      | . relational_expression OP_GT shift_expression
   93                      | . relational_expression OP_LET shift_expression
   94                      | . relational_expression OP_GET shift_expression
   95                      | . relational_expression TYPEOF type_specifier
   96 shift_expression: . additive_expression
   97                 | . shift_expression L_SHIFT additive_expression
   98                 | . shift_expression R_SHIFT additive_expression
   99 additive_expression: . multiplicative_expression
  100                    | . additive_expression OP_PLUS multiplicative_expression
  101                    | . additive_expression OP_MINUS multiplicative_expression
  102 multiplicative_expression: . cast_expression
  103                          | . multiplicative_expression OP_ASTERISK cast_expression
  104                          | . multiplicative_expression OP_DIV cast_expression
  105                          | . multiplicative_expression OP_MOD cast_expression
  106 cast_expression: . unary_expression
  107                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  108                | . L_PAREN user_type_expression R_PAREN cast_expression
  109                | . L_PAREN expression R_PAREN logical_unary_expression
  124 not_just_name: . complex_primary
  125 complex_primary: . L_PAREN expression R_PAREN
  126                | . complex_primary_no_parenthesis
  127 complex_primary_no_parenthesis: . BOOL_LITERAL
  128                               | . OCTAL
  129                               | . DECIMAL
  130                               | . HEX
  131                               | . FLOATING_POINT
  132                               | . STRING_LITERAL
  133                               | . array_access
  134                               | . field_access
  135                               | . subprogram_call
  136 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  137             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  138 field_access: . not_just_name DOT IDENTIFIER
  139             | . postfix_expression DOT IDENTIFIER
  140 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  141                | . subprogram_access L_PAREN R_PAREN
  142 subprogram_access: . complex_primary_no_parenthesis
  143                  | . qualified_name
  145 argument_list: argument_list COMMA . expression

    BOOL_LITERAL        deslocar, e ir ao estado 60
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 61
    DECIMAL             deslocar, e ir ao estado 62
    FLOATING_POINT      deslocar, e ir ao estado 63
    HEX                 deslocar, e ir ao estado 64
    IDENTIFIER          deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 65
    LOG_NOT             deslocar, e ir ao estado 66
    OP_PLUS             deslocar, e ir ao estado 67
    OP_MINUS            deslocar, e ir ao estado 68
    OCTAL               deslocar, e ir ao estado 69
    STRING_LITERAL      deslocar, e ir ao estado 70

    qualified_name                  ir ao estado 72
    expression                      ir ao estado 216
    assignment_expression           ir ao estado 74
    unary_expression                ir ao estado 75
    logical_unary_expression        ir ao estado 76
    postfix_expression              ir ao estado 77
    primary_expression              ir ao estado 78
    arithmetic_unary_operator       ir ao estado 79
    logical_unary_operator          ir ao estado 80
    conditional_or_expression       ir ao estado 81
    conditional_and_expression      ir ao estado 82
    inclusive_or_expression         ir ao estado 83
    exclusive_or_expression         ir ao estado 84
    and_expression                  ir ao estado 85
    equality_expression             ir ao estado 86
    relational_expression           ir ao estado 87
    shift_expression                ir ao estado 88
    additive_expression             ir ao estado 89
    multiplicative_expression       ir ao estado 90
    cast_expression                 ir ao estado 91
    not_just_name                   ir ao estado 92
    complex_primary                 ir ao estado 93
    complex_primary_no_parenthesis  ir ao estado 94
    array_access                    ir ao estado 95
    field_access                    ir ao estado 96
    subprogram_call                 ir ao estado 97
    subprogram_access               ir ao estado 98


State 214

  140 subprogram_call: subprogram_access L_PAREN argument_list R_PAREN .

    $padrão  reduzir usando a regra 140 (subprogram_call)


State 215

   51 array_initializers: array_initializers COMMA variable_initializer .

    $padrão  reduzir usando a regra 51 (array_initializers)


State 216

  145 argument_list: argument_list COMMA expression .

    $padrão  reduzir usando a regra 145 (argument_list)
