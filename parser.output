Terminais não utilizados na gramática

   OP_PTR
   SIZEOF


Gramática

    0 $accept: translation_unit $end

    1 translation_unit: program_file

    2 program_file: declarations

    3 declarations: declaration
    4             | declarations declaration

    5 declaration: function_declaration
    6            | procedure_declaration
    7            | type_declaration
    8            | variable_declaration

    9 function_declaration: FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION

   10 procedure_declaration: PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE

   11 subprogram_declarator: IDENTIFIER L_PAREN parameter_list R_PAREN
   12                      | IDENTIFIER L_PAREN R_PAREN

   13 parameter_list: parameter
   14               | parameter_list COMMA parameter

   15 parameter: type_specifier declarator_name
   16          | CONST type_specifier declarator_name

   17 subprogram_body: block
   18                | SEMICOLON

   19 block: local_variable_declarations_and_statements

   20 local_variable_declarations_and_statements: local_variable_declarations_or_statements
   21                                           | local_variable_declarations_and_statements local_variable_declarations_or_statements

   22 local_variable_declarations_or_statements: local_variable_declaration_statement
   23                                          | statement

   24 local_variable_declaration_statement: type_specifier variable_declarators SEMICOLON
   25                                     | STATIC type_specifier variable_declarators SEMICOLON

   26 statement: assignment_expression SEMICOLON
   27          | selection_statement
   28          | iteration_statement
   29          | jump_statement
   30          | read_statement
   31          | print_statement
   32          | println_statement

   33 selection_statement: IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | IF L_PAREN expression R_PAREN block END_IF

   36 elsif_staments: elsif_stament
   37               | elsif_staments ELSIF elsif_stament
   38               | ELSE block

   39 elsif_stament: L_PAREN expression R_PAREN block

   40 iteration_statement: WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | FOR L_PAREN for_init for_expr R_PAREN block END_FOR

   43 for_init: expression_statements SEMICOLON
   44         | local_variable_declaration_statement
   45         | SEMICOLON

   46 for_expr: expression SEMICOLON
   47         | SEMICOLON

   48 for_incr: expression_statements

   49 expression_statements: expression_statement
   50                      | expression_statements COMMA expression_statement

   51 expression_statement: expression

   52 jump_statement: BREAK IDENTIFIER SEMICOLON
   53               | BREAK SEMICOLON
   54               | CONTINUE IDENTIFIER SEMICOLON
   55               | CONTINUE SEMICOLON
   56               | RETURN expression SEMICOLON
   57               | RETURN SEMICOLON

   58 read_statement: READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON

   60 print_statement: PRINT L_PAREN expression R_PAREN SEMICOLON

   61 println_statement: PRINTLN L_PAREN expression R_PAREN SEMICOLON

   62 type_declaration: STRUCT IDENTIFIER variable_declarations END_STRUCT
   63                 | UNION IDENTIFIER discriminant union_body END_UNION
   64                 | ENUM IDENTIFIER enumerator_list END_ENUM

   65 variable_declarations: variable_declaration
   66                      | variable_declarations variable_declaration

   67 variable_declaration: modifiers type_specifier variable_declarators SEMICOLON
   68                     | type_specifier variable_declarators SEMICOLON

   69 modifiers: modifier
   70          | modifiers modifier

   71 modifier: CONST
   72         | STATIC

   73 type_specifier: type_name

   74 type_name: primitive_type
   75          | qualified_name

   76 primitive_type: AUTO
   77               | BOOL
   78               | CHAR
   79               | DOUBLE
   80               | FLOAT
   81               | INT
   82               | LONG
   83               | SHORT
   84               | STRING

   85 discriminant: L_PAREN type_specifier declarator_name R_PAREN
   86             | %empty

   87 enumerator_list: enumerator
   88                | enumerator_list COMMA enumerator

   89 enumerator: IDENTIFIER ASSIGN expression
   90           | IDENTIFIER

   91 qualified_name: IDENTIFIER

   92 union_body: variable_declarations short_case_statement
   93           | variable_declarations

   94 short_case_statement: CASE IDENTIFIER choices END_CASE

   95 choices: choice
   96        | choices choice

   97 choice: WHEN IDENTIFIER THEN variable_declarations

   98 variable_declarators: variable_declarator
   99                     | variable_declarators COMMA variable_declarator

  100 variable_declarator: declarator_name
  101                    | declarator_name ASSIGN variable_initializer

  102 declarator_name: IDENTIFIER
  103                | declarator_name L_SQ_PAREN expression R_SQ_PAREN

  104 variable_initializer: expression
  105                     | L_BRACE R_BRACE
  106                     | L_BRACE array_initializers R_BRACE

  107 array_initializers: variable_initializer
  108                   | array_initializers COMMA variable_initializer
  109                   | array_initializers COMMA

  110 expression: assignment_expression

  111 assignment_expression: conditional_or_expression
  112                      | unary_expression assignment_operator assignment_expression

  113 unary_expression: arithmetic_unary_operator cast_expression
  114                 | logical_unary_expression

  115 logical_unary_expression: postfix_expression
  116                         | logical_unary_operator unary_expression

  117 postfix_expression: primary_expression

  118 primary_expression: qualified_name
  119                   | not_just_name

  120 arithmetic_unary_operator: OP_PLUS
  121                          | OP_MINUS

  122 logical_unary_operator: BITWISE_COMPLEMENT
  123                       | LOG_NOT

  124 conditional_or_expression: conditional_and_expression
  125                          | conditional_or_expression LOG_OR conditional_and_expression
  126                          | conditional_or_expression LOG_SC_OR conditional_and_expression

  127 conditional_and_expression: inclusive_or_expression
  128                           | conditional_and_expression LOG_AND inclusive_or_expression
  129                           | conditional_and_expression LOG_SC_AND inclusive_or_expression

  130 inclusive_or_expression: exclusive_or_expression
  131                        | inclusive_or_expression BITWISE_OR exclusive_or_expression

  132 exclusive_or_expression: and_expression
  133                        | exclusive_or_expression BITWISE_OR_EXC and_expression

  134 and_expression: equality_expression
  135               | and_expression AMPERSAND equality_expression

  136 equality_expression: relational_expression
  137                    | equality_expression OP_EQ relational_expression
  138                    | equality_expression OP_NE relational_expression

  139 relational_expression: shift_expression
  140                      | relational_expression OP_LT shift_expression
  141                      | relational_expression OP_GT shift_expression
  142                      | relational_expression OP_LET shift_expression
  143                      | relational_expression OP_GET shift_expression
  144                      | relational_expression TYPEOF type_specifier

  145 shift_expression: additive_expression
  146                 | shift_expression L_SHIFT additive_expression
  147                 | shift_expression R_SHIFT additive_expression

  148 additive_expression: multiplicative_expression
  149                    | additive_expression OP_PLUS multiplicative_expression
  150                    | additive_expression OP_MINUS multiplicative_expression

  151 multiplicative_expression: cast_expression
  152                          | multiplicative_expression OP_ASTERISK cast_expression
  153                          | multiplicative_expression OP_DIV cast_expression
  154                          | multiplicative_expression OP_MOD cast_expression

  155 cast_expression: unary_expression
  156                | L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | L_PAREN user_type_expression R_PAREN cast_expression
  158                | L_PAREN expression R_PAREN logical_unary_expression

  159 primitive_type_expression: primitive_type
  160                          | primitive_type dims

  161 user_type_expression: qualified_name dims

  162 assignment_operator: ASSIGN
  163                    | ASSIGN_PLUS
  164                    | ASSIGN_MINUS
  165                    | ASSIGN_PRODUCT
  166                    | ASSIGN_DIV
  167                    | ASSIGN_MOD
  168                    | ASSIGN_BITWISE_AND
  169                    | ASSIGN_BITWISE_OR
  170                    | ASSIGN_BITWISE_OR_EXC
  171                    | ASSIGN_L_SHIFT
  172                    | ASSIGN_R_SHIFT

  173 not_just_name: complex_primary

  174 complex_primary: L_PAREN expression R_PAREN
  175                | complex_primary_no_parenthesis

  176 complex_primary_no_parenthesis: BOOL_LITERAL
  177                               | OCTAL
  178                               | DECIMAL
  179                               | HEX
  180                               | FLOATING_POINT
  181                               | NNULL
  182                               | STRING_LITERAL
  183                               | CHAR_LITERAL
  184                               | array_access
  185                               | field_access
  186                               | subprogram_call

  187 array_access: qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | complex_primary L_SQ_PAREN expression R_SQ_PAREN

  189 field_access: postfix_expression DOT IDENTIFIER

  190 subprogram_call: subprogram_access L_PAREN argument_list R_PAREN
  191                | subprogram_access L_PAREN R_PAREN

  192 subprogram_access: complex_primary_no_parenthesis
  193                  | qualified_name

  194 argument_list: expression
  195              | argument_list COMMA expression

  196 dims: L_SQ_PAREN R_SQ_PAREN
  197     | dims L_SQ_PAREN R_SQ_PAREN


Terminais, com as regras onde eles aparecem

$end (0) 0
error (256)
IDENTIFIER (258) 11 12 52 54 62 63 64 89 90 91 94 97 102 189
STRING_LITERAL (259) 58 59 182
DECIMAL (260) 178
HEX (261) 179
OCTAL (262) 177
FLOATING_POINT (263) 180
BOOL_LITERAL (264) 176
CHAR_LITERAL (265) 183
ASSIGN (266) 89 101 162
ASSIGN_PLUS (267) 163
ASSIGN_MINUS (268) 164
ASSIGN_PRODUCT (269) 165
ASSIGN_DIV (270) 166
ASSIGN_MOD (271) 167
ASSIGN_BITWISE_AND (272) 168
ASSIGN_BITWISE_OR (273) 169
ASSIGN_BITWISE_OR_EXC (274) 170
ASSIGN_L_SHIFT (275) 171
ASSIGN_R_SHIFT (276) 172
AMPERSAND (277) 135
AUTO (278) 76
BOOL (279) 77
BREAK (280) 52 53
BITWISE_COMPLEMENT (281) 122
BITWISE_OR (282) 131
BITWISE_OR_EXC (283) 133
CASE (284) 94
CHAR (285) 78
COMMA (286) 14 50 58 88 99 108 109 195
CONTINUE (287) 54 55
CONST (288) 16 71
DOT (289) 189
DOUBLE (290) 79
ENUM (291) 64
ELSE (292) 34 38
ELSIF (293) 33 37
END_CASE (294) 94
END_ENUM (295) 64
END_FOR (296) 41 42
END_FUNCTION (297) 9
END_IF (298) 33 34 35
END_PROCEDURE (299) 10
END_STRUCT (300) 62
END_UNION (301) 63
END_WHILE (302) 40
FLOAT (303) 80
FOR (304) 41 42
FUNCTION (305) 9
IF (306) 33 34 35
INT (307) 81
L_PAREN (308) 11 12 33 34 35 39 40 41 42 58 59 60 61 85 156 157 158
    174 190 191
L_SQ_PAREN (309) 103 187 188 196 197
L_BRACE (310) 105 106
L_SHIFT (311) 146
LOG_NOT (312) 123
LOG_AND (313) 128
LOG_OR (314) 125
LOG_SC_AND (315) 129
LOG_SC_OR (316) 126
LONG (317) 82
NNULL (318) 181
OP_EQ (319) 137
OP_NE (320) 138
OP_PTR (321)
OP_PLUS (322) 120 149
OP_MINUS (323) 121 150
OP_ASTERISK (324) 152
OP_DIV (325) 153
OP_MOD (326) 154
OP_LET (327) 142
OP_LT (328) 140
OP_GET (329) 143
OP_GT (330) 141
PRINT (331) 60
PRINTLN (332) 61
PROCEDURE (333) 10
READ (334) 58 59
RETURN (335) 56 57
R_PAREN (336) 11 12 33 34 35 39 40 41 42 58 59 60 61 85 156 157 158
    174 190 191
R_SQ_PAREN (337) 103 187 188 196 197
R_BRACE (338) 105 106
R_SHIFT (339) 147
SHORT (340) 83
STRING (341) 84
STRUCT (342) 62
STATIC (343) 25 72
SIZEOF (344)
SEMICOLON (345) 18 24 25 26 43 45 46 47 52 53 54 55 56 57 58 59 60
    61 67 68
THEN (346) 97
TYPEOF (347) 144
UNION (348) 63
WHEN (349) 97
WHILE (350) 40


Não-terminais com as regras onde eles aparecem

$accept (96)
    à esquerda: 0
translation_unit (97)
    à esquerda: 1, à direita: 0
program_file (98)
    à esquerda: 2, à direita: 1
declarations (99)
    à esquerda: 3 4, à direita: 2 4
declaration (100)
    à esquerda: 5 6 7 8, à direita: 3 4
function_declaration (101)
    à esquerda: 9, à direita: 5
procedure_declaration (102)
    à esquerda: 10, à direita: 6
subprogram_declarator (103)
    à esquerda: 11 12, à direita: 9 10
parameter_list (104)
    à esquerda: 13 14, à direita: 11 14
parameter (105)
    à esquerda: 15 16, à direita: 13 14
subprogram_body (106)
    à esquerda: 17 18, à direita: 9 10
block (107)
    à esquerda: 19, à direita: 17 33 34 35 38 39 40 41 42
local_variable_declarations_and_statements (108)
    à esquerda: 20 21, à direita: 19 21
local_variable_declarations_or_statements (109)
    à esquerda: 22 23, à direita: 20 21
local_variable_declaration_statement (110)
    à esquerda: 24 25, à direita: 22 44
statement (111)
    à esquerda: 26 27 28 29 30 31 32, à direita: 23
selection_statement (112)
    à esquerda: 33 34 35, à direita: 27
elsif_staments (113)
    à esquerda: 36 37 38, à direita: 33 37
elsif_stament (114)
    à esquerda: 39, à direita: 36 37
iteration_statement (115)
    à esquerda: 40 41 42, à direita: 28
for_init (116)
    à esquerda: 43 44 45, à direita: 41 42
for_expr (117)
    à esquerda: 46 47, à direita: 41 42
for_incr (118)
    à esquerda: 48, à direita: 41
expression_statements (119)
    à esquerda: 49 50, à direita: 43 48 50
expression_statement (120)
    à esquerda: 51, à direita: 49 50
jump_statement (121)
    à esquerda: 52 53 54 55 56 57, à direita: 29
read_statement (122)
    à esquerda: 58 59, à direita: 30
print_statement (123)
    à esquerda: 60, à direita: 31
println_statement (124)
    à esquerda: 61, à direita: 32
type_declaration (125)
    à esquerda: 62 63 64, à direita: 7
variable_declarations (126)
    à esquerda: 65 66, à direita: 62 66 92 93 97
variable_declaration (127)
    à esquerda: 67 68, à direita: 8 65 66
modifiers (128)
    à esquerda: 69 70, à direita: 67 70
modifier (129)
    à esquerda: 71 72, à direita: 69 70
type_specifier (130)
    à esquerda: 73, à direita: 9 15 16 24 25 67 68 85 144
type_name (131)
    à esquerda: 74 75, à direita: 73
primitive_type (132)
    à esquerda: 76 77 78 79 80 81 82 83 84, à direita: 74 159 160
discriminant (133)
    à esquerda: 85 86, à direita: 63
enumerator_list (134)
    à esquerda: 87 88, à direita: 64 88
enumerator (135)
    à esquerda: 89 90, à direita: 87 88
qualified_name (136)
    à esquerda: 91, à direita: 75 118 161 187 193
union_body (137)
    à esquerda: 92 93, à direita: 63
short_case_statement (138)
    à esquerda: 94, à direita: 92
choices (139)
    à esquerda: 95 96, à direita: 94 96
choice (140)
    à esquerda: 97, à direita: 95 96
variable_declarators (141)
    à esquerda: 98 99, à direita: 24 25 67 68 99
variable_declarator (142)
    à esquerda: 100 101, à direita: 98 99
declarator_name (143)
    à esquerda: 102 103, à direita: 15 16 85 100 101 103
variable_initializer (144)
    à esquerda: 104 105 106, à direita: 101 107 108
array_initializers (145)
    à esquerda: 107 108 109, à direita: 106 108 109
expression (146)
    à esquerda: 110, à direita: 33 34 35 39 40 46 51 56 60 61 89
    103 104 158 174 187 188 194 195
assignment_expression (147)
    à esquerda: 111 112, à direita: 26 110 112
unary_expression (148)
    à esquerda: 113 114, à direita: 112 116 155
logical_unary_expression (149)
    à esquerda: 115 116, à direita: 114 158
postfix_expression (150)
    à esquerda: 117, à direita: 115 189
primary_expression (151)
    à esquerda: 118 119, à direita: 117
arithmetic_unary_operator (152)
    à esquerda: 120 121, à direita: 113
logical_unary_operator (153)
    à esquerda: 122 123, à direita: 116
conditional_or_expression (154)
    à esquerda: 124 125 126, à direita: 111 125 126
conditional_and_expression (155)
    à esquerda: 127 128 129, à direita: 124 125 126 128 129
inclusive_or_expression (156)
    à esquerda: 130 131, à direita: 127 128 129 131
exclusive_or_expression (157)
    à esquerda: 132 133, à direita: 130 131 133
and_expression (158)
    à esquerda: 134 135, à direita: 132 133 135
equality_expression (159)
    à esquerda: 136 137 138, à direita: 134 135 137 138
relational_expression (160)
    à esquerda: 139 140 141 142 143 144, à direita: 136 137 138 140
    141 142 143 144
shift_expression (161)
    à esquerda: 145 146 147, à direita: 139 140 141 142 143 146 147
additive_expression (162)
    à esquerda: 148 149 150, à direita: 145 146 147 149 150
multiplicative_expression (163)
    à esquerda: 151 152 153 154, à direita: 148 149 150 152 153 154
cast_expression (164)
    à esquerda: 155 156 157 158, à direita: 113 151 152 153 154 156
    157
primitive_type_expression (165)
    à esquerda: 159 160, à direita: 156
user_type_expression (166)
    à esquerda: 161, à direita: 157
assignment_operator (167)
    à esquerda: 162 163 164 165 166 167 168 169 170 171 172, à direita:
    112
not_just_name (168)
    à esquerda: 173, à direita: 119
complex_primary (169)
    à esquerda: 174 175, à direita: 173 188
complex_primary_no_parenthesis (170)
    à esquerda: 176 177 178 179 180 181 182 183 184 185 186, à direita:
    175 192
array_access (171)
    à esquerda: 187 188, à direita: 184
field_access (172)
    à esquerda: 189, à direita: 185
subprogram_call (173)
    à esquerda: 190 191, à direita: 186
subprogram_access (174)
    à esquerda: 192 193, à direita: 190 191
argument_list (175)
    à esquerda: 194 195, à direita: 58 190 195
dims (176)
    à esquerda: 196 197, à direita: 160 161 197


State 0

    0 $accept: . translation_unit $end
    1 translation_unit: . program_file
    2 program_file: . declarations
    3 declarations: . declaration
    4             | . declarations declaration
    5 declaration: . function_declaration
    6            | . procedure_declaration
    7            | . type_declaration
    8            | . variable_declaration
    9 function_declaration: . FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION
   10 procedure_declaration: . PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE
   62 type_declaration: . STRUCT IDENTIFIER variable_declarations END_STRUCT
   63                 | . UNION IDENTIFIER discriminant union_body END_UNION
   64                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    ENUM        deslocar, e ir ao estado 7
    FLOAT       deslocar, e ir ao estado 8
    FUNCTION    deslocar, e ir ao estado 9
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    PROCEDURE   deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STRUCT      deslocar, e ir ao estado 15
    STATIC      deslocar, e ir ao estado 16
    UNION       deslocar, e ir ao estado 17

    translation_unit       ir ao estado 18
    program_file           ir ao estado 19
    declarations           ir ao estado 20
    declaration            ir ao estado 21
    function_declaration   ir ao estado 22
    procedure_declaration  ir ao estado 23
    type_declaration       ir ao estado 24
    variable_declaration   ir ao estado 25
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31


State 1

   91 qualified_name: IDENTIFIER .

    $padrão  reduzir usando a regra 91 (qualified_name)


State 2

   76 primitive_type: AUTO .

    $padrão  reduzir usando a regra 76 (primitive_type)


State 3

   77 primitive_type: BOOL .

    $padrão  reduzir usando a regra 77 (primitive_type)


State 4

   78 primitive_type: CHAR .

    $padrão  reduzir usando a regra 78 (primitive_type)


State 5

   71 modifier: CONST .

    $padrão  reduzir usando a regra 71 (modifier)


State 6

   79 primitive_type: DOUBLE .

    $padrão  reduzir usando a regra 79 (primitive_type)


State 7

   64 type_declaration: ENUM . IDENTIFIER enumerator_list END_ENUM

    IDENTIFIER  deslocar, e ir ao estado 32


State 8

   80 primitive_type: FLOAT .

    $padrão  reduzir usando a regra 80 (primitive_type)


State 9

    9 function_declaration: FUNCTION . type_specifier subprogram_declarator subprogram_body END_FUNCTION
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 33
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 10

   81 primitive_type: INT .

    $padrão  reduzir usando a regra 81 (primitive_type)


State 11

   82 primitive_type: LONG .

    $padrão  reduzir usando a regra 82 (primitive_type)


State 12

   10 procedure_declaration: PROCEDURE . subprogram_declarator subprogram_body END_PROCEDURE
   11 subprogram_declarator: . IDENTIFIER L_PAREN parameter_list R_PAREN
   12                      | . IDENTIFIER L_PAREN R_PAREN

    IDENTIFIER  deslocar, e ir ao estado 34

    subprogram_declarator  ir ao estado 35


State 13

   83 primitive_type: SHORT .

    $padrão  reduzir usando a regra 83 (primitive_type)


State 14

   84 primitive_type: STRING .

    $padrão  reduzir usando a regra 84 (primitive_type)


State 15

   62 type_declaration: STRUCT . IDENTIFIER variable_declarations END_STRUCT

    IDENTIFIER  deslocar, e ir ao estado 36


State 16

   72 modifier: STATIC .

    $padrão  reduzir usando a regra 72 (modifier)


State 17

   63 type_declaration: UNION . IDENTIFIER discriminant union_body END_UNION

    IDENTIFIER  deslocar, e ir ao estado 37


State 18

    0 $accept: translation_unit . $end

    $end  deslocar, e ir ao estado 38


State 19

    1 translation_unit: program_file .

    $padrão  reduzir usando a regra 1 (translation_unit)


State 20

    2 program_file: declarations .  [$end]
    4 declarations: declarations . declaration
    5 declaration: . function_declaration
    6            | . procedure_declaration
    7            | . type_declaration
    8            | . variable_declaration
    9 function_declaration: . FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION
   10 procedure_declaration: . PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE
   62 type_declaration: . STRUCT IDENTIFIER variable_declarations END_STRUCT
   63                 | . UNION IDENTIFIER discriminant union_body END_UNION
   64                 | . ENUM IDENTIFIER enumerator_list END_ENUM
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    ENUM        deslocar, e ir ao estado 7
    FLOAT       deslocar, e ir ao estado 8
    FUNCTION    deslocar, e ir ao estado 9
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    PROCEDURE   deslocar, e ir ao estado 12
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STRUCT      deslocar, e ir ao estado 15
    STATIC      deslocar, e ir ao estado 16
    UNION       deslocar, e ir ao estado 17

    $padrão  reduzir usando a regra 2 (program_file)

    declaration            ir ao estado 39
    function_declaration   ir ao estado 22
    procedure_declaration  ir ao estado 23
    type_declaration       ir ao estado 24
    variable_declaration   ir ao estado 25
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31


State 21

    3 declarations: declaration .

    $padrão  reduzir usando a regra 3 (declarations)


State 22

    5 declaration: function_declaration .

    $padrão  reduzir usando a regra 5 (declaration)


State 23

    6 declaration: procedure_declaration .

    $padrão  reduzir usando a regra 6 (declaration)


State 24

    7 declaration: type_declaration .

    $padrão  reduzir usando a regra 7 (declaration)


State 25

    8 declaration: variable_declaration .

    $padrão  reduzir usando a regra 8 (declaration)


State 26

   67 variable_declaration: modifiers . type_specifier variable_declarators SEMICOLON
   70 modifiers: modifiers . modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    modifier        ir ao estado 40
    type_specifier  ir ao estado 41
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 27

   69 modifiers: modifier .

    $padrão  reduzir usando a regra 69 (modifiers)


State 28

   68 variable_declaration: type_specifier . variable_declarators SEMICOLON
   98 variable_declarators: . variable_declarator
   99                     | . variable_declarators COMMA variable_declarator
  100 variable_declarator: . declarator_name
  101                    | . declarator_name ASSIGN variable_initializer
  102 declarator_name: . IDENTIFIER
  103                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    variable_declarators  ir ao estado 43
    variable_declarator   ir ao estado 44
    declarator_name       ir ao estado 45


State 29

   73 type_specifier: type_name .

    $padrão  reduzir usando a regra 73 (type_specifier)


State 30

   74 type_name: primitive_type .

    $padrão  reduzir usando a regra 74 (type_name)


State 31

   75 type_name: qualified_name .

    $padrão  reduzir usando a regra 75 (type_name)


State 32

   64 type_declaration: ENUM IDENTIFIER . enumerator_list END_ENUM
   87 enumerator_list: . enumerator
   88                | . enumerator_list COMMA enumerator
   89 enumerator: . IDENTIFIER ASSIGN expression
   90           | . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 46

    enumerator_list  ir ao estado 47
    enumerator       ir ao estado 48


State 33

    9 function_declaration: FUNCTION type_specifier . subprogram_declarator subprogram_body END_FUNCTION
   11 subprogram_declarator: . IDENTIFIER L_PAREN parameter_list R_PAREN
   12                      | . IDENTIFIER L_PAREN R_PAREN

    IDENTIFIER  deslocar, e ir ao estado 34

    subprogram_declarator  ir ao estado 49


State 34

   11 subprogram_declarator: IDENTIFIER . L_PAREN parameter_list R_PAREN
   12                      | IDENTIFIER . L_PAREN R_PAREN

    L_PAREN  deslocar, e ir ao estado 50


State 35

   10 procedure_declaration: PROCEDURE subprogram_declarator . subprogram_body END_PROCEDURE
   17 subprogram_body: . block
   18                | . SEMICOLON
   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 58
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 60
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 61
    IF                  deslocar, e ir ao estado 62
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    PRINT               deslocar, e ir ao estado 68
    PRINTLN             deslocar, e ir ao estado 69
    READ                deslocar, e ir ao estado 70
    RETURN              deslocar, e ir ao estado 71
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    SEMICOLON           deslocar, e ir ao estado 73
    WHILE               deslocar, e ir ao estado 74

    subprogram_body                             ir ao estado 75
    block                                       ir ao estado 76
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 36

   62 type_declaration: STRUCT IDENTIFIER . variable_declarations END_STRUCT
   65 variable_declarations: . variable_declaration
   66                      | . variable_declarations variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    variable_declarations  ir ao estado 114
    variable_declaration   ir ao estado 115
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31


State 37

   63 type_declaration: UNION IDENTIFIER . discriminant union_body END_UNION
   85 discriminant: . L_PAREN type_specifier declarator_name R_PAREN
   86             | . %empty  [IDENTIFIER, AUTO, BOOL, CHAR, CONST, DOUBLE, FLOAT, INT, LONG, SHORT, STRING, STATIC]

    L_PAREN  deslocar, e ir ao estado 116

    $padrão  reduzir usando a regra 86 (discriminant)

    discriminant  ir ao estado 117


State 38

    0 $accept: translation_unit $end .

    $padrão  aceitar


State 39

    4 declarations: declarations declaration .

    $padrão  reduzir usando a regra 4 (declarations)


State 40

   70 modifiers: modifiers modifier .

    $padrão  reduzir usando a regra 70 (modifiers)


State 41

   67 variable_declaration: modifiers type_specifier . variable_declarators SEMICOLON
   98 variable_declarators: . variable_declarator
   99                     | . variable_declarators COMMA variable_declarator
  100 variable_declarator: . declarator_name
  101                    | . declarator_name ASSIGN variable_initializer
  102 declarator_name: . IDENTIFIER
  103                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    variable_declarators  ir ao estado 118
    variable_declarator   ir ao estado 44
    declarator_name       ir ao estado 45


State 42

  102 declarator_name: IDENTIFIER .

    $padrão  reduzir usando a regra 102 (declarator_name)


State 43

   68 variable_declaration: type_specifier variable_declarators . SEMICOLON
   99 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 119
    SEMICOLON  deslocar, e ir ao estado 120


State 44

   98 variable_declarators: variable_declarator .

    $padrão  reduzir usando a regra 98 (variable_declarators)


State 45

  100 variable_declarator: declarator_name .  [COMMA, SEMICOLON]
  101                    | declarator_name . ASSIGN variable_initializer
  103 declarator_name: declarator_name . L_SQ_PAREN expression R_SQ_PAREN

    ASSIGN      deslocar, e ir ao estado 121
    L_SQ_PAREN  deslocar, e ir ao estado 122

    $padrão  reduzir usando a regra 100 (variable_declarator)


State 46

   89 enumerator: IDENTIFIER . ASSIGN expression
   90           | IDENTIFIER .  [COMMA, END_ENUM]

    ASSIGN  deslocar, e ir ao estado 123

    $padrão  reduzir usando a regra 90 (enumerator)


State 47

   64 type_declaration: ENUM IDENTIFIER enumerator_list . END_ENUM
   88 enumerator_list: enumerator_list . COMMA enumerator

    COMMA     deslocar, e ir ao estado 124
    END_ENUM  deslocar, e ir ao estado 125


State 48

   87 enumerator_list: enumerator .

    $padrão  reduzir usando a regra 87 (enumerator_list)


State 49

    9 function_declaration: FUNCTION type_specifier subprogram_declarator . subprogram_body END_FUNCTION
   17 subprogram_body: . block
   18                | . SEMICOLON
   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 58
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 60
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 61
    IF                  deslocar, e ir ao estado 62
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    PRINT               deslocar, e ir ao estado 68
    PRINTLN             deslocar, e ir ao estado 69
    READ                deslocar, e ir ao estado 70
    RETURN              deslocar, e ir ao estado 71
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    SEMICOLON           deslocar, e ir ao estado 73
    WHILE               deslocar, e ir ao estado 74

    subprogram_body                             ir ao estado 126
    block                                       ir ao estado 76
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 50

   11 subprogram_declarator: IDENTIFIER L_PAREN . parameter_list R_PAREN
   12                      | IDENTIFIER L_PAREN . R_PAREN
   13 parameter_list: . parameter
   14               | . parameter_list COMMA parameter
   15 parameter: . type_specifier declarator_name
   16          | . CONST type_specifier declarator_name
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 127
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    R_PAREN     deslocar, e ir ao estado 128
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    parameter_list  ir ao estado 129
    parameter       ir ao estado 130
    type_specifier  ir ao estado 131
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 51

  182 complex_primary_no_parenthesis: STRING_LITERAL .

    $padrão  reduzir usando a regra 182 (complex_primary_no_parenthesis)


State 52

  178 complex_primary_no_parenthesis: DECIMAL .

    $padrão  reduzir usando a regra 178 (complex_primary_no_parenthesis)


State 53

  179 complex_primary_no_parenthesis: HEX .

    $padrão  reduzir usando a regra 179 (complex_primary_no_parenthesis)


State 54

  177 complex_primary_no_parenthesis: OCTAL .

    $padrão  reduzir usando a regra 177 (complex_primary_no_parenthesis)


State 55

  180 complex_primary_no_parenthesis: FLOATING_POINT .

    $padrão  reduzir usando a regra 180 (complex_primary_no_parenthesis)


State 56

  176 complex_primary_no_parenthesis: BOOL_LITERAL .

    $padrão  reduzir usando a regra 176 (complex_primary_no_parenthesis)


State 57

  183 complex_primary_no_parenthesis: CHAR_LITERAL .

    $padrão  reduzir usando a regra 183 (complex_primary_no_parenthesis)


State 58

   52 jump_statement: BREAK . IDENTIFIER SEMICOLON
   53               | BREAK . SEMICOLON

    IDENTIFIER  deslocar, e ir ao estado 132
    SEMICOLON   deslocar, e ir ao estado 133


State 59

  122 logical_unary_operator: BITWISE_COMPLEMENT .

    $padrão  reduzir usando a regra 122 (logical_unary_operator)


State 60

   54 jump_statement: CONTINUE . IDENTIFIER SEMICOLON
   55               | CONTINUE . SEMICOLON

    IDENTIFIER  deslocar, e ir ao estado 134
    SEMICOLON   deslocar, e ir ao estado 135


State 61

   41 iteration_statement: FOR . L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | FOR . L_PAREN for_init for_expr R_PAREN block END_FOR

    L_PAREN  deslocar, e ir ao estado 136


State 62

   33 selection_statement: IF . L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | IF . L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | IF . L_PAREN expression R_PAREN block END_IF

    L_PAREN  deslocar, e ir ao estado 137


State 63

   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  156                | L_PAREN . primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  157                | L_PAREN . user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  158                | L_PAREN . expression R_PAREN logical_unary_expression
  159 primitive_type_expression: . primitive_type
  160                          | . primitive_type dims
  161 user_type_expression: . qualified_name dims
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  174                | L_PAREN . expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14

    primitive_type                  ir ao estado 138
    qualified_name                  ir ao estado 139
    expression                      ir ao estado 140
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    primitive_type_expression       ir ao estado 142
    user_type_expression            ir ao estado 143
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 64

  123 logical_unary_operator: LOG_NOT .

    $padrão  reduzir usando a regra 123 (logical_unary_operator)


State 65

  181 complex_primary_no_parenthesis: NNULL .

    $padrão  reduzir usando a regra 181 (complex_primary_no_parenthesis)


State 66

  120 arithmetic_unary_operator: OP_PLUS .

    $padrão  reduzir usando a regra 120 (arithmetic_unary_operator)


State 67

  121 arithmetic_unary_operator: OP_MINUS .

    $padrão  reduzir usando a regra 121 (arithmetic_unary_operator)


State 68

   60 print_statement: PRINT . L_PAREN expression R_PAREN SEMICOLON

    L_PAREN  deslocar, e ir ao estado 144


State 69

   61 println_statement: PRINTLN . L_PAREN expression R_PAREN SEMICOLON

    L_PAREN  deslocar, e ir ao estado 145


State 70

   58 read_statement: READ . L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | READ . L_PAREN STRING_LITERAL R_PAREN SEMICOLON

    L_PAREN  deslocar, e ir ao estado 146


State 71

   56 jump_statement: RETURN . expression SEMICOLON
   57               | RETURN . SEMICOLON
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    SEMICOLON           deslocar, e ir ao estado 147

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 149
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 72

   25 local_variable_declaration_statement: STATIC . type_specifier variable_declarators SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 150
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 73

   18 subprogram_body: SEMICOLON .

    $padrão  reduzir usando a regra 18 (subprogram_body)


State 74

   40 iteration_statement: WHILE . L_PAREN expression R_PAREN block END_WHILE

    L_PAREN  deslocar, e ir ao estado 151


State 75

   10 procedure_declaration: PROCEDURE subprogram_declarator subprogram_body . END_PROCEDURE

    END_PROCEDURE  deslocar, e ir ao estado 152


State 76

   17 subprogram_body: block .

    $padrão  reduzir usando a regra 17 (subprogram_body)


State 77

   19 block: local_variable_declarations_and_statements .  [ELSE, ELSIF, END_FOR, END_FUNCTION, END_IF, END_PROCEDURE, END_WHILE]
   21 local_variable_declarations_and_statements: local_variable_declarations_and_statements . local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 58
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 60
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 61
    IF                  deslocar, e ir ao estado 62
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    PRINT               deslocar, e ir ao estado 68
    PRINTLN             deslocar, e ir ao estado 69
    READ                deslocar, e ir ao estado 70
    RETURN              deslocar, e ir ao estado 71
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    WHILE               deslocar, e ir ao estado 74

    $padrão  reduzir usando a regra 19 (block)

    local_variable_declarations_or_statements  ir ao estado 153
    local_variable_declaration_statement       ir ao estado 79
    statement                                  ir ao estado 80
    selection_statement                        ir ao estado 81
    iteration_statement                        ir ao estado 82
    jump_statement                             ir ao estado 83
    read_statement                             ir ao estado 84
    print_statement                            ir ao estado 85
    println_statement                          ir ao estado 86
    type_specifier                             ir ao estado 87
    type_name                                  ir ao estado 29
    primitive_type                             ir ao estado 30
    qualified_name                             ir ao estado 88
    assignment_expression                      ir ao estado 89
    unary_expression                           ir ao estado 90
    logical_unary_expression                   ir ao estado 91
    postfix_expression                         ir ao estado 92
    primary_expression                         ir ao estado 93
    arithmetic_unary_operator                  ir ao estado 94
    logical_unary_operator                     ir ao estado 95
    conditional_or_expression                  ir ao estado 96
    conditional_and_expression                 ir ao estado 97
    inclusive_or_expression                    ir ao estado 98
    exclusive_or_expression                    ir ao estado 99
    and_expression                             ir ao estado 100
    equality_expression                        ir ao estado 101
    relational_expression                      ir ao estado 102
    shift_expression                           ir ao estado 103
    additive_expression                        ir ao estado 104
    multiplicative_expression                  ir ao estado 105
    cast_expression                            ir ao estado 106
    not_just_name                              ir ao estado 107
    complex_primary                            ir ao estado 108
    complex_primary_no_parenthesis             ir ao estado 109
    array_access                               ir ao estado 110
    field_access                               ir ao estado 111
    subprogram_call                            ir ao estado 112
    subprogram_access                          ir ao estado 113


State 78

   20 local_variable_declarations_and_statements: local_variable_declarations_or_statements .

    $padrão  reduzir usando a regra 20 (local_variable_declarations_and_statements)


State 79

   22 local_variable_declarations_or_statements: local_variable_declaration_statement .

    $padrão  reduzir usando a regra 22 (local_variable_declarations_or_statements)


State 80

   23 local_variable_declarations_or_statements: statement .

    $padrão  reduzir usando a regra 23 (local_variable_declarations_or_statements)


State 81

   27 statement: selection_statement .

    $padrão  reduzir usando a regra 27 (statement)


State 82

   28 statement: iteration_statement .

    $padrão  reduzir usando a regra 28 (statement)


State 83

   29 statement: jump_statement .

    $padrão  reduzir usando a regra 29 (statement)


State 84

   30 statement: read_statement .

    $padrão  reduzir usando a regra 30 (statement)


State 85

   31 statement: print_statement .

    $padrão  reduzir usando a regra 31 (statement)


State 86

   32 statement: println_statement .

    $padrão  reduzir usando a regra 32 (statement)


State 87

   24 local_variable_declaration_statement: type_specifier . variable_declarators SEMICOLON
   98 variable_declarators: . variable_declarator
   99                     | . variable_declarators COMMA variable_declarator
  100 variable_declarator: . declarator_name
  101                    | . declarator_name ASSIGN variable_initializer
  102 declarator_name: . IDENTIFIER
  103                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    variable_declarators  ir ao estado 154
    variable_declarator   ir ao estado 44
    declarator_name       ir ao estado 45


State 88

   75 type_name: qualified_name .  [IDENTIFIER]
  118 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_SHIFT, SEMICOLON, TYPEOF]
  187 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  193 subprogram_access: qualified_name .  [L_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 155

    IDENTIFIER  reduzir usando a regra 75 (type_name)
    L_PAREN     reduzir usando a regra 193 (subprogram_access)
    $padrão    reduzir usando a regra 118 (primary_expression)


State 89

   26 statement: assignment_expression . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 156


State 90

  112 assignment_expression: unary_expression . assignment_operator assignment_expression
  155 cast_expression: unary_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  162 assignment_operator: . ASSIGN
  163                    | . ASSIGN_PLUS
  164                    | . ASSIGN_MINUS
  165                    | . ASSIGN_PRODUCT
  166                    | . ASSIGN_DIV
  167                    | . ASSIGN_MOD
  168                    | . ASSIGN_BITWISE_AND
  169                    | . ASSIGN_BITWISE_OR
  170                    | . ASSIGN_BITWISE_OR_EXC
  171                    | . ASSIGN_L_SHIFT
  172                    | . ASSIGN_R_SHIFT

    ASSIGN                 deslocar, e ir ao estado 157
    ASSIGN_PLUS            deslocar, e ir ao estado 158
    ASSIGN_MINUS           deslocar, e ir ao estado 159
    ASSIGN_PRODUCT         deslocar, e ir ao estado 160
    ASSIGN_DIV             deslocar, e ir ao estado 161
    ASSIGN_MOD             deslocar, e ir ao estado 162
    ASSIGN_BITWISE_AND     deslocar, e ir ao estado 163
    ASSIGN_BITWISE_OR      deslocar, e ir ao estado 164
    ASSIGN_BITWISE_OR_EXC  deslocar, e ir ao estado 165
    ASSIGN_L_SHIFT         deslocar, e ir ao estado 166
    ASSIGN_R_SHIFT         deslocar, e ir ao estado 167

    $padrão  reduzir usando a regra 155 (cast_expression)

    assignment_operator  ir ao estado 168


State 91

  114 unary_expression: logical_unary_expression .

    $padrão  reduzir usando a regra 114 (unary_expression)


State 92

  115 logical_unary_expression: postfix_expression .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  189 field_access: postfix_expression . DOT IDENTIFIER

    DOT  deslocar, e ir ao estado 169

    $padrão  reduzir usando a regra 115 (logical_unary_expression)


State 93

  117 postfix_expression: primary_expression .

    $padrão  reduzir usando a regra 117 (postfix_expression)


State 94

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  113                 | arithmetic_unary_operator . cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 171
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 95

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  116                         | logical_unary_operator . unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 172
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 173
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 96

  111 assignment_expression: conditional_or_expression .  [COMMA, END_ENUM, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  125 conditional_or_expression: conditional_or_expression . LOG_OR conditional_and_expression
  126                          | conditional_or_expression . LOG_SC_OR conditional_and_expression

    LOG_OR     deslocar, e ir ao estado 174
    LOG_SC_OR  deslocar, e ir ao estado 175

    $padrão  reduzir usando a regra 111 (assignment_expression)


State 97

  124 conditional_or_expression: conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  128 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
  129                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 176
    LOG_SC_AND  deslocar, e ir ao estado 177

    $padrão  reduzir usando a regra 124 (conditional_or_expression)


State 98

  127 conditional_and_expression: inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  131 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 178

    $padrão  reduzir usando a regra 127 (conditional_and_expression)


State 99

  130 inclusive_or_expression: exclusive_or_expression .  [BITWISE_OR, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  133 exclusive_or_expression: exclusive_or_expression . BITWISE_OR_EXC and_expression

    BITWISE_OR_EXC  deslocar, e ir ao estado 179

    $padrão  reduzir usando a regra 130 (inclusive_or_expression)


State 100

  132 exclusive_or_expression: and_expression .  [BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  135 and_expression: and_expression . AMPERSAND equality_expression

    AMPERSAND  deslocar, e ir ao estado 180

    $padrão  reduzir usando a regra 132 (exclusive_or_expression)


State 101

  134 and_expression: equality_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  137 equality_expression: equality_expression . OP_EQ relational_expression
  138                    | equality_expression . OP_NE relational_expression

    OP_EQ  deslocar, e ir ao estado 181
    OP_NE  deslocar, e ir ao estado 182

    $padrão  reduzir usando a regra 134 (and_expression)


State 102

  136 equality_expression: relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  140 relational_expression: relational_expression . OP_LT shift_expression
  141                      | relational_expression . OP_GT shift_expression
  142                      | relational_expression . OP_LET shift_expression
  143                      | relational_expression . OP_GET shift_expression
  144                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 183
    OP_LT   deslocar, e ir ao estado 184
    OP_GET  deslocar, e ir ao estado 185
    OP_GT   deslocar, e ir ao estado 186
    TYPEOF  deslocar, e ir ao estado 187

    $padrão  reduzir usando a regra 136 (equality_expression)


State 103

  139 relational_expression: shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
  146 shift_expression: shift_expression . L_SHIFT additive_expression
  147                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 188
    R_SHIFT  deslocar, e ir ao estado 189

    $padrão  reduzir usando a regra 139 (relational_expression)


State 104

  145 shift_expression: additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  149 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  150                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 190
    OP_MINUS  deslocar, e ir ao estado 191

    $padrão  reduzir usando a regra 145 (shift_expression)


State 105

  148 additive_expression: multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  152 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  153                          | multiplicative_expression . OP_DIV cast_expression
  154                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 192
    OP_DIV       deslocar, e ir ao estado 193
    OP_MOD       deslocar, e ir ao estado 194

    $padrão  reduzir usando a regra 148 (additive_expression)


State 106

  151 multiplicative_expression: cast_expression .

    $padrão  reduzir usando a regra 151 (multiplicative_expression)


State 107

  119 primary_expression: not_just_name .

    $padrão  reduzir usando a regra 119 (primary_expression)


State 108

  173 not_just_name: complex_primary .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  188 array_access: complex_primary . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 195

    $padrão  reduzir usando a regra 173 (not_just_name)


State 109

  175 complex_primary: complex_primary_no_parenthesis .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  192 subprogram_access: complex_primary_no_parenthesis .  [L_PAREN]

    L_PAREN   reduzir usando a regra 192 (subprogram_access)
    $padrão  reduzir usando a regra 175 (complex_primary)


State 110

  184 complex_primary_no_parenthesis: array_access .

    $padrão  reduzir usando a regra 184 (complex_primary_no_parenthesis)


State 111

  185 complex_primary_no_parenthesis: field_access .

    $padrão  reduzir usando a regra 185 (complex_primary_no_parenthesis)


State 112

  186 complex_primary_no_parenthesis: subprogram_call .

    $padrão  reduzir usando a regra 186 (complex_primary_no_parenthesis)


State 113

  190 subprogram_call: subprogram_access . L_PAREN argument_list R_PAREN
  191                | subprogram_access . L_PAREN R_PAREN

    L_PAREN  deslocar, e ir ao estado 196


State 114

   62 type_declaration: STRUCT IDENTIFIER variable_declarations . END_STRUCT
   66 variable_declarations: variable_declarations . variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    END_STRUCT  deslocar, e ir ao estado 197
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    variable_declaration  ir ao estado 198
    modifiers             ir ao estado 26
    modifier              ir ao estado 27
    type_specifier        ir ao estado 28
    type_name             ir ao estado 29
    primitive_type        ir ao estado 30
    qualified_name        ir ao estado 31


State 115

   65 variable_declarations: variable_declaration .

    $padrão  reduzir usando a regra 65 (variable_declarations)


State 116

   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   85 discriminant: L_PAREN . type_specifier declarator_name R_PAREN
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 199
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 117

   63 type_declaration: UNION IDENTIFIER discriminant . union_body END_UNION
   65 variable_declarations: . variable_declaration
   66                      | . variable_declarations variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
   92 union_body: . variable_declarations short_case_statement
   93           | . variable_declarations

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    variable_declarations  ir ao estado 200
    variable_declaration   ir ao estado 115
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31
    union_body             ir ao estado 201


State 118

   67 variable_declaration: modifiers type_specifier variable_declarators . SEMICOLON
   99 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 119
    SEMICOLON  deslocar, e ir ao estado 202


State 119

   99 variable_declarators: variable_declarators COMMA . variable_declarator
  100 variable_declarator: . declarator_name
  101                    | . declarator_name ASSIGN variable_initializer
  102 declarator_name: . IDENTIFIER
  103                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    variable_declarator  ir ao estado 203
    declarator_name      ir ao estado 45


State 120

   68 variable_declaration: type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 68 (variable_declaration)


State 121

   91 qualified_name: . IDENTIFIER
  101 variable_declarator: declarator_name ASSIGN . variable_initializer
  104 variable_initializer: . expression
  105                     | . L_BRACE R_BRACE
  106                     | . L_BRACE array_initializers R_BRACE
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    L_BRACE             deslocar, e ir ao estado 204
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    variable_initializer            ir ao estado 205
    expression                      ir ao estado 206
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 122

   91 qualified_name: . IDENTIFIER
  103 declarator_name: declarator_name L_SQ_PAREN . expression R_SQ_PAREN
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 207
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 123

   89 enumerator: IDENTIFIER ASSIGN . expression
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 208
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 124

   88 enumerator_list: enumerator_list COMMA . enumerator
   89 enumerator: . IDENTIFIER ASSIGN expression
   90           | . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 46

    enumerator  ir ao estado 209


State 125

   64 type_declaration: ENUM IDENTIFIER enumerator_list END_ENUM .

    $padrão  reduzir usando a regra 64 (type_declaration)


State 126

    9 function_declaration: FUNCTION type_specifier subprogram_declarator subprogram_body . END_FUNCTION

    END_FUNCTION  deslocar, e ir ao estado 210


State 127

   16 parameter: CONST . type_specifier declarator_name
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 211
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 128

   12 subprogram_declarator: IDENTIFIER L_PAREN R_PAREN .

    $padrão  reduzir usando a regra 12 (subprogram_declarator)


State 129

   11 subprogram_declarator: IDENTIFIER L_PAREN parameter_list . R_PAREN
   14 parameter_list: parameter_list . COMMA parameter

    COMMA    deslocar, e ir ao estado 212
    R_PAREN  deslocar, e ir ao estado 213


State 130

   13 parameter_list: parameter .

    $padrão  reduzir usando a regra 13 (parameter_list)


State 131

   15 parameter: type_specifier . declarator_name
  102 declarator_name: . IDENTIFIER
  103                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    declarator_name  ir ao estado 214


State 132

   52 jump_statement: BREAK IDENTIFIER . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 215


State 133

   53 jump_statement: BREAK SEMICOLON .

    $padrão  reduzir usando a regra 53 (jump_statement)


State 134

   54 jump_statement: CONTINUE IDENTIFIER . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 216


State 135

   55 jump_statement: CONTINUE SEMICOLON .

    $padrão  reduzir usando a regra 55 (jump_statement)


State 136

   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   41 iteration_statement: FOR L_PAREN . for_init for_expr for_incr R_PAREN block END_FOR
   42                    | FOR L_PAREN . for_init for_expr R_PAREN block END_FOR
   43 for_init: . expression_statements SEMICOLON
   44         | . local_variable_declaration_statement
   45         | . SEMICOLON
   49 expression_statements: . expression_statement
   50                      | . expression_statements COMMA expression_statement
   51 expression_statement: . expression
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    SEMICOLON           deslocar, e ir ao estado 217

    local_variable_declaration_statement  ir ao estado 218
    for_init                              ir ao estado 219
    expression_statements                 ir ao estado 220
    expression_statement                  ir ao estado 221
    type_specifier                        ir ao estado 87
    type_name                             ir ao estado 29
    primitive_type                        ir ao estado 30
    qualified_name                        ir ao estado 88
    expression                            ir ao estado 222
    assignment_expression                 ir ao estado 141
    unary_expression                      ir ao estado 90
    logical_unary_expression              ir ao estado 91
    postfix_expression                    ir ao estado 92
    primary_expression                    ir ao estado 93
    arithmetic_unary_operator             ir ao estado 94
    logical_unary_operator                ir ao estado 95
    conditional_or_expression             ir ao estado 96
    conditional_and_expression            ir ao estado 97
    inclusive_or_expression               ir ao estado 98
    exclusive_or_expression               ir ao estado 99
    and_expression                        ir ao estado 100
    equality_expression                   ir ao estado 101
    relational_expression                 ir ao estado 102
    shift_expression                      ir ao estado 103
    additive_expression                   ir ao estado 104
    multiplicative_expression             ir ao estado 105
    cast_expression                       ir ao estado 106
    not_just_name                         ir ao estado 107
    complex_primary                       ir ao estado 108
    complex_primary_no_parenthesis        ir ao estado 109
    array_access                          ir ao estado 110
    field_access                          ir ao estado 111
    subprogram_call                       ir ao estado 112
    subprogram_access                     ir ao estado 113


State 137

   33 selection_statement: IF L_PAREN . expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | IF L_PAREN . expression R_PAREN block ELSE block END_IF
   35                    | IF L_PAREN . expression R_PAREN block END_IF
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 223
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 138

  159 primitive_type_expression: primitive_type .  [R_PAREN]
  160                          | primitive_type . dims
  196 dims: . L_SQ_PAREN R_SQ_PAREN
  197     | . dims L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 224

    $padrão  reduzir usando a regra 159 (primitive_type_expression)

    dims  ir ao estado 225


State 139

  118 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, DOT, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SHIFT, TYPEOF]
  161 user_type_expression: qualified_name . dims
  187 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  193 subprogram_access: qualified_name .  [L_PAREN]
  196 dims: . L_SQ_PAREN R_SQ_PAREN
  197     | . dims L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 226

    L_PAREN   reduzir usando a regra 193 (subprogram_access)
    $padrão  reduzir usando a regra 118 (primary_expression)

    dims  ir ao estado 227


State 140

  158 cast_expression: L_PAREN expression . R_PAREN logical_unary_expression
  174 complex_primary: L_PAREN expression . R_PAREN

    R_PAREN  deslocar, e ir ao estado 228


State 141

  110 expression: assignment_expression .

    $padrão  reduzir usando a regra 110 (expression)


State 142

  156 cast_expression: L_PAREN primitive_type_expression . R_PAREN cast_expression

    R_PAREN  deslocar, e ir ao estado 229


State 143

  157 cast_expression: L_PAREN user_type_expression . R_PAREN cast_expression

    R_PAREN  deslocar, e ir ao estado 230


State 144

   60 print_statement: PRINT L_PAREN . expression R_PAREN SEMICOLON
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 231
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 145

   61 println_statement: PRINTLN L_PAREN . expression R_PAREN SEMICOLON
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 232
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 146

   58 read_statement: READ L_PAREN . STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | READ L_PAREN . STRING_LITERAL R_PAREN SEMICOLON

    STRING_LITERAL  deslocar, e ir ao estado 233


State 147

   57 jump_statement: RETURN SEMICOLON .

    $padrão  reduzir usando a regra 57 (jump_statement)


State 148

  118 primary_expression: qualified_name .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  187 array_access: qualified_name . L_SQ_PAREN expression R_SQ_PAREN
  193 subprogram_access: qualified_name .  [L_PAREN]

    L_SQ_PAREN  deslocar, e ir ao estado 155

    L_PAREN   reduzir usando a regra 193 (subprogram_access)
    $padrão  reduzir usando a regra 118 (primary_expression)


State 149

   56 jump_statement: RETURN expression . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 234


State 150

   25 local_variable_declaration_statement: STATIC type_specifier . variable_declarators SEMICOLON
   98 variable_declarators: . variable_declarator
   99                     | . variable_declarators COMMA variable_declarator
  100 variable_declarator: . declarator_name
  101                    | . declarator_name ASSIGN variable_initializer
  102 declarator_name: . IDENTIFIER
  103                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    variable_declarators  ir ao estado 235
    variable_declarator   ir ao estado 44
    declarator_name       ir ao estado 45


State 151

   40 iteration_statement: WHILE L_PAREN . expression R_PAREN block END_WHILE
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 236
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 152

   10 procedure_declaration: PROCEDURE subprogram_declarator subprogram_body END_PROCEDURE .

    $padrão  reduzir usando a regra 10 (procedure_declaration)


State 153

   21 local_variable_declarations_and_statements: local_variable_declarations_and_statements local_variable_declarations_or_statements .

    $padrão  reduzir usando a regra 21 (local_variable_declarations_and_statements)


State 154

   24 local_variable_declaration_statement: type_specifier variable_declarators . SEMICOLON
   99 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 119
    SEMICOLON  deslocar, e ir ao estado 237


State 155

   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  187             | qualified_name L_SQ_PAREN . expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 238
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 156

   26 statement: assignment_expression SEMICOLON .

    $padrão  reduzir usando a regra 26 (statement)


State 157

  162 assignment_operator: ASSIGN .

    $padrão  reduzir usando a regra 162 (assignment_operator)


State 158

  163 assignment_operator: ASSIGN_PLUS .

    $padrão  reduzir usando a regra 163 (assignment_operator)


State 159

  164 assignment_operator: ASSIGN_MINUS .

    $padrão  reduzir usando a regra 164 (assignment_operator)


State 160

  165 assignment_operator: ASSIGN_PRODUCT .

    $padrão  reduzir usando a regra 165 (assignment_operator)


State 161

  166 assignment_operator: ASSIGN_DIV .

    $padrão  reduzir usando a regra 166 (assignment_operator)


State 162

  167 assignment_operator: ASSIGN_MOD .

    $padrão  reduzir usando a regra 167 (assignment_operator)


State 163

  168 assignment_operator: ASSIGN_BITWISE_AND .

    $padrão  reduzir usando a regra 168 (assignment_operator)


State 164

  169 assignment_operator: ASSIGN_BITWISE_OR .

    $padrão  reduzir usando a regra 169 (assignment_operator)


State 165

  170 assignment_operator: ASSIGN_BITWISE_OR_EXC .

    $padrão  reduzir usando a regra 170 (assignment_operator)


State 166

  171 assignment_operator: ASSIGN_L_SHIFT .

    $padrão  reduzir usando a regra 171 (assignment_operator)


State 167

  172 assignment_operator: ASSIGN_R_SHIFT .

    $padrão  reduzir usando a regra 172 (assignment_operator)


State 168

   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  112                      | unary_expression assignment_operator . assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    assignment_expression           ir ao estado 239
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 169

  189 field_access: postfix_expression DOT . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 240


State 170

  155 cast_expression: unary_expression .

    $padrão  reduzir usando a regra 155 (cast_expression)


State 171

  113 unary_expression: arithmetic_unary_operator cast_expression .

    $padrão  reduzir usando a regra 113 (unary_expression)


State 172

   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  174                | L_PAREN . expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 241
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 173

  116 logical_unary_expression: logical_unary_operator unary_expression .

    $padrão  reduzir usando a regra 116 (logical_unary_expression)


State 174

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  125 conditional_or_expression: conditional_or_expression LOG_OR . conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_and_expression      ir ao estado 242
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 175

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  126 conditional_or_expression: conditional_or_expression LOG_SC_OR . conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_and_expression      ir ao estado 243
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 176

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  128 conditional_and_expression: conditional_and_expression LOG_AND . inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    inclusive_or_expression         ir ao estado 244
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 177

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  129 conditional_and_expression: conditional_and_expression LOG_SC_AND . inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    inclusive_or_expression         ir ao estado 245
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 178

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  131 inclusive_or_expression: inclusive_or_expression BITWISE_OR . exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    exclusive_or_expression         ir ao estado 246
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 179

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  133 exclusive_or_expression: exclusive_or_expression BITWISE_OR_EXC . and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    and_expression                  ir ao estado 247
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 180

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  135 and_expression: and_expression AMPERSAND . equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    equality_expression             ir ao estado 248
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 181

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  137 equality_expression: equality_expression OP_EQ . relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    relational_expression           ir ao estado 249
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 182

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  138 equality_expression: equality_expression OP_NE . relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    relational_expression           ir ao estado 250
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 183

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  142 relational_expression: relational_expression OP_LET . shift_expression
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    shift_expression                ir ao estado 251
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 184

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  140 relational_expression: relational_expression OP_LT . shift_expression
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    shift_expression                ir ao estado 252
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 185

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  143 relational_expression: relational_expression OP_GET . shift_expression
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    shift_expression                ir ao estado 253
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 186

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  141 relational_expression: relational_expression OP_GT . shift_expression
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    shift_expression                ir ao estado 254
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 187

   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  144 relational_expression: relational_expression TYPEOF . type_specifier

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    type_specifier  ir ao estado 255
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 188

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  146 shift_expression: shift_expression L_SHIFT . additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    additive_expression             ir ao estado 256
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 189

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  147 shift_expression: shift_expression R_SHIFT . additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    additive_expression             ir ao estado 257
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 190

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  149 additive_expression: additive_expression OP_PLUS . multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    multiplicative_expression       ir ao estado 258
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 191

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  150 additive_expression: additive_expression OP_MINUS . multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    multiplicative_expression       ir ao estado 259
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 192

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  152 multiplicative_expression: multiplicative_expression OP_ASTERISK . cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 260
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 193

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  153 multiplicative_expression: multiplicative_expression OP_DIV . cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 261
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 194

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  154 multiplicative_expression: multiplicative_expression OP_MOD . cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 262
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 195

   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  188             | complex_primary L_SQ_PAREN . expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 263
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 196

   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  190                | subprogram_access L_PAREN . argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  191                | subprogram_access L_PAREN . R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name
  194 argument_list: . expression
  195              | . argument_list COMMA expression

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    R_PAREN             deslocar, e ir ao estado 264

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 265
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113
    argument_list                   ir ao estado 266


State 197

   62 type_declaration: STRUCT IDENTIFIER variable_declarations END_STRUCT .

    $padrão  reduzir usando a regra 62 (type_declaration)


State 198

   66 variable_declarations: variable_declarations variable_declaration .

    $padrão  reduzir usando a regra 66 (variable_declarations)


State 199

   85 discriminant: L_PAREN type_specifier . declarator_name R_PAREN
  102 declarator_name: . IDENTIFIER
  103                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    declarator_name  ir ao estado 267


State 200

   66 variable_declarations: variable_declarations . variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
   92 union_body: variable_declarations . short_case_statement
   93           | variable_declarations .  [END_UNION]
   94 short_case_statement: . CASE IDENTIFIER choices END_CASE

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CASE        deslocar, e ir ao estado 268
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    $padrão  reduzir usando a regra 93 (union_body)

    variable_declaration  ir ao estado 198
    modifiers             ir ao estado 26
    modifier              ir ao estado 27
    type_specifier        ir ao estado 28
    type_name             ir ao estado 29
    primitive_type        ir ao estado 30
    qualified_name        ir ao estado 31
    short_case_statement  ir ao estado 269


State 201

   63 type_declaration: UNION IDENTIFIER discriminant union_body . END_UNION

    END_UNION  deslocar, e ir ao estado 270


State 202

   67 variable_declaration: modifiers type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 67 (variable_declaration)


State 203

   99 variable_declarators: variable_declarators COMMA variable_declarator .

    $padrão  reduzir usando a regra 99 (variable_declarators)


State 204

   91 qualified_name: . IDENTIFIER
  104 variable_initializer: . expression
  105                     | . L_BRACE R_BRACE
  105                     | L_BRACE . R_BRACE
  106                     | . L_BRACE array_initializers R_BRACE
  106                     | L_BRACE . array_initializers R_BRACE
  107 array_initializers: . variable_initializer
  108                   | . array_initializers COMMA variable_initializer
  109                   | . array_initializers COMMA
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    L_BRACE             deslocar, e ir ao estado 204
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    R_BRACE             deslocar, e ir ao estado 271

    qualified_name                  ir ao estado 148
    variable_initializer            ir ao estado 272
    array_initializers              ir ao estado 273
    expression                      ir ao estado 206
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 205

  101 variable_declarator: declarator_name ASSIGN variable_initializer .

    $padrão  reduzir usando a regra 101 (variable_declarator)


State 206

  104 variable_initializer: expression .

    $padrão  reduzir usando a regra 104 (variable_initializer)


State 207

  103 declarator_name: declarator_name L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 274


State 208

   89 enumerator: IDENTIFIER ASSIGN expression .

    $padrão  reduzir usando a regra 89 (enumerator)


State 209

   88 enumerator_list: enumerator_list COMMA enumerator .

    $padrão  reduzir usando a regra 88 (enumerator_list)


State 210

    9 function_declaration: FUNCTION type_specifier subprogram_declarator subprogram_body END_FUNCTION .

    $padrão  reduzir usando a regra 9 (function_declaration)


State 211

   16 parameter: CONST type_specifier . declarator_name
  102 declarator_name: . IDENTIFIER
  103                | . declarator_name L_SQ_PAREN expression R_SQ_PAREN

    IDENTIFIER  deslocar, e ir ao estado 42

    declarator_name  ir ao estado 275


State 212

   14 parameter_list: parameter_list COMMA . parameter
   15 parameter: . type_specifier declarator_name
   16          | . CONST type_specifier declarator_name
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 127
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14

    parameter       ir ao estado 276
    type_specifier  ir ao estado 131
    type_name       ir ao estado 29
    primitive_type  ir ao estado 30
    qualified_name  ir ao estado 31


State 213

   11 subprogram_declarator: IDENTIFIER L_PAREN parameter_list R_PAREN .

    $padrão  reduzir usando a regra 11 (subprogram_declarator)


State 214

   15 parameter: type_specifier declarator_name .  [COMMA, R_PAREN]
  103 declarator_name: declarator_name . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 122

    $padrão  reduzir usando a regra 15 (parameter)


State 215

   52 jump_statement: BREAK IDENTIFIER SEMICOLON .

    $padrão  reduzir usando a regra 52 (jump_statement)


State 216

   54 jump_statement: CONTINUE IDENTIFIER SEMICOLON .

    $padrão  reduzir usando a regra 54 (jump_statement)


State 217

   45 for_init: SEMICOLON .

    $padrão  reduzir usando a regra 45 (for_init)


State 218

   44 for_init: local_variable_declaration_statement .

    $padrão  reduzir usando a regra 44 (for_init)


State 219

   41 iteration_statement: FOR L_PAREN for_init . for_expr for_incr R_PAREN block END_FOR
   42                    | FOR L_PAREN for_init . for_expr R_PAREN block END_FOR
   46 for_expr: . expression SEMICOLON
   47         | . SEMICOLON
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    SEMICOLON           deslocar, e ir ao estado 277

    for_expr                        ir ao estado 278
    qualified_name                  ir ao estado 148
    expression                      ir ao estado 279
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 220

   43 for_init: expression_statements . SEMICOLON
   50 expression_statements: expression_statements . COMMA expression_statement

    COMMA      deslocar, e ir ao estado 280
    SEMICOLON  deslocar, e ir ao estado 281


State 221

   49 expression_statements: expression_statement .

    $padrão  reduzir usando a regra 49 (expression_statements)


State 222

   51 expression_statement: expression .

    $padrão  reduzir usando a regra 51 (expression_statement)


State 223

   33 selection_statement: IF L_PAREN expression . R_PAREN block ELSIF elsif_staments END_IF
   34                    | IF L_PAREN expression . R_PAREN block ELSE block END_IF
   35                    | IF L_PAREN expression . R_PAREN block END_IF

    R_PAREN  deslocar, e ir ao estado 282


State 224

  196 dims: L_SQ_PAREN . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 283


State 225

  160 primitive_type_expression: primitive_type dims .  [R_PAREN]
  197 dims: dims . L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 284

    $padrão  reduzir usando a regra 160 (primitive_type_expression)


State 226

   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  187             | qualified_name L_SQ_PAREN . expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name
  196 dims: L_SQ_PAREN . R_SQ_PAREN

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    R_SQ_PAREN          deslocar, e ir ao estado 283

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 238
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 227

  161 user_type_expression: qualified_name dims .  [R_PAREN]
  197 dims: dims . L_SQ_PAREN R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 284

    $padrão  reduzir usando a regra 161 (user_type_expression)


State 228

   91 qualified_name: . IDENTIFIER
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  158 cast_expression: L_PAREN expression R_PAREN . logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  174                | L_PAREN expression R_PAREN .  [ASSIGN, ASSIGN_PLUS, ASSIGN_MINUS, ASSIGN_PRODUCT, ASSIGN_DIV, ASSIGN_MOD, ASSIGN_BITWISE_AND, ASSIGN_BITWISE_OR, ASSIGN_BITWISE_OR_EXC, ASSIGN_L_SHIFT, ASSIGN_R_SHIFT, AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, DOT, END_ENUM, L_SQ_PAREN, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_ASTERISK, OP_DIV, OP_MOD, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 172
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65

    $padrão  reduzir usando a regra 174 (complex_primary)

    qualified_name                  ir ao estado 148
    logical_unary_expression        ir ao estado 285
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    logical_unary_operator          ir ao estado 95
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 229

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  156                | L_PAREN primitive_type_expression R_PAREN . cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 286
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 230

   91 qualified_name: . IDENTIFIER
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  157                | L_PAREN user_type_expression R_PAREN . cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    unary_expression                ir ao estado 170
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    cast_expression                 ir ao estado 287
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 231

   60 print_statement: PRINT L_PAREN expression . R_PAREN SEMICOLON

    R_PAREN  deslocar, e ir ao estado 288


State 232

   61 println_statement: PRINTLN L_PAREN expression . R_PAREN SEMICOLON

    R_PAREN  deslocar, e ir ao estado 289


State 233

   58 read_statement: READ L_PAREN STRING_LITERAL . COMMA argument_list R_PAREN SEMICOLON
   59               | READ L_PAREN STRING_LITERAL . R_PAREN SEMICOLON

    COMMA    deslocar, e ir ao estado 290
    R_PAREN  deslocar, e ir ao estado 291


State 234

   56 jump_statement: RETURN expression SEMICOLON .

    $padrão  reduzir usando a regra 56 (jump_statement)


State 235

   25 local_variable_declaration_statement: STATIC type_specifier variable_declarators . SEMICOLON
   99 variable_declarators: variable_declarators . COMMA variable_declarator

    COMMA      deslocar, e ir ao estado 119
    SEMICOLON  deslocar, e ir ao estado 292


State 236

   40 iteration_statement: WHILE L_PAREN expression . R_PAREN block END_WHILE

    R_PAREN  deslocar, e ir ao estado 293


State 237

   24 local_variable_declaration_statement: type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 24 (local_variable_declaration_statement)


State 238

  187 array_access: qualified_name L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 294


State 239

  112 assignment_expression: unary_expression assignment_operator assignment_expression .

    $padrão  reduzir usando a regra 112 (assignment_expression)


State 240

  189 field_access: postfix_expression DOT IDENTIFIER .

    $padrão  reduzir usando a regra 189 (field_access)


State 241

  174 complex_primary: L_PAREN expression . R_PAREN

    R_PAREN  deslocar, e ir ao estado 295


State 242

  125 conditional_or_expression: conditional_or_expression LOG_OR conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  128 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
  129                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 176
    LOG_SC_AND  deslocar, e ir ao estado 177

    $padrão  reduzir usando a regra 125 (conditional_or_expression)


State 243

  126 conditional_or_expression: conditional_or_expression LOG_SC_OR conditional_and_expression .  [COMMA, END_ENUM, LOG_OR, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  128 conditional_and_expression: conditional_and_expression . LOG_AND inclusive_or_expression
  129                           | conditional_and_expression . LOG_SC_AND inclusive_or_expression

    LOG_AND     deslocar, e ir ao estado 176
    LOG_SC_AND  deslocar, e ir ao estado 177

    $padrão  reduzir usando a regra 126 (conditional_or_expression)


State 244

  128 conditional_and_expression: conditional_and_expression LOG_AND inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  131 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 178

    $padrão  reduzir usando a regra 128 (conditional_and_expression)


State 245

  129 conditional_and_expression: conditional_and_expression LOG_SC_AND inclusive_or_expression .  [COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  131 inclusive_or_expression: inclusive_or_expression . BITWISE_OR exclusive_or_expression

    BITWISE_OR  deslocar, e ir ao estado 178

    $padrão  reduzir usando a regra 129 (conditional_and_expression)


State 246

  131 inclusive_or_expression: inclusive_or_expression BITWISE_OR exclusive_or_expression .  [BITWISE_OR, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  133 exclusive_or_expression: exclusive_or_expression . BITWISE_OR_EXC and_expression

    BITWISE_OR_EXC  deslocar, e ir ao estado 179

    $padrão  reduzir usando a regra 131 (inclusive_or_expression)


State 247

  133 exclusive_or_expression: exclusive_or_expression BITWISE_OR_EXC and_expression .  [BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  135 and_expression: and_expression . AMPERSAND equality_expression

    AMPERSAND  deslocar, e ir ao estado 180

    $padrão  reduzir usando a regra 133 (exclusive_or_expression)


State 248

  135 and_expression: and_expression AMPERSAND equality_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  137 equality_expression: equality_expression . OP_EQ relational_expression
  138                    | equality_expression . OP_NE relational_expression

    OP_EQ  deslocar, e ir ao estado 181
    OP_NE  deslocar, e ir ao estado 182

    $padrão  reduzir usando a regra 135 (and_expression)


State 249

  137 equality_expression: equality_expression OP_EQ relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  140 relational_expression: relational_expression . OP_LT shift_expression
  141                      | relational_expression . OP_GT shift_expression
  142                      | relational_expression . OP_LET shift_expression
  143                      | relational_expression . OP_GET shift_expression
  144                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 183
    OP_LT   deslocar, e ir ao estado 184
    OP_GET  deslocar, e ir ao estado 185
    OP_GT   deslocar, e ir ao estado 186
    TYPEOF  deslocar, e ir ao estado 187

    $padrão  reduzir usando a regra 137 (equality_expression)


State 250

  138 equality_expression: equality_expression OP_NE relational_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON]
  140 relational_expression: relational_expression . OP_LT shift_expression
  141                      | relational_expression . OP_GT shift_expression
  142                      | relational_expression . OP_LET shift_expression
  143                      | relational_expression . OP_GET shift_expression
  144                      | relational_expression . TYPEOF type_specifier

    OP_LET  deslocar, e ir ao estado 183
    OP_LT   deslocar, e ir ao estado 184
    OP_GET  deslocar, e ir ao estado 185
    OP_GT   deslocar, e ir ao estado 186
    TYPEOF  deslocar, e ir ao estado 187

    $padrão  reduzir usando a regra 138 (equality_expression)


State 251

  142 relational_expression: relational_expression OP_LET shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
  146 shift_expression: shift_expression . L_SHIFT additive_expression
  147                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 188
    R_SHIFT  deslocar, e ir ao estado 189

    $padrão  reduzir usando a regra 142 (relational_expression)


State 252

  140 relational_expression: relational_expression OP_LT shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
  146 shift_expression: shift_expression . L_SHIFT additive_expression
  147                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 188
    R_SHIFT  deslocar, e ir ao estado 189

    $padrão  reduzir usando a regra 140 (relational_expression)


State 253

  143 relational_expression: relational_expression OP_GET shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
  146 shift_expression: shift_expression . L_SHIFT additive_expression
  147                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 188
    R_SHIFT  deslocar, e ir ao estado 189

    $padrão  reduzir usando a regra 143 (relational_expression)


State 254

  141 relational_expression: relational_expression OP_GT shift_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, SEMICOLON, TYPEOF]
  146 shift_expression: shift_expression . L_SHIFT additive_expression
  147                 | shift_expression . R_SHIFT additive_expression

    L_SHIFT  deslocar, e ir ao estado 188
    R_SHIFT  deslocar, e ir ao estado 189

    $padrão  reduzir usando a regra 141 (relational_expression)


State 255

  144 relational_expression: relational_expression TYPEOF type_specifier .

    $padrão  reduzir usando a regra 144 (relational_expression)


State 256

  146 shift_expression: shift_expression L_SHIFT additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  149 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  150                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 190
    OP_MINUS  deslocar, e ir ao estado 191

    $padrão  reduzir usando a regra 146 (shift_expression)


State 257

  147 shift_expression: shift_expression R_SHIFT additive_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  149 additive_expression: additive_expression . OP_PLUS multiplicative_expression
  150                    | additive_expression . OP_MINUS multiplicative_expression

    OP_PLUS   deslocar, e ir ao estado 190
    OP_MINUS  deslocar, e ir ao estado 191

    $padrão  reduzir usando a regra 147 (shift_expression)


State 258

  149 additive_expression: additive_expression OP_PLUS multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  152 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  153                          | multiplicative_expression . OP_DIV cast_expression
  154                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 192
    OP_DIV       deslocar, e ir ao estado 193
    OP_MOD       deslocar, e ir ao estado 194

    $padrão  reduzir usando a regra 149 (additive_expression)


State 259

  150 additive_expression: additive_expression OP_MINUS multiplicative_expression .  [AMPERSAND, BITWISE_OR, BITWISE_OR_EXC, COMMA, END_ENUM, L_SHIFT, LOG_AND, LOG_OR, LOG_SC_AND, LOG_SC_OR, OP_EQ, OP_NE, OP_PLUS, OP_MINUS, OP_LET, OP_LT, OP_GET, OP_GT, R_PAREN, R_SQ_PAREN, R_BRACE, R_SHIFT, SEMICOLON, TYPEOF]
  152 multiplicative_expression: multiplicative_expression . OP_ASTERISK cast_expression
  153                          | multiplicative_expression . OP_DIV cast_expression
  154                          | multiplicative_expression . OP_MOD cast_expression

    OP_ASTERISK  deslocar, e ir ao estado 192
    OP_DIV       deslocar, e ir ao estado 193
    OP_MOD       deslocar, e ir ao estado 194

    $padrão  reduzir usando a regra 150 (additive_expression)


State 260

  152 multiplicative_expression: multiplicative_expression OP_ASTERISK cast_expression .

    $padrão  reduzir usando a regra 152 (multiplicative_expression)


State 261

  153 multiplicative_expression: multiplicative_expression OP_DIV cast_expression .

    $padrão  reduzir usando a regra 153 (multiplicative_expression)


State 262

  154 multiplicative_expression: multiplicative_expression OP_MOD cast_expression .

    $padrão  reduzir usando a regra 154 (multiplicative_expression)


State 263

  188 array_access: complex_primary L_SQ_PAREN expression . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 296


State 264

  191 subprogram_call: subprogram_access L_PAREN R_PAREN .

    $padrão  reduzir usando a regra 191 (subprogram_call)


State 265

  194 argument_list: expression .

    $padrão  reduzir usando a regra 194 (argument_list)


State 266

  190 subprogram_call: subprogram_access L_PAREN argument_list . R_PAREN
  195 argument_list: argument_list . COMMA expression

    COMMA    deslocar, e ir ao estado 297
    R_PAREN  deslocar, e ir ao estado 298


State 267

   85 discriminant: L_PAREN type_specifier declarator_name . R_PAREN
  103 declarator_name: declarator_name . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 122
    R_PAREN     deslocar, e ir ao estado 299


State 268

   94 short_case_statement: CASE . IDENTIFIER choices END_CASE

    IDENTIFIER  deslocar, e ir ao estado 300


State 269

   92 union_body: variable_declarations short_case_statement .

    $padrão  reduzir usando a regra 92 (union_body)


State 270

   63 type_declaration: UNION IDENTIFIER discriminant union_body END_UNION .

    $padrão  reduzir usando a regra 63 (type_declaration)


State 271

  105 variable_initializer: L_BRACE R_BRACE .

    $padrão  reduzir usando a regra 105 (variable_initializer)


State 272

  107 array_initializers: variable_initializer .

    $padrão  reduzir usando a regra 107 (array_initializers)


State 273

  106 variable_initializer: L_BRACE array_initializers . R_BRACE
  108 array_initializers: array_initializers . COMMA variable_initializer
  109                   | array_initializers . COMMA

    COMMA    deslocar, e ir ao estado 301
    R_BRACE  deslocar, e ir ao estado 302


State 274

  103 declarator_name: declarator_name L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 103 (declarator_name)


State 275

   16 parameter: CONST type_specifier declarator_name .  [COMMA, R_PAREN]
  103 declarator_name: declarator_name . L_SQ_PAREN expression R_SQ_PAREN

    L_SQ_PAREN  deslocar, e ir ao estado 122

    $padrão  reduzir usando a regra 16 (parameter)


State 276

   14 parameter_list: parameter_list COMMA parameter .

    $padrão  reduzir usando a regra 14 (parameter_list)


State 277

   47 for_expr: SEMICOLON .

    $padrão  reduzir usando a regra 47 (for_expr)


State 278

   41 iteration_statement: FOR L_PAREN for_init for_expr . for_incr R_PAREN block END_FOR
   42                    | FOR L_PAREN for_init for_expr . R_PAREN block END_FOR
   48 for_incr: . expression_statements
   49 expression_statements: . expression_statement
   50                      | . expression_statements COMMA expression_statement
   51 expression_statement: . expression
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    R_PAREN             deslocar, e ir ao estado 303

    for_incr                        ir ao estado 304
    expression_statements           ir ao estado 305
    expression_statement            ir ao estado 221
    qualified_name                  ir ao estado 148
    expression                      ir ao estado 222
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 279

   46 for_expr: expression . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 306


State 280

   50 expression_statements: expression_statements COMMA . expression_statement
   51 expression_statement: . expression
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    expression_statement            ir ao estado 307
    qualified_name                  ir ao estado 148
    expression                      ir ao estado 222
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 281

   43 for_init: expression_statements SEMICOLON .

    $padrão  reduzir usando a regra 43 (for_init)


State 282

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   33                    | IF L_PAREN expression R_PAREN . block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   34                    | IF L_PAREN expression R_PAREN . block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   35                    | IF L_PAREN expression R_PAREN . block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 58
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 60
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 61
    IF                  deslocar, e ir ao estado 62
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    PRINT               deslocar, e ir ao estado 68
    PRINTLN             deslocar, e ir ao estado 69
    READ                deslocar, e ir ao estado 70
    RETURN              deslocar, e ir ao estado 71
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    WHILE               deslocar, e ir ao estado 74

    block                                       ir ao estado 308
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 283

  196 dims: L_SQ_PAREN R_SQ_PAREN .

    $padrão  reduzir usando a regra 196 (dims)


State 284

  197 dims: dims L_SQ_PAREN . R_SQ_PAREN

    R_SQ_PAREN  deslocar, e ir ao estado 309


State 285

  158 cast_expression: L_PAREN expression R_PAREN logical_unary_expression .

    $padrão  reduzir usando a regra 158 (cast_expression)


State 286

  156 cast_expression: L_PAREN primitive_type_expression R_PAREN cast_expression .

    $padrão  reduzir usando a regra 156 (cast_expression)


State 287

  157 cast_expression: L_PAREN user_type_expression R_PAREN cast_expression .

    $padrão  reduzir usando a regra 157 (cast_expression)


State 288

   60 print_statement: PRINT L_PAREN expression R_PAREN . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 310


State 289

   61 println_statement: PRINTLN L_PAREN expression R_PAREN . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 311


State 290

   58 read_statement: READ L_PAREN STRING_LITERAL COMMA . argument_list R_PAREN SEMICOLON
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name
  194 argument_list: . expression
  195              | . argument_list COMMA expression

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 265
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113
    argument_list                   ir ao estado 312


State 291

   59 read_statement: READ L_PAREN STRING_LITERAL R_PAREN . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 313


State 292

   25 local_variable_declaration_statement: STATIC type_specifier variable_declarators SEMICOLON .

    $padrão  reduzir usando a regra 25 (local_variable_declaration_statement)


State 293

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   40                    | WHILE L_PAREN expression R_PAREN . block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 58
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 60
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 61
    IF                  deslocar, e ir ao estado 62
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    PRINT               deslocar, e ir ao estado 68
    PRINTLN             deslocar, e ir ao estado 69
    READ                deslocar, e ir ao estado 70
    RETURN              deslocar, e ir ao estado 71
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    WHILE               deslocar, e ir ao estado 74

    block                                       ir ao estado 314
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 294

  187 array_access: qualified_name L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 187 (array_access)


State 295

  174 complex_primary: L_PAREN expression R_PAREN .

    $padrão  reduzir usando a regra 174 (complex_primary)


State 296

  188 array_access: complex_primary L_SQ_PAREN expression R_SQ_PAREN .

    $padrão  reduzir usando a regra 188 (array_access)


State 297

   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name
  195 argument_list: argument_list COMMA . expression

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 315
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 298

  190 subprogram_call: subprogram_access L_PAREN argument_list R_PAREN .

    $padrão  reduzir usando a regra 190 (subprogram_call)


State 299

   85 discriminant: L_PAREN type_specifier declarator_name R_PAREN .

    $padrão  reduzir usando a regra 85 (discriminant)


State 300

   94 short_case_statement: CASE IDENTIFIER . choices END_CASE
   95 choices: . choice
   96        | . choices choice
   97 choice: . WHEN IDENTIFIER THEN variable_declarations

    WHEN  deslocar, e ir ao estado 316

    choices  ir ao estado 317
    choice   ir ao estado 318


State 301

   91 qualified_name: . IDENTIFIER
  104 variable_initializer: . expression
  105                     | . L_BRACE R_BRACE
  106                     | . L_BRACE array_initializers R_BRACE
  108 array_initializers: array_initializers COMMA . variable_initializer
  109                   | array_initializers COMMA .  [COMMA, R_BRACE]
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    L_BRACE             deslocar, e ir ao estado 204
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    $padrão  reduzir usando a regra 109 (array_initializers)

    qualified_name                  ir ao estado 148
    variable_initializer            ir ao estado 319
    expression                      ir ao estado 206
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 302

  106 variable_initializer: L_BRACE array_initializers R_BRACE .

    $padrão  reduzir usando a regra 106 (variable_initializer)


State 303

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   42                    | FOR L_PAREN for_init for_expr R_PAREN . block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 58
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 60
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 61
    IF                  deslocar, e ir ao estado 62
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    PRINT               deslocar, e ir ao estado 68
    PRINTLN             deslocar, e ir ao estado 69
    READ                deslocar, e ir ao estado 70
    RETURN              deslocar, e ir ao estado 71
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    WHILE               deslocar, e ir ao estado 74

    block                                       ir ao estado 320
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 304

   41 iteration_statement: FOR L_PAREN for_init for_expr for_incr . R_PAREN block END_FOR

    R_PAREN  deslocar, e ir ao estado 321


State 305

   48 for_incr: expression_statements .  [R_PAREN]
   50 expression_statements: expression_statements . COMMA expression_statement

    COMMA  deslocar, e ir ao estado 280

    $padrão  reduzir usando a regra 48 (for_incr)


State 306

   46 for_expr: expression SEMICOLON .

    $padrão  reduzir usando a regra 46 (for_expr)


State 307

   50 expression_statements: expression_statements COMMA expression_statement .

    $padrão  reduzir usando a regra 50 (expression_statements)


State 308

   33 selection_statement: IF L_PAREN expression R_PAREN block . ELSIF elsif_staments END_IF
   34                    | IF L_PAREN expression R_PAREN block . ELSE block END_IF
   35                    | IF L_PAREN expression R_PAREN block . END_IF

    ELSE    deslocar, e ir ao estado 322
    ELSIF   deslocar, e ir ao estado 323
    END_IF  deslocar, e ir ao estado 324


State 309

  197 dims: dims L_SQ_PAREN R_SQ_PAREN .

    $padrão  reduzir usando a regra 197 (dims)


State 310

   60 print_statement: PRINT L_PAREN expression R_PAREN SEMICOLON .

    $padrão  reduzir usando a regra 60 (print_statement)


State 311

   61 println_statement: PRINTLN L_PAREN expression R_PAREN SEMICOLON .

    $padrão  reduzir usando a regra 61 (println_statement)


State 312

   58 read_statement: READ L_PAREN STRING_LITERAL COMMA argument_list . R_PAREN SEMICOLON
  195 argument_list: argument_list . COMMA expression

    COMMA    deslocar, e ir ao estado 297
    R_PAREN  deslocar, e ir ao estado 325


State 313

   59 read_statement: READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON .

    $padrão  reduzir usando a regra 59 (read_statement)


State 314

   40 iteration_statement: WHILE L_PAREN expression R_PAREN block . END_WHILE

    END_WHILE  deslocar, e ir ao estado 326


State 315

  195 argument_list: argument_list COMMA expression .

    $padrão  reduzir usando a regra 195 (argument_list)


State 316

   97 choice: WHEN . IDENTIFIER THEN variable_declarations

    IDENTIFIER  deslocar, e ir ao estado 327


State 317

   94 short_case_statement: CASE IDENTIFIER choices . END_CASE
   96 choices: choices . choice
   97 choice: . WHEN IDENTIFIER THEN variable_declarations

    END_CASE  deslocar, e ir ao estado 328
    WHEN      deslocar, e ir ao estado 316

    choice  ir ao estado 329


State 318

   95 choices: choice .

    $padrão  reduzir usando a regra 95 (choices)


State 319

  108 array_initializers: array_initializers COMMA variable_initializer .

    $padrão  reduzir usando a regra 108 (array_initializers)


State 320

   42 iteration_statement: FOR L_PAREN for_init for_expr R_PAREN block . END_FOR

    END_FOR  deslocar, e ir ao estado 330


State 321

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   41                    | FOR L_PAREN for_init for_expr for_incr R_PAREN . block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 58
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 60
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 61
    IF                  deslocar, e ir ao estado 62
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    PRINT               deslocar, e ir ao estado 68
    PRINTLN             deslocar, e ir ao estado 69
    READ                deslocar, e ir ao estado 70
    RETURN              deslocar, e ir ao estado 71
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    WHILE               deslocar, e ir ao estado 74

    block                                       ir ao estado 331
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 322

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   34                    | IF L_PAREN expression R_PAREN block ELSE . block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 58
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 60
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 61
    IF                  deslocar, e ir ao estado 62
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    PRINT               deslocar, e ir ao estado 68
    PRINTLN             deslocar, e ir ao estado 69
    READ                deslocar, e ir ao estado 70
    RETURN              deslocar, e ir ao estado 71
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    WHILE               deslocar, e ir ao estado 74

    block                                       ir ao estado 332
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 323

   33 selection_statement: IF L_PAREN expression R_PAREN block ELSIF . elsif_staments END_IF
   36 elsif_staments: . elsif_stament
   37               | . elsif_staments ELSIF elsif_stament
   38               | . ELSE block
   39 elsif_stament: . L_PAREN expression R_PAREN block

    ELSE     deslocar, e ir ao estado 333
    L_PAREN  deslocar, e ir ao estado 334

    elsif_staments  ir ao estado 335
    elsif_stament   ir ao estado 336


State 324

   35 selection_statement: IF L_PAREN expression R_PAREN block END_IF .

    $padrão  reduzir usando a regra 35 (selection_statement)


State 325

   58 read_statement: READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN . SEMICOLON

    SEMICOLON  deslocar, e ir ao estado 337


State 326

   40 iteration_statement: WHILE L_PAREN expression R_PAREN block END_WHILE .

    $padrão  reduzir usando a regra 40 (iteration_statement)


State 327

   97 choice: WHEN IDENTIFIER . THEN variable_declarations

    THEN  deslocar, e ir ao estado 338


State 328

   94 short_case_statement: CASE IDENTIFIER choices END_CASE .

    $padrão  reduzir usando a regra 94 (short_case_statement)


State 329

   96 choices: choices choice .

    $padrão  reduzir usando a regra 96 (choices)


State 330

   42 iteration_statement: FOR L_PAREN for_init for_expr R_PAREN block END_FOR .

    $padrão  reduzir usando a regra 42 (iteration_statement)


State 331

   41 iteration_statement: FOR L_PAREN for_init for_expr for_incr R_PAREN block . END_FOR

    END_FOR  deslocar, e ir ao estado 339


State 332

   34 selection_statement: IF L_PAREN expression R_PAREN block ELSE block . END_IF

    END_IF  deslocar, e ir ao estado 340


State 333

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   38 elsif_staments: ELSE . block
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 58
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 60
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 61
    IF                  deslocar, e ir ao estado 62
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    PRINT               deslocar, e ir ao estado 68
    PRINTLN             deslocar, e ir ao estado 69
    READ                deslocar, e ir ao estado 70
    RETURN              deslocar, e ir ao estado 71
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    WHILE               deslocar, e ir ao estado 74

    block                                       ir ao estado 341
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 334

   39 elsif_stament: L_PAREN . expression R_PAREN block
   91 qualified_name: . IDENTIFIER
  110 expression: . assignment_expression
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67

    qualified_name                  ir ao estado 148
    expression                      ir ao estado 342
    assignment_expression           ir ao estado 141
    unary_expression                ir ao estado 90
    logical_unary_expression        ir ao estado 91
    postfix_expression              ir ao estado 92
    primary_expression              ir ao estado 93
    arithmetic_unary_operator       ir ao estado 94
    logical_unary_operator          ir ao estado 95
    conditional_or_expression       ir ao estado 96
    conditional_and_expression      ir ao estado 97
    inclusive_or_expression         ir ao estado 98
    exclusive_or_expression         ir ao estado 99
    and_expression                  ir ao estado 100
    equality_expression             ir ao estado 101
    relational_expression           ir ao estado 102
    shift_expression                ir ao estado 103
    additive_expression             ir ao estado 104
    multiplicative_expression       ir ao estado 105
    cast_expression                 ir ao estado 106
    not_just_name                   ir ao estado 107
    complex_primary                 ir ao estado 108
    complex_primary_no_parenthesis  ir ao estado 109
    array_access                    ir ao estado 110
    field_access                    ir ao estado 111
    subprogram_call                 ir ao estado 112
    subprogram_access               ir ao estado 113


State 335

   33 selection_statement: IF L_PAREN expression R_PAREN block ELSIF elsif_staments . END_IF
   37 elsif_staments: elsif_staments . ELSIF elsif_stament

    ELSIF   deslocar, e ir ao estado 343
    END_IF  deslocar, e ir ao estado 344


State 336

   36 elsif_staments: elsif_stament .

    $padrão  reduzir usando a regra 36 (elsif_staments)


State 337

   58 read_statement: READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON .

    $padrão  reduzir usando a regra 58 (read_statement)


State 338

   65 variable_declarations: . variable_declaration
   66                      | . variable_declarations variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
   97 choice: WHEN IDENTIFIER THEN . variable_declarations

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    variable_declarations  ir ao estado 345
    variable_declaration   ir ao estado 115
    modifiers              ir ao estado 26
    modifier               ir ao estado 27
    type_specifier         ir ao estado 28
    type_name              ir ao estado 29
    primitive_type         ir ao estado 30
    qualified_name         ir ao estado 31


State 339

   41 iteration_statement: FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR .

    $padrão  reduzir usando a regra 41 (iteration_statement)


State 340

   34 selection_statement: IF L_PAREN expression R_PAREN block ELSE block END_IF .

    $padrão  reduzir usando a regra 34 (selection_statement)


State 341

   38 elsif_staments: ELSE block .

    $padrão  reduzir usando a regra 38 (elsif_staments)


State 342

   39 elsif_stament: L_PAREN expression . R_PAREN block

    R_PAREN  deslocar, e ir ao estado 346


State 343

   37 elsif_staments: elsif_staments ELSIF . elsif_stament
   39 elsif_stament: . L_PAREN expression R_PAREN block

    L_PAREN  deslocar, e ir ao estado 334

    elsif_stament  ir ao estado 347


State 344

   33 selection_statement: IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF .

    $padrão  reduzir usando a regra 33 (selection_statement)


State 345

   66 variable_declarations: variable_declarations . variable_declaration
   67 variable_declaration: . modifiers type_specifier variable_declarators SEMICOLON
   68                     | . type_specifier variable_declarators SEMICOLON
   69 modifiers: . modifier
   70          | . modifiers modifier
   71 modifier: . CONST
   72         | . STATIC
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
   97 choice: WHEN IDENTIFIER THEN variable_declarations .  [END_CASE, WHEN]

    IDENTIFIER  deslocar, e ir ao estado 1
    AUTO        deslocar, e ir ao estado 2
    BOOL        deslocar, e ir ao estado 3
    CHAR        deslocar, e ir ao estado 4
    CONST       deslocar, e ir ao estado 5
    DOUBLE      deslocar, e ir ao estado 6
    FLOAT       deslocar, e ir ao estado 8
    INT         deslocar, e ir ao estado 10
    LONG        deslocar, e ir ao estado 11
    SHORT       deslocar, e ir ao estado 13
    STRING      deslocar, e ir ao estado 14
    STATIC      deslocar, e ir ao estado 16

    $padrão  reduzir usando a regra 97 (choice)

    variable_declaration  ir ao estado 198
    modifiers             ir ao estado 26
    modifier              ir ao estado 27
    type_specifier        ir ao estado 28
    type_name             ir ao estado 29
    primitive_type        ir ao estado 30
    qualified_name        ir ao estado 31


State 346

   19 block: . local_variable_declarations_and_statements
   20 local_variable_declarations_and_statements: . local_variable_declarations_or_statements
   21                                           | . local_variable_declarations_and_statements local_variable_declarations_or_statements
   22 local_variable_declarations_or_statements: . local_variable_declaration_statement
   23                                          | . statement
   24 local_variable_declaration_statement: . type_specifier variable_declarators SEMICOLON
   25                                     | . STATIC type_specifier variable_declarators SEMICOLON
   26 statement: . assignment_expression SEMICOLON
   27          | . selection_statement
   28          | . iteration_statement
   29          | . jump_statement
   30          | . read_statement
   31          | . print_statement
   32          | . println_statement
   33 selection_statement: . IF L_PAREN expression R_PAREN block ELSIF elsif_staments END_IF
   34                    | . IF L_PAREN expression R_PAREN block ELSE block END_IF
   35                    | . IF L_PAREN expression R_PAREN block END_IF
   39 elsif_stament: L_PAREN expression R_PAREN . block
   40 iteration_statement: . WHILE L_PAREN expression R_PAREN block END_WHILE
   41                    | . FOR L_PAREN for_init for_expr for_incr R_PAREN block END_FOR
   42                    | . FOR L_PAREN for_init for_expr R_PAREN block END_FOR
   52 jump_statement: . BREAK IDENTIFIER SEMICOLON
   53               | . BREAK SEMICOLON
   54               | . CONTINUE IDENTIFIER SEMICOLON
   55               | . CONTINUE SEMICOLON
   56               | . RETURN expression SEMICOLON
   57               | . RETURN SEMICOLON
   58 read_statement: . READ L_PAREN STRING_LITERAL COMMA argument_list R_PAREN SEMICOLON
   59               | . READ L_PAREN STRING_LITERAL R_PAREN SEMICOLON
   60 print_statement: . PRINT L_PAREN expression R_PAREN SEMICOLON
   61 println_statement: . PRINTLN L_PAREN expression R_PAREN SEMICOLON
   73 type_specifier: . type_name
   74 type_name: . primitive_type
   75          | . qualified_name
   76 primitive_type: . AUTO
   77               | . BOOL
   78               | . CHAR
   79               | . DOUBLE
   80               | . FLOAT
   81               | . INT
   82               | . LONG
   83               | . SHORT
   84               | . STRING
   91 qualified_name: . IDENTIFIER
  111 assignment_expression: . conditional_or_expression
  112                      | . unary_expression assignment_operator assignment_expression
  113 unary_expression: . arithmetic_unary_operator cast_expression
  114                 | . logical_unary_expression
  115 logical_unary_expression: . postfix_expression
  116                         | . logical_unary_operator unary_expression
  117 postfix_expression: . primary_expression
  118 primary_expression: . qualified_name
  119                   | . not_just_name
  120 arithmetic_unary_operator: . OP_PLUS
  121                          | . OP_MINUS
  122 logical_unary_operator: . BITWISE_COMPLEMENT
  123                       | . LOG_NOT
  124 conditional_or_expression: . conditional_and_expression
  125                          | . conditional_or_expression LOG_OR conditional_and_expression
  126                          | . conditional_or_expression LOG_SC_OR conditional_and_expression
  127 conditional_and_expression: . inclusive_or_expression
  128                           | . conditional_and_expression LOG_AND inclusive_or_expression
  129                           | . conditional_and_expression LOG_SC_AND inclusive_or_expression
  130 inclusive_or_expression: . exclusive_or_expression
  131                        | . inclusive_or_expression BITWISE_OR exclusive_or_expression
  132 exclusive_or_expression: . and_expression
  133                        | . exclusive_or_expression BITWISE_OR_EXC and_expression
  134 and_expression: . equality_expression
  135               | . and_expression AMPERSAND equality_expression
  136 equality_expression: . relational_expression
  137                    | . equality_expression OP_EQ relational_expression
  138                    | . equality_expression OP_NE relational_expression
  139 relational_expression: . shift_expression
  140                      | . relational_expression OP_LT shift_expression
  141                      | . relational_expression OP_GT shift_expression
  142                      | . relational_expression OP_LET shift_expression
  143                      | . relational_expression OP_GET shift_expression
  144                      | . relational_expression TYPEOF type_specifier
  145 shift_expression: . additive_expression
  146                 | . shift_expression L_SHIFT additive_expression
  147                 | . shift_expression R_SHIFT additive_expression
  148 additive_expression: . multiplicative_expression
  149                    | . additive_expression OP_PLUS multiplicative_expression
  150                    | . additive_expression OP_MINUS multiplicative_expression
  151 multiplicative_expression: . cast_expression
  152                          | . multiplicative_expression OP_ASTERISK cast_expression
  153                          | . multiplicative_expression OP_DIV cast_expression
  154                          | . multiplicative_expression OP_MOD cast_expression
  155 cast_expression: . unary_expression
  156                | . L_PAREN primitive_type_expression R_PAREN cast_expression
  157                | . L_PAREN user_type_expression R_PAREN cast_expression
  158                | . L_PAREN expression R_PAREN logical_unary_expression
  173 not_just_name: . complex_primary
  174 complex_primary: . L_PAREN expression R_PAREN
  175                | . complex_primary_no_parenthesis
  176 complex_primary_no_parenthesis: . BOOL_LITERAL
  177                               | . OCTAL
  178                               | . DECIMAL
  179                               | . HEX
  180                               | . FLOATING_POINT
  181                               | . NNULL
  182                               | . STRING_LITERAL
  183                               | . CHAR_LITERAL
  184                               | . array_access
  185                               | . field_access
  186                               | . subprogram_call
  187 array_access: . qualified_name L_SQ_PAREN expression R_SQ_PAREN
  188             | . complex_primary L_SQ_PAREN expression R_SQ_PAREN
  189 field_access: . postfix_expression DOT IDENTIFIER
  190 subprogram_call: . subprogram_access L_PAREN argument_list R_PAREN
  191                | . subprogram_access L_PAREN R_PAREN
  192 subprogram_access: . complex_primary_no_parenthesis
  193                  | . qualified_name

    IDENTIFIER          deslocar, e ir ao estado 1
    STRING_LITERAL      deslocar, e ir ao estado 51
    DECIMAL             deslocar, e ir ao estado 52
    HEX                 deslocar, e ir ao estado 53
    OCTAL               deslocar, e ir ao estado 54
    FLOATING_POINT      deslocar, e ir ao estado 55
    BOOL_LITERAL        deslocar, e ir ao estado 56
    CHAR_LITERAL        deslocar, e ir ao estado 57
    AUTO                deslocar, e ir ao estado 2
    BOOL                deslocar, e ir ao estado 3
    BREAK               deslocar, e ir ao estado 58
    BITWISE_COMPLEMENT  deslocar, e ir ao estado 59
    CHAR                deslocar, e ir ao estado 4
    CONTINUE            deslocar, e ir ao estado 60
    DOUBLE              deslocar, e ir ao estado 6
    FLOAT               deslocar, e ir ao estado 8
    FOR                 deslocar, e ir ao estado 61
    IF                  deslocar, e ir ao estado 62
    INT                 deslocar, e ir ao estado 10
    L_PAREN             deslocar, e ir ao estado 63
    LOG_NOT             deslocar, e ir ao estado 64
    LONG                deslocar, e ir ao estado 11
    NNULL               deslocar, e ir ao estado 65
    OP_PLUS             deslocar, e ir ao estado 66
    OP_MINUS            deslocar, e ir ao estado 67
    PRINT               deslocar, e ir ao estado 68
    PRINTLN             deslocar, e ir ao estado 69
    READ                deslocar, e ir ao estado 70
    RETURN              deslocar, e ir ao estado 71
    SHORT               deslocar, e ir ao estado 13
    STRING              deslocar, e ir ao estado 14
    STATIC              deslocar, e ir ao estado 72
    WHILE               deslocar, e ir ao estado 74

    block                                       ir ao estado 348
    local_variable_declarations_and_statements  ir ao estado 77
    local_variable_declarations_or_statements   ir ao estado 78
    local_variable_declaration_statement        ir ao estado 79
    statement                                   ir ao estado 80
    selection_statement                         ir ao estado 81
    iteration_statement                         ir ao estado 82
    jump_statement                              ir ao estado 83
    read_statement                              ir ao estado 84
    print_statement                             ir ao estado 85
    println_statement                           ir ao estado 86
    type_specifier                              ir ao estado 87
    type_name                                   ir ao estado 29
    primitive_type                              ir ao estado 30
    qualified_name                              ir ao estado 88
    assignment_expression                       ir ao estado 89
    unary_expression                            ir ao estado 90
    logical_unary_expression                    ir ao estado 91
    postfix_expression                          ir ao estado 92
    primary_expression                          ir ao estado 93
    arithmetic_unary_operator                   ir ao estado 94
    logical_unary_operator                      ir ao estado 95
    conditional_or_expression                   ir ao estado 96
    conditional_and_expression                  ir ao estado 97
    inclusive_or_expression                     ir ao estado 98
    exclusive_or_expression                     ir ao estado 99
    and_expression                              ir ao estado 100
    equality_expression                         ir ao estado 101
    relational_expression                       ir ao estado 102
    shift_expression                            ir ao estado 103
    additive_expression                         ir ao estado 104
    multiplicative_expression                   ir ao estado 105
    cast_expression                             ir ao estado 106
    not_just_name                               ir ao estado 107
    complex_primary                             ir ao estado 108
    complex_primary_no_parenthesis              ir ao estado 109
    array_access                                ir ao estado 110
    field_access                                ir ao estado 111
    subprogram_call                             ir ao estado 112
    subprogram_access                           ir ao estado 113


State 347

   37 elsif_staments: elsif_staments ELSIF elsif_stament .

    $padrão  reduzir usando a regra 37 (elsif_staments)


State 348

   39 elsif_stament: L_PAREN expression R_PAREN block .

    $padrão  reduzir usando a regra 39 (elsif_stament)
